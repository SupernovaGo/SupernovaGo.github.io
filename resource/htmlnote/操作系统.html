<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex: 2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }
.md-alert.md-alert-note { border-left-color: rgb(9, 105, 218); }
.md-alert.md-alert-important { border-left-color: rgb(130, 80, 223); }
.md-alert.md-alert-warning { border-left-color: rgb(154, 103, 0); }
.md-alert.md-alert-tip { border-left-color: rgb(31, 136, 61); }
.md-alert.md-alert-caution { border-left-color: rgb(207, 34, 46); }
.md-alert { padding: 0px 1em; margin-bottom: 16px; color: inherit; border-left: 0.25em solid rgb(0, 0, 0); }
.md-alert-text-note { color: rgb(9, 105, 218); }
.md-alert-text-important { color: rgb(130, 80, 223); }
.md-alert-text-warning { color: rgb(154, 103, 0); }
.md-alert-text-tip { color: rgb(31, 136, 61); }
.md-alert-text-caution { color: rgb(207, 34, 46); }
.md-alert-text { font-size: 0.9rem; font-weight: 700; }
.md-alert-text svg { fill: currentcolor; position: relative; top: 0.125em; margin-right: 1ch; overflow: visible; }
.md-alert-text-container::after { content: attr(data-text); text-transform: capitalize; pointer-events: none; margin-right: 1ch; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


/* you can override the default max-width size here or override each style by your custom css */

#write {
    font-size: 1.25rem;
    line-height: 1.625rem;
    max-width: 80rem;
}

p {
    line-height: 2rem;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875em;
}
@import "";
@import "";

/* FONTS */

/* VARIABLES */

:root {
  --theme-0: rgb(255, 255, 255);

  /* Slate grayscale */
  --theme-50: #f8fafc;
  --theme-100: #f1f5f9;
  --theme-200: #e2e8f0;
  --theme-300: #cbd5e1;
  --theme-400: #94a3b8;
  --theme-500: #64748b;
  --theme-600: #475569;
  --theme-700: #334155;
  --theme-800: #1e293b;
  --theme-900: #0f172a;

  /* Tailwind variables */
  --tw-primary: #62bbf3;

  --tw-prose-body: var(--theme-700);
  --tw-prose-headings: var(--theme-900);
  --tw-prose-lead: var(--theme-600);
  --tw-prose-links: var(--theme-900);
  --tw-prose-bold: var(--theme-900);
  --tw-prose-counters: var(--theme-500);
  --tw-prose-bullets: var(--theme-300);
  --tw-prose-hr: var(--theme-200);
  --tw-prose-quotes: var(--theme-900);
  --tw-prose-quote-borders: var(--theme-200);
  --tw-prose-captions: var(--theme-500);
  --tw-prose-code: var(--theme-900);
  --tw-prose-pre-code: var(--theme-100);
  --tw-prose-pre-bg: var(--theme-800);
  --tw-prose-th-borders: var(--theme-300);
  --tw-prose-td-borders: var(--theme-200);
  --tw-prose-bg: var(--theme-0);
  --tw-prose-meta: var(--theme-500);
  --tw-prose-meta-bg: var(--theme-100);

  --tw-prose-invert-body: var(--theme-300);
  --tw-prose-invert-headings: var(--theme-0);
  --tw-prose-invert-lead: var(--theme-400);
  --tw-prose-invert-links: var(--theme-0);
  --tw-prose-invert-bold: var(--theme-0);
  --tw-prose-invert-counters: var(--theme-400);
  --tw-prose-invert-bullets: var(--theme-600);
  --tw-prose-invert-hr: var(--theme-700);
  --tw-prose-invert-quotes: var(--theme-100);
  --tw-prose-invert-quote-borders: var(--theme-700);
  --tw-prose-invert-captions: var(--theme-400);
  --tw-prose-invert-code: var(--theme-0);
  --tw-prose-invert-pre-bg: var(--theme-900);
  --tw-prose-invert-th-borders: var(--theme-600);
  --tw-prose-invert-td-borders: var(--theme-700);
  --tw-prose-invert-bg: var(--theme-800);
  --tw-prose-invert-meta: var(--theme-400);
  --tw-prose-invert-meta-bg: var(--theme-700);

  --tw-highlight-color: #fde047; /* yellow-300 */
  --tw-drop-shadow-md: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07))
    drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));
  --tw-button-hover-bg: var(--theme-100);

  --tw-button-hover-bg-inverted: var(--theme-700);

  /* Typora variables */

  --background: var(--tw-prose-bg);
  --bg-color: var(--tw-prose-bg);
  --text-color: var(--tw-prose-body);
  --primary-color: var(--tw-primary);
  --md-char-color: var(--theme-400);
  --meta-content-color: var(--theme-500);
  --typora-source-body: var(--theme-800);
  --heading-char-color: var(--md-char-color);
  --mermaid-theme: neutral;
  --active-toggle-btn-color: var(--theme-200);

  --md-char-color-inverted: var(--theme-500);
  --meta-content-color-inverted: var(--theme-400);
  --typora-source-body-inverted: var(--theme-300);
  --mermaid-theme-inverted: dark;
  --active-toggle-btn-color-inverted: var(--theme-400);

  /* Sidebar */
  --side-bar-bg-color: var(--tw-prose-bg);
  --active-file-bg-color: var(--theme-100);
  --active-file-text-color: var(--tw-prose-bold);
  --active-file-border-color: var(--theme-100);
  --panel-border-color: var(--theme-300);
  --blur-text-color: var(--theme-300);
  --window-border: 1px solid var(--theme-200);
  --item-hover-bg-color: var(--theme-100);
  --search-hit-text-bg-color: var(--theme-200);
  --search-hit-text-font-color: inherit;
  --search-select-text-color: var(--select-text-font-color);
  --search-select-bg-color: var(--select-text-bg-color);

  --blur-text-color-inverted: var(--theme-500);
  --panel-border-color-inverted: var(--theme-700);
  --active-file-bg-color-inverted: var(--theme-700);
  --window-border-inverted: 1px solid var(--theme-700);
  --search-hit-text-bg-color-inverted: var(--theme-700);
  --search-hit-text-font-color-inverted: var(--theme-0);
  --search-select-bg-color-inverted: var(--theme-400);
  --rawblock-edit-panel-bd: var(--tw-prose-pre-bg);
  --item-hover-bg-color-inverted: var(--theme-700);

  --monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", "Courier New", monospace;

  /* Custom */
  --footnote: var(--tw-prose-body);
  /* I'd love to use the --theme grayscale for --footnote-bg, but there's (currently)
  no way to add an alpha-channel to a CSS variable (and we need the transparency
  because otherwise the caret wil not be visible), so I here just used a hardcoded
  copy of --theme-500 */
  --footnote-bg: #94a3b855;
  --button-bg: var(--theme-200);

  --button-bg-inverted: var(--theme-600);

  --md-grid-header: var(--theme-100);
  --md-grid-header-ext: var(--theme-400);
  --md-grid-ext: var(--theme-300);
  --md-grid-header-active: var(--theme-500);
  --md-grid-active: var(--theme-400);
  --md-grid-border-color: var(--theme-500);

  --md-grid-header-inverted: var(--theme-600);
  --md-grid-header-ext-inverted: var(--theme-500);
  --md-grid-ext-inverted: var(--theme-600);
  --md-grid-header-active-inverted: var(--theme-400);
  --md-grid-active-inverted: var(--theme-500);
  --md-grid-border-color-inverted: var(--theme-200);

  --code-blocks-font-size: 0.9em;
  --inline-code-font-size: 0.9em;
}

.ty-file-search-match-text {
  background-color: var(--search-hit-text-bg-color);
}

/* TAILWIND RESET */

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: currentColor;
  /* 2 */
}

::before,
::after {
  --tw-content: "";
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
*/

#text {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
  tab-size: 4;
  /* 3 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

#text {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

#write {
    background: #131b29;
    color: #a9aaab;
    margin: 0 auto;
    max-width: 800px;
    padding: 30px;
    padding-bottom: 100px;
    position: static;
    width: 90%;
}

#write>ul:first-child,
#write>ol:first-child {
    margin-top: 30px;
}

a {
    color: #71bfd9;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    cursor: text;
    font-weight: bold;
    line-height: 1.4;
    margin-bottom: 1rem;
    margin-top: 1rem;
    position: relative;
}

#write h1,
#write h2,
#write h3,
#write h4,
#write h5,
#write h6,
#write pre {
    color: #dfb057;
    width: auto;
}

#write h1::before,
#write h2::before,
#write h3::before,
#write h4::before,
#write h5::before,
#write h6::before {
    border-radius: 0;
    bottom: 0;
    color: #517090;
    float: none;
    font-size: 1rem;
    font-variant: 'small-caps';
    font-weight: bold;
    left: auto;
    line-height: 20px;
    padding: 0;
    position: absolute;
    right: calc(100% + 10px);
    vertical-align: baseline;
}

#write h1 {
    font-size: 3.2rem;
    margin: 3rem 0;
    text-align: center;
}

#write h1::before {
    bottom: 1.45rem;
    content: 'H1';
}

#write h2 {
    font-size: 2.2rem;
    margin: 1.4rem 0;
}

#write h2::before {
    bottom: 0.2rem;
    content: 'H2';
}

#write h3 {
    font-size: 2rem;
    margin: 1rem 0;
}

#write h3::before {
    bottom: 0.18rem;
    content: 'H3';
}

#write h4 {
    font-size: 1.7rem;
    margin: 0.8rem 3;
}

#write h4::before {
    content: 'H4';
    bottom: 0.15rem;
}

#write h5 {
  font-size: 1.5rem;
  margin: 0.5rem 0;
}

#write h6 {
    font-size: 1.3rem;
    margin: 0.2rem,0;
}

#write h5::before,
#write h6::before {
    bottom: 0.1rem;
}

#write h5::before {
    content: 'H5';
}

#write h6::before {
    content: 'H6';
}

h1::after, h2::after {
  content: ""; /* 必须设置 content */
  display: block; /* 确保伪元素占据一行 */
  border-bottom: 2px solid #ccc; /* 分割线样式：颜色为灰色，厚度为 1px */
  margin-top: 4px; /* 分割线与标题的间距 */
  margin-bottom: 8px; /* 分割线与下文的间距 */
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
  font-family: "LXGWWenKai-Blod";
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured `mono` font family by default.
2. Correct the odd `em` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: var(--monospace);
  /* 1 */
  font-size: 1em;
  /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  line-height: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/* TAILWIND PROSE IMPLEMENTATION */

#write {
  font-size: 1.25rem;
  line-height: 1.625rem;
  max-width: 80rem;
}

html,
body {
  font-family: "LXGWWenKai-Regular";
}

/* on Windows/Linux, it is the part that is not titlebar or status bar. */
content,
titlebar {
  background: var(--tw-prose-bg);
}

#write {
  padding-top: 100px;
  padding-bottom: 100px;
  color: var(--tw-prose-body);
  max-width: 60ch;
}

#write > :where(:first-child) {
  margin-top: 0;
}

#write > :where(:last-child) {
  margin-bottom: 0;
}

/**
  * ---------------------
  * Block Elements
  */

/* yaml */
pre.md-meta-block {
  color: var(--tw-prose-meta);
  background-color: var(--tw-prose-meta-bg);
  font-weight: 400;
  font-size: var(--code-blocks-font-size);
  line-height: 1.7777778;
  border-radius: 0.5rem /* 8px */;
  padding: 1.1111111em 1.3333333em;
  margin-bottom: 2.8em;
}

/* headings */
h1 {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.5rem;
  margin-top: 0;
  margin-bottom: 1.5rem;
  line-height: 2.75rem;
  letter-spacing: -1.5px;
}

h1 strong {
  font-weight: 900;
}

h2 {
  color: var(--tw-prose-headings);
  font-weight: bold;
  font-size: 1.63rem;
  margin-top: 1.5555556em;
  margin-bottom: 1.5rem;
  line-height: 1.875rem;
  letter-spacing: -1px;
}

h2 strong {
  font-weight: 800;
}

h3 {
  color: var(--tw-prose-headings);
  font-weight: bold;
  font-size: 1.17rem;
  margin-top: 1.6em;
  margin-bottom: 1.5rem;
  line-height: 1.5rem;
  letter-spacing: -1px;
}

h3 strong {
  font-weight: 700;
}

h4 {
  color: var(--tw-prose-headings);
  font-size: 1.12rem;
  font-weight: 600;
  margin-top: 1.8em;
  margin-bottom: 1.5rem;
  line-height: 1.375rem;
}

h4 strong {
  font-weight: 700;
}

h2 code {
  font-size: 0.8611111em;
}

h3 code {
  font-size: 0.9em;
}

h2 + * {
  margin-top: 0;
}

h3 + * {
  margin-top: 0;
}

h4 + * {
  margin-top: 0;
}

h5 {
  font-size: 0.97rem;
  line-height: 1.25rem;
  margin-bottom: 1.5rem;
  font-weight: bold;
}

h6 {
  font-size: 0.93rem;
  line-height: 1rem;
  margin-bottom: 0.75rem;
}

/* table */

table {
  width: 100%;
  table-layout: auto;
  text-align: left;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.9em;
  line-height: 1.5555556;
}

/* table header */

thead {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}

thead th {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-right: 0.6666667em;
  padding-bottom: 0.8888889em;
  padding-left: 0.6666667em;
}

thead th:first-child {
  padding-left: 0;
}

thead th:last-child {
  padding-right: 0;
}

tbody tr {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}

tbody tr:last-child {
  border-bottom-width: 0;
}

tbody td {
  vertical-align: baseline;
  padding-top: 0.8888889em;
  padding-right: 0.6666667em;
  padding-bottom: 0.8888889em;
  padding-left: 0.6666667em;
}

tbody td:first-child {
  padding-left: 0;
}

tbody td:last-child {
  padding-right: 0;
}

.md-grid-board tr[row="1"] {
  background-color: var(--md-grid-header);
}

.md-grid-board a:hover,
.md-grid-board a.md-active {
  background: var(--md-grid-active);
}

.md-grid-board tr[row="1"] a:hover,
.md-grid-board tr[row="1"] a.md-active {
  background: var(--md-grid-header-active);
}

.md-grid-board .md-grid-ext {
  background: var(--md-grid-ext);
}

.md-grid-board tr[row="1"] .md-grid-ext {
  background: var(--md-grid-header-ext);
}

.md-grid-board a {
  border-color: var(--md-grid-border-color) !important;
}

/* lists */

ol {
  list-style-type: decimal;
  padding-left: 1em;
}

li {
  margin-top: 0.6em;
  margin-bottom: 0.6em;
}

ul {
  list-style-type: disc;
  padding-left: 1em;
}

#write ul.task-list {
  padding-left: 0;
}

#write li.task-list-item {
  padding-left: 0.4em;
}

#write input[type="checkbox"] {
  margin-left: -1em;
}

input[checked] ~ * {
  opacity: 0.7;
  text-decoration: line-through;
}

ol > li::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}

ul > li::marker {
  color: var(--tw-prose-bullets);
}

ul > li,
ol > li {
  padding-left: 0.4em;
}

ul > li p,
ol > li p {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}

#write > ul > li > :not(input):first-child,
#write > ol > li > :not(input):first-child,
#write > ul > li > input + *,
#write > ol > li > input + * {
  margin-top: 1.2em;
}

#write > ul > li > *:last-child,
#write > ol > li > *:last-child {
  margin-bottom: 1.2em;
}

#write ul > li > p:only-child,
#write ol > li > p:only-child,
#write ul > li > input + p:last-child,
#write ol > li > input + p:last-child {
  margin-top: 0;
  margin-bottom: 0;
}

ul ul,
ul ol,
ol ul,
ol ol {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}

/* blockquote */
blockquote {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-left-width: 0.25rem;
  border-left-color: var(--tw-prose-quote-borders);
  quotes: "\201C""\201D""\2018""\2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-left: 1.0666667em;
}

blockquote p:first-of-type::before {
  content: open-quote;
}

blockquote p:last-of-type::after {
  content: close-quote;
}

/* hr */
hr {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
}

[mdtype="hr"] {
  margin-top: 2.8em;
  margin-bottom: 2.8em;
}

p {
  margin-top: 1.2em;
  margin-bottom: 1.2em;
  color: #eeeeee;
}

.in-text-selection,::selection {
  background-color: var(--select-text-bg-color);
}

/* diagram panel */
.md-diagram-panel {
  color: var(--tw-prose-body);
}

.enable-diagrams .md-diagram .code-tooltip {
  bottom: -1.9em;
  right: 0;
}

.md-fences-adv-panel {
  margin-top: 1.3em;
}

/* footnote definition */
sup.md-footnote {
  color: var(--footnote);
  background-color: var(--footnote-bg);
}

.footnotes {
  font-size: 0.85em;
}

.md-reverse-footnote-area a {
  font-family: "LXGWWenKai-Regular";
  text-decoration: none;
  color: var(--tw-primary);
  border-radius: 3px;
}

.md-hover-tip .code-tooltip-content {
  font-size: 1.05rem;
  line-height: 1.6;
  padding: 0.8em 1.2em;
}

.md-reverse-footnote-area a:hover {
  background-color: var(--item-hover-bg-color);
}

.md-def-name:before {
  color: var(--md-char-color);
}

.md-rawblock.md-rawblock-on-edit,
.md-rawblock:hover {
  color: var(--tw-prose-pre-code);
}

.md-inline-math script {
  color: var(--tw-prose-code);
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: var(--tw-highlight-color) !important;
}

g[data-mml-node="merror"] > g {
  fill: #000 !important;
  stroke: #000 !important;
}

.code-tooltip {
  color: var(--tw-prose-pre-code);
}

.code-tooltip .md-mathjax-preview {
  color: var(--tw-prose-body);
}

.md-htmlblock-container,
.md-rawblock-input.md-rawblock-control,
.md-htmlblock-panel.md-rawblock-control,
.md-math-container {
  border-radius: 0.5rem 0 0.5rem 0.5rem;
}

.md-rawblock-input {
  font-size: var(--code-blocks-font-size);
  padding: 0 1.3333333em;
}

.md-mathblock-panel .md-rawblock-input.md-rawblock-control {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-radius: 0;
}

.md-mathblock-panel .md-rawblock-before {
  padding-top: 1.1em;
  border-top-left-radius: 0.5rem;
}

.md-mathblock-panel .md-rawblock-after {
  padding-bottom: 1.1em;
  border-bottom-left-radius: 0.5rem;
  border-bottom-right-radius: 0.5rem;
}

.md-htmlblock-panel .md-rawblock-input {
  padding-top: 1.1111111em;
  padding-bottom: 1.1111111em;
}

.md-mathblock-panel .md-rawblock-before,
.md-mathblock-panel .md-rawblock-after {
  font-size: var(--code-blocks-font-size);
  padding-left: calc(4px + 1.3333333em);
  color: var(--code-bracket);
}

.md-rawblock-tooltip {
  color: var(--tw-prose-pre-code);
  border-radius: 0.5rem 0.5rem 0 0;
}

.md-rawblock-tooltip-name {
  opacity: 1;
}

.md-comment {
  font-size: var(--inline-code-font-size);
  color: var(--code-comment);
}

.md-raw-inline,
.md-tag,
[md-inline="linebreak"],
.md-image > .md-meta,
.md-inline-math.md-expand > .md-inline-math-container {
  font-size: var(--code-blocks-font-size);
}

/**
  * Code Fences
  * see http://support.typora.io/Code-Block-Styles
  */

.md-fences {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  font-weight: 400;
  font-size: var(--code-blocks-font-size);
  line-height: 1.7777778;
  margin-top: 2em;
  margin-bottom: 2em;
  border-radius: 0.5rem /* 8px */;
  padding: 1.1111111em 1.3333333em;
}

.md-fences.md-focus {
  border-bottom-right-radius: 0;
}

.md-fences > .code-tooltip {
  height: 1.8rem;
  bottom: -1.8rem;
  font-size: 0.9rem;
  border-radius: 0 0 0.5rem 0.5rem;
}

.code-tooltip .ty-input {
  min-width: 10rem;
}

pre code {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}

pre code::before {
  content: none;
}

pre code::after {
  content: none;
}

/* SYNTAX HIGHLIGHTING */

:root {
  --code-neutral: var(--theme-800);
  --code-cursor: var(--theme-900);
  --code-string: rgb(14, 165, 233); /* sky-500 */
  --code-number: rgb(245, 158, 11); /* amber-500 */
  --code-tag: rgb(236, 72, 153); /* pink-500 */
  --code-color: rgb(154, 154, 154);
  --code-color-bg: rgb(213, 213, 205);
  --code-variable: var(--theme-700);
  --code-operator: var(--theme-600);
  --code-comment: var(--theme-500);
  --code-bracket: var(--theme-500);
  --code-citation: var(--theme-500);

  --code-neutral-inverted: var(--theme-100);
  --code-cursor-inverted: var(--theme-50);
  --code-string-inverted: #7dd4fc; /* sky-300 */
  --code-number-inverted: #fde68a; /* amber-100 */
  --code-tag-inverted: #f472b5; /* pink-400 */
  --code-variable-inverted: var(--theme-200);
  --code-operator-inverted: var(--theme-400);
  --code-comment-inverted: var(--theme-400);
  --code-bracket-inverted: var(--theme-500);
  --code-citation-inverted: var(--theme-400);
}

#write .cm-s-inner {
  --code-neutral: var(--code-neutral-inverted);
  --code-cursor: var(--code-cursor-inverted);
  --code-string: var(--code-string-inverted);
  --code-number: var(--code-number-inverted);
  --code-tag: var(--code-tag-inverted);
  --code-variable: var(--code-variable-inverted);
  --code-operator: var(--code-operator-inverted);
  --code-comment: var(--code-comment-inverted);
  --code-bracket: var(--code-bracket-inverted);
  --code-citation: var(--code-citation-inverted);
}

.CodeMirror-selectedtext {
  background-color: transparent;
}
.CodeMirror-cursor {
  border-left: 1px solid var(--code-cursor) !important;
}
.CodeMirror-gutters {
  border-color: var(--code-comment);
}
.cm-s-inner span.cm-string {
  color: var(--code-string);
}

.cm-s-inner span.cm-number {
  color: var(--code-number);
}

.cm-s-inner span.cm-tag,
.cm-s-inner span.cm-keyword,
.cm-s-inner span.cm-qualifier {
  color: var(--code-tag);
}

.cm-s-inner .CodeMirror-guttermarker,
.cm-s-inner .CodeMirror-guttermarker-subtle,
.cm-s-inner span.cm-comment.cm-def,
.cm-s-inner span.cm-comment.cm-type,
.cm-s-inner span.cm-builtin,
.cm-s-inner span.cm-type,
.cm-s-inner span.cm-header,
.cm-s-inner span.cm-link,
.cm-s-inner span.cm-error {
  background: transparent;
  color: var(--code-neutral);
}

.cm-s-inner span.cm-attribute,
.cm-s-inner span.cm-property,
.cm-s-inner span.cm-variable,
.cm-s-inner span.cm-variable-2,
.cm-s-inner span.cm-variable-3,
.cm-s-inner span.cm-type,
.cm-s-inner span.cm-atom,
.cm-s-inner span.cm-def {
  color: var(--code-variable);
}
.cm-s-inner span.cm-comment,
.cm-s-inner .CodeMirror-linenumber {
  color: var(--code-comment);
}
.cm-s-inner span.cm-operator {
  color: var(--code-operator);
}
.cm-s-inner span.cm-bracket,
.cm-s-inner span.cm-tag.cm-bracket,
.cm-s-inner span.cm-meta {
  color: var(--code-bracket);
}

.cm-s-inner span.cm-link {
  text-decoration: underline;
}

/**
  * Inline Elements
  */

/* basic styles */

code {
  color: rgb(47, 206, 47);
  background-color: var(--code-color-bg);
  border-radius: 0.3rem;
  padding: 0.1rem 0.3rem;
  margin: 0.1rem 0.1rem;
}

code::before {
  content: none;
}

code::after {
  content: none;
}

[md-inline="code"].md-expand > code::before,
[md-inline="code"].md-expand > code::after {
  content: "";
}

a code {
  color: var(--tw-prose-links);
}

mark code {
  color: inherit;
}

strong {
  color: rgb(211, 211, 77);
  font-weight: 600;
}

a {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}

/* A block-level image should have a total top and bottom margin of 2em.
It is always wrapped in a paragraph with 1.2em vertical margin, hence we
add 0.8 here */
p > .md-image:only-child {
  margin-top: 0.8em !important;
  margin-bottom: 0.8em !important;
}

.md-image > .md-meta {
  color: var(--tw-prose-code);
}

/* extend styles */

mark {
  border-radius: 3px;
  padding: 0 2px;
  background-color: var(--tw-highlight-color);
}

/**
  * Source Code Mode
  * see http://support.typora.io/Code-Block-Styles
  */

.cm-s-typora-default .CodeMirror-activeline-background {
  background-color: var(--item-hover-bg-color);
}

#typora-source {
  font-family: var(--monospace);
  color: var(--typora-source-body);
}

#typora-source .cm-header {
  color: var(--code-tag);
}

#typora-source .cm-link {
  color: var(--code-string);
}

#typora-source .cm-string {
  color: var(--code-string);
}

#typora-source .cm-comment {
  color: var(--code-comment);
}

#typora-source .cm-atom {
  color: var(--code-citation);
}

#typora-source .cm-tag {
  color: var(--code-tag);
}

#typora-source .cm-attribute {
  color: var(--code-variable);
}

#typora-source .cm-bracket {
  color: var(--code-bracket);
}

.file-list-item-file-ext-part {
  opacity: 0.5;
}

#write div.md-toc-tooltip {
  background-color: var(--tw-prose-bg);
}

.md-toc {
  font-size: 0.8em;
}

.md-toc-h1 .md-toc-inner {
  margin-left: 0;
}

.md-toc-h2 .md-toc-inner {
  margin-left: 1em;
}

.md-toc-h3 .md-toc-inner {
  margin-left: 2em;
}

.md-toc-h4 .md-toc-inner {
  margin-left: 3em;
}

.md-toc-h5 .md-toc-inner {
  margin-left: 4em;
}

.md-toc-h6 .md-toc-inner {
  margin-left: 5em;
}

#typora-sidebar {
  border-right: var(--window-border);
}

.sidebar-tab {
  text-transform: none;
  font-weight: 700;
  font-size: 1.1em;
}

.md-search-hit {
  color: var(--search-hit-text-font-color);
  background-color: var(--search-hit-text-bg-color);
}

#md-searchpanel {
  box-shadow: none;
  filter: var(--tw-drop-shadow-md);
}

#md-searchpanel .btn:not(.close-btn):hover {
  box-shadow: none;
  -webkit-box-shadow: none;
  background-color: var(--tw-button-hover-bg);
}

#md-searchpanel input,
#md-searchpanel .btn,
#searchpanel-msg {
  border-radius: 5px;
}

#searchpanel-msg {
  color: var(--theme-500);
  border-color: var(--theme-300);
  background: var(--theme-100);
}

.form-control {
  border-color: var(--panel-border-color);
}

.btn-default {
  background-color: var(--button-bg);
}

/* you can override the default max-width size here or override each style by your custom css */

#write {
    font-size: 1.25rem;
    line-height: 1.625rem;
    max-width: 80rem;
}

p {
    line-height: 2rem;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875em;
}
@import "";
@import "";
@import "";

:root {
  --tw-prose-body: var(--tw-prose-invert-body);
  --tw-prose-headings: var(--tw-prose-invert-headings);
  --tw-prose-lead: var(--tw-prose-invert-lead);
  --tw-prose-links: var(--tw-prose-invert-links);
  --tw-prose-bold: var(--tw-prose-invert-bold);
  --tw-prose-counters: var(--tw-prose-invert-counters);
  --tw-prose-bullets: var(--tw-prose-invert-bullets);
  --tw-prose-hr: var(--tw-prose-invert-hr);
  --tw-prose-quotes: var(--tw-prose-invert-quotes);
  --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
  --tw-prose-code: var(--tw-prose-invert-code);
  --tw-prose-captions: var(--tw-prose-invert-captions);
  --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
  --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
  --tw-prose-td-borders: var(--tw-prose-invert-td-borders);
  --tw-prose-bg: var(--tw-prose-invert-bg);
  --tw-prose-meta: var(--tw-prose-invert-meta);
  --tw-prose-meta-bg: var(--tw-prose-invert-meta-bg); 
  --select-text-bg-color: rgb(35, 92, 197);

  --tw-button-hover-bg: var(--tw-button-hover-bg-inverted);

  --md-char-color: var(--md-char-color-inverted);
  --meta-content-color: var(--meta-content-color-inverted);
  --panel-border-color: var(--panel-border-color-inverted);
  --active-file-bg-color: var(--active-file-bg-color-inverted);
  --window-border: var(--window-border-inverted);
  --search-hit-text-bg-color: var(--search-hit-text-bg-color-inverted);
  --search-hit-text-font-color: var(--search-hit-text-font-color-inverted);
  --search-select-bg-color: var(--search-select-bg-color-inverted);
  --blur-text-color: var(--blur-text-color-inverted);
  --item-hover-bg-color: var(--item-hover-bg-color-inverted);
  --typora-source-body: var(--typora-source-body-inverted);
  --mermaid-theme: var(--mermaid-theme-inverted);
  --active-toggle-btn-color: var(--active-toggle-btn-color-inverted);

  --code-neutral: var(--code-neutral-inverted);
  --code-cursor: var(--code-cursor-inverted);
  --code-string: var(--code-string-inverted);
  --code-number: var(--code-number-inverted);
  --code-tag: var(--code-tag-inverted);
  --code-variable: var(--code-variable-inverted);
  --code-operator: var(--code-operator-inverted);
  --code-comment: var(--code-comment-inverted);
  --code-bracket: var(--code-bracket-inverted);
  --code-citation: var(--code-citation-inverted);
  --code-color: rgb(237, 71, 89);
  --code-color-bg: rgb(32, 41, 58);

  --button-bg: var(--button-bg-inverted);

  --md-grid-header: var(--md-grid-header-inverted);
  --md-grid-header-ext: var(--md-grid-header-ext-inverted);
  --md-grid-ext: var(--md-grid-ext-inverted);
  --md-grid-header-active: var(--md-grid-header-active-inverted);
  --md-grid-active: var(--md-grid-active-inverted);
  --md-grid-border-color: var(--md-grid-border-color-inverted);
}



mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG2"] path[data-c], mjx-container[jax="SVG2"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}
mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
							stroke-width: 0;
						}
</style><title>操作系统</title>
</head>
<body class='typora-export os-windows typora-export-show-outline typora-export-collapse-outline'><div class='typora-export-content'>
<div class="typora-export-sidebar"><div class="outline-content"><li class="outline-item-wrapper outline-h1"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#操作系统">操作系统</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h2 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#注意点">注意点</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#概述">概述</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#概念">概念</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#发展">发展</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#运行环境">运行环境</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#结构">结构</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#启动引导">启动引导</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#虚拟机">虚拟机</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#进程管理">进程管理</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#进程">进程</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#线程">线程</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#处理机调度">处理机调度</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#同步与互斥">同步与互斥</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#死锁">死锁</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#内存管理">内存管理</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#概念-2">概念</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#覆盖与交换">覆盖与交换</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#连续分配">连续分配</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#离散分配">离散分配</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#虚拟内存">虚拟内存</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#文件管理">文件管理</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#概念-3">概念</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#目录">目录</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#文件系统">文件系统</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#io管理">IO管理</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#io设备">I/O设备</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#设备独立性软件">设备独立性软件</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#磁盘与固态硬盘">磁盘与固态硬盘</a></div><ul class="outline-children"></ul></li></ul></li></ul></li></div></div><div id='write'  class=' first-line-indent'><h1 id='操作系统'><span>操作系统</span></h1><p>&nbsp;</p><h2 id='注意点'><span>注意点</span></h2><ul><li><p><span>外存文件地址，若是连续存储，FCB一般存的是</span><em><span>首块块号+块数</span></em></p></li><li><p><span>页目录号+页号为总逻辑空间大小。若无说明，默认页表和页目录均占 1 页</span></p></li><li><p><span>页表不一定常驻内存，如二级页表中不常用的放在外存，故页表常驻内存能加快地址转换</span></p></li><li><p><span>当缺页时，仍然是先查TLB，然后调页表并放到TLB，继续查TLB。此时查TLB的次数比不缺页的次数多</span></p></li><li><p><span>信号量：循环语句，</span><code>semaphore bowl=min(n-1,m)</code><span>用于防止死锁</span></p></li><li><p><span>键盘输入，中断服务结束数据先放在内核缓冲区，等整个中断结束后再放到yong&#39;hu</span></p></li></ul><p>&nbsp;</p><h2 id='概述'><span>概述</span></h2><h4 id='概念'><span>概念</span></h4><p><span>是最基本的</span><em><span>系统软件</span></em><span>，充当硬件和用户之间的中介</span></p><ul><li><p><span>特征</span></p><ul><li><p><span>并发</span></p><ul><li><p><span>通过分时得以实现，为了进程的并发执行，宏观同时执行，微观上交替执行。注意不是并行</span></p></li></ul></li><li><p><span>共享</span></p><ul><li><p><span>即资源共享，系统中的资源可让多个并发执行的进程共同使用</span></p><ul><li><p><span>共享的文件同样可以以“写”的方式打开，但不能同时写，如读者-写者问题</span></p></li></ul></li><li><p><span>互斥共享：一段时间内只能有一个进程访问某资源</span></p></li><li><p><span>同时访问：“同时”仍然指一小段时间内，分时共享，微观上仍可能是交替访问的</span></p></li><li><p><em><span>并发和共享是OS两个最基本的特征</span></em><span>，两者之间互为存在的条件</span></p></li></ul></li><li><p><span>虚拟</span></p><ul><li><p><span>把一个物理上的实体变成若干个逻辑上的对应物</span></p></li><li><p><span>虚拟技术分为：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器</span></p></li></ul></li><li><p><span>异步</span></p><ul><li><p><span>进程是走走停停的，以不可预知的速度推进，这就是异步性</span></p></li></ul></li></ul></li><li><p><span>目标和功能</span></p><ul><li><p><span>系统资源的管理者</span></p><ul><li><p><span>处理机、存储器、文件、设备管理管理</span></p></li><li><p><span>源文件是面向用户的，OS不该管</span></p></li><li><p><span>缓存由OS管理，对用户透明，没有相关的指令</span></p></li><li><p><span>编译器是应用程序，即编译不是由OS提供的</span></p></li></ul></li><li><p><span>用户和计算机硬件之间的接口</span></p><ul><li><p><span>命令接口</span></p><ul><li><p><span>联机命令接口</span></p><ul><li><p><span>也就是交互式接口，适用于分时或实时系统，比如 CMD</span></p></li></ul></li><li><p><span>脱机命令接口</span></p><ul><li><p><span>适用于批处理系统，如.bat</span></p></li></ul></li></ul></li><li><p><span>程序接口（系统调用）</span></p><ul><li><p><span>又称广义指令，在程序中使用系统调用，请求OS来为它服务，如GUI</span></p></li><li><p><span>系统调用</span><em><span>不是</span></em><span>OS必须实现的功能，最开始的OS并没有系统调用</span></p></li></ul></li></ul></li><li><p><span>实现对计算机资源的扩充</span></p></li></ul></li></ul><h4 id='发展'><span>发展</span></h4><ul><li><p><span>手工操作（</span><em><span>无操作系统</span></em><span>）</span></p></li><li><p><span>批处理阶段</span></p><ul><li><p><span>单道批处理</span></p><ul><li><p><span>一个个自动运行程序</span></p></li></ul></li><li><p><span>多道批处理</span></p><ul><li><p><span>允许多个程序同时进入内存并让它们在CPU中交替运行</span></p></li><li><p><span>注意不是分时的，而是有IO了才取执行另一道程序</span></p></li><li><p><span>宏观上并行，微观上串行</span></p></li><li><p><span>资源利用率高，CPU总是在忙碌状态，但用户响应的时间比较长，且没有人机交互能力</span></p></li></ul></li></ul></li><li><p><span>分时操作系统</span></p><ul><li><p><span>同时性、交互性、独立性、及时性</span></p></li><li><p><span>把处理器的运行时间分成很短的时间片，多个用户（程序）共享同一台计算机</span></p></li></ul></li><li><p><span>实时操作系统</span></p><ul><li><p><span>及时性、可靠性</span></p></li></ul></li><li><p><span>网络操作系统</span></p><ul><li><p><span>共享与通信</span></p></li></ul></li><li><p><span>个人计算机操作系统</span></p></li></ul><h4 id='运行环境'><span>运行环境</span></h4><ul><li><p><span>处理机运行模式</span></p><ul><li><p><span>用户态</span></p><ul><li><p><span>非特权指令</span></p><ul><li><p><span>允许用户直接使用的指令，但不能直接访问系统的软硬件资源，而仅限于访问用户的地址空间</span></p></li></ul></li></ul></li><li><p><span>内核态</span></p><ul><li><p><span>特权指令</span></p><ul><li><p><span>不允许用户直接使用的指令，如IO指令</span></p></li></ul></li><li><p><span>内核</span></p><ul><li><p><span>是操作系统的核心、最基本的组成部分，提供操作系统最基本的功能并管理着整个系统</span></p></li><li><p><span>OS常驻内存的只有内核</span></p></li></ul></li><li><p><span>四方面的内容</span></p><ul><li><p><span>时钟管理</span></p><ul><li><p><span>置时钟指令只能在内核态运行，但读时钟指令可以在用户态运行</span></p></li><li><p><span>需要硬件支持</span></p></li></ul></li><li><p><span>中断机制</span></p><ul><li><p><span>最开始中断是为了提高多道程序的CPU的利用率</span></p></li><li><p><span>现代操作系统是靠</span><em><span>中断驱动</span></em><span>的软件</span></p></li><li><p><em><span>中断是 OS 必备功能</span></em></p></li></ul></li><li><p><span>原语</span></p><ul><li><p><span>是一些公用的小程序，位于</span><em><span>操作系统最底层</span></em><span>，最接近硬件的部分</span></p></li><li><p><span>是</span><em><span>原子操作</span></em><span>，只能一次性完成</span></p></li><li><p><span>运行时间短，且调用频繁</span></p></li></ul></li><li><p><span>系统控制的数据结构</span></p><ul><li><p><span>进程管理</span></p></li><li><p><span>存储器管理</span></p></li><li><p><span>设备管理</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>中断与异常</span></p><ul><li><p><span>中断</span></p><ul><li><p><span>也称外中断，是来自CPU外部的事件</span></p></li><li><p><span>分为可屏蔽中断、不可屏蔽中断</span></p></li><li><p><span>中断或系统调用时，</span><em><span>通用寄存器和执行服务由OS完成，而PC和程序状态字以及改为内核态均由中断隐指令完成</span></em></p></li><li><p><span>中断时，OS负责中断向量表的初始化</span></p></li></ul></li><li><p><span>异常</span></p><ul><li><p><span>内中断，即来自CPU执行指令内部的事件</span></p></li><li><p><em><span>异常无法屏蔽</span></em><span>，必须立即执行</span></p></li><li><p><span>故障、自陷、终止</span></p></li><li><p><em><span>陷入指令也称访管指令</span></em><span>，它是在用户态使用的，不可能是特权指令。在系统调用的时候，进程将使用访管指令自陷</span></p></li></ul></li><li><p><span>发生中断和异常后，CPU会立刻进入核心态（由硬件实现）</span></p></li><li><p><span>故障处理完后，返回原来的指令执行；自陷返回 i+1 条指令执行；终止直接停止执行</span></p></li><li><p><span>中断则是第 i+1 条指令执行</span></p></li></ul></li><li><p><span>系统调用</span></p><ul><li><p><span>即程序接口，</span><em><span>用户态调用、切换到内核态执行</span></em></p></li><li><p><span>凡是与资源有关的操作，都必须由OS代为执行</span></p></li><li><p><span>包含：设备、文件、内存管理，进程控制和通信</span></p></li><li><p><span>执行次序：次序：传递调用参数、执行trap指令、执行服务、返回用户态</span></p><ul><li><p><span>P进程进行系统调用后，中断处理结束前就将P插入就绪队列，然后再从中断返回</span></p></li></ul></li></ul></li></ul><h4 id='结构'><span>结构</span></h4><ul><li><p><span>分层法</span></p><ul><li><p><span>单向紧邻依赖</span></p></li><li><p><span>便于调试和易于维护，不够灵活且效率差</span></p></li></ul></li><li><p><span>模块化</span></p><ul><li><p><span>目标是高内聚、低耦合</span></p></li><li><p><span>提高了操作系统设计的正确性，可理解性和可维护性，增强了操作系统的可适应性，但设计时难度较高</span></p></li></ul></li><li><p><span>宏内核</span></p><ul><li><p><em><span>大内核，性能好</span></em></p></li><li><p><span>将操作系统的主要功能模块都集中在内核中</span></p></li></ul></li><li><p><span>微内核</span></p><ul><li><p><span>将基本的功能保留在内核</span></p><ul><li><p><span>进程管理、低级存储器管理、中断和陷入</span></p></li></ul></li><li><p><span>特点：扩展性和灵活性、可靠性和安全性、可移植、分布式计算，但有性能问题</span></p></li><li><p><span>定义微内核结构的四个方面</span></p><ol start='' ><li><p><span>足够小的内核</span></p></li><li><p><span>基于 C/S 模式</span></p></li><li><p><span>应用机制与策略相分离的原理</span></p><ul><li><p><span>机制为根本，策略为上层实现</span></p></li></ul></li><li><p><span>采用面向对象技术</span></p></li></ol></li></ul></li><li><p><span>外核</span></p><ul><li><p><span>专门为虚拟机分配资源，是运行在内核态的</span><em><span>程序</span></em></p></li><li><p><span>保持多个虚拟机不发生冲突，减少了映射层，但需维护重映像磁盘地址表格</span></p></li></ul></li></ul><h4 id='启动引导'><span>启动引导</span></h4><ul><li><p><span>启动顺序为：激活CPU、执行JMP指令跳转到BIOS并执行、构建中断向量表、硬件自检、加载活动硬盘、加载MBR、扫描分区表、加载分区引导、加载启动管理器、启动操作系统</span></p></li><li><p><span>MBR：主引导扇区，告诉CPU去哪个主分区去找操作系统</span></p></li><li><p><span>BIOS：基本输入输出系统，是ROM上的一个程序，是引导程序的引导</span></p></li></ul><h4 id='虚拟机'><span>虚拟机</span></h4><ul><li><p><span>逻辑计算机，有计算机全部的功能</span></p></li><li><p><span>可用软件或硬件实现（软硬件的等价性）</span></p></li><li><p><span>第一类虚拟机管理程序</span></p><ul><li><p><span>自己本身就类似一个 OS</span></p></li><li><p><span>向上提供若干台虚拟机，每一个都是裸机硬件的精确复制品，可运行不同的操作系统</span></p></li><li><p><span>虚拟机作为一个用户态的进程运行，但虚拟机上的操作系统认为自己运行在内核态。当执行敏感指令时，若是虚拟机的系统执行的，则安排正确执行</span></p></li></ul></li><li><p><span>第二类虚拟机管理程序</span></p><ul><li><p><span>依赖于底层系统，类似于模拟软件</span></p></li><li><p><span>当前大部分虚拟机就是第二类，如 VMware 等</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='进程管理'><span>进程管理</span></h2><h4 id='进程'><span>进程</span></h4><ul><li><p><span>特点</span></p><ul><li><p><span>进程实体运行起来就是进程</span></p></li><li><p><span>进程可运行在用户空间或内核空间中</span></p></li><li><p><span>是系统分配资源的最小单位，若引入了线程，则线程是分配处理机的最小单位</span></p></li><li><p><em><span>动态性（最基本）、并发性（引入目的）</span></em><span>、独立性、异步性</span></p></li><li><p><span>子进程同样是进程，有独立的地址空间和PCB，也可以和父进程并发执行</span></p></li><li><p><span>子程序调用不改变程序状态，故 PSW （程序状态字寄存器）不需要保存内容，但 PC 需要</span></p></li><li><p><span>状态：</span><em><span>运行、就绪、阻塞</span></em><span>、创建、终止</span></p><ul><li><p><span>堵塞态是进程</span><em><span>缺少某资源</span></em><span>而暂停</span></p></li><li><p><span>就绪态是进程仅缺少处理机</span></p></li><li><p><span>前三种是基本状态</span></p></li><li><p><span>5 种状态之间的转化关系</span></p></li><li><p><em><span>从运行态到阻塞态是主动的，从阻塞态到就绪态是被动的</span></em><span>，必须依靠其它进程唤醒</span></p></li><li><p><span>若共 n 个进程，最多 n-1 个在就绪态，最少 0 个</span></p></li></ul></li></ul></li><li><p><span>进程组成</span></p><ul><li><p><span>进程控制块（PCB）</span></p><ul><li><p><span>是进程存在唯一标志</span></p></li><li><p><span>存放描述信息（UID和PID）、控制信息（如优先级、当前状态等）、资源分配等</span></p></li><li><p><em><span>创建进程实际上是创建PCB</span></em><span>，而销毁也是销毁PCB</span></p></li><li><p><span>为方便调度和管理，需要将各进程的PCB组织起来</span></p><ul><li><p><span>链接方式</span></p><ul><li><p><span>将所有处于相同状态的PCB链接成一个队列</span></p></li></ul></li><li><p><span>索引方式</span></p><ul><li><p><span>将同一状态的 PCB 组织在一个索引表中，表项指向PCB</span></p></li></ul></li></ul></li></ul></li><li><p><span>程序段</span></p><ul><li><p><span>CPU执行的程序代码段，可共享但不能同时运行</span></p></li><li><p><span>若是可共享的程序段，则必须采用可重入编码</span></p></li><li><p><span>C语言编写的程序的分段</span></p><ol start='' ><li><p><span>正文段：代码、常量（已赋值的变量）</span></p></li><li><p><span>堆：动态分配段</span></p></li><li><p><span>栈：临时变量如函数传参、未赋值的变量</span></p></li></ol></li></ul></li><li><p><span>数据段</span></p><ul><li><p><span>可以是程序要处理的原始数据，也可以是程序执行产生的结果</span></p></li></ul></li><li><p><span>由以上三部分构成了进程实体，也称进程映像，而进程是进程实体的运行过程</span></p></li></ul></li><li><p><span>进程控制</span></p><ul><li><p><span>创建</span></p><ul><li><p><em><span>子进程可继承父进程的所有资源</span></em><span>，子进程被撤销时，归还所得到的资源</span></p></li><li><p><span>子进程毕竟是一个进程，有着自己的进程空间，注意和线程区别</span></p></li><li><p><span>步骤</span></p><ol start='' ><li><p><span>分配PID，申请一个空白的PCB（PCB有限）</span></p></li><li><p><span>分配资源，若资源不足则处于创建态，等待资源</span></p></li><li><p><span>初始化 PCB</span></p><p><span>创建进程时，创建PCB和初始化都要进行，只有初始化PCB才能正确识别进程</span></p></li><li><p><span>加入就绪队列</span></p></li></ol></li></ul></li><li><p><span>终止</span></p><ul><li><p><span>包含正常结束、异常结束、外界干预等情况</span></p></li><li><p><span>步骤</span></p><ol start='' ><li><p><span>根据终止的 PID，检索出该进程的 PCB，从中读出进程的状态</span></p></li><li><p><span>若此时处于运行状态，则立即终止执行，将处理机分配给其它进程</span></p></li><li><p><span>若还有子孙进程，则立即终止</span></p></li><li><p><span>将资源归还给父进程，或者是操作系统</span></p></li><li><p><span>将该 PCB 从所在的队列中删除</span></p><p><em><span>PCB 总是最先创建，最后删除</span></em></p></li></ol></li></ul></li><li><p><span>阻塞和唤醒</span></p><ul><li><p><em><span>阻塞是主动行为</span></em><span>，进程调用阻塞原语（Block）使自己变阻塞态，只有处于运行态的进程可以这么做</span></p></li><li><p><span>阻塞过程中需要保护现场</span></p></li><li><p><span>当阻塞进程所需要的资源到位后，由相关进程调用唤醒原语（Wakeup）唤醒该进程</span></p></li><li><p><span>Block 和 Wakeup 作用相反，必须成对使用</span></p></li></ul></li></ul></li><li><p><span>进程通信</span></p><ul><li><p><span>指进程之间的信息交换</span></p></li><li><p><span>PV 操作是低级通信方法，高级通信指以高效率传输大量数据的通信</span></p></li><li><p><span>高级通信方法</span></p><ul><li><p><span>共享存储</span></p><ul><li><p><span>在通信的进程之间有一块可直接访问的共享空间，可进行读写，但需要使用同步互斥工具，如PV操作</span></p></li><li><p><span>由于进程空间是独立的，想让进程共享空间必须使用特殊的系统调用</span></p></li><li><p><span>分类</span></p><ul><li><p><span>基于数据结构的共享（低级）</span></p></li><li><p><span>基于存储区的共享（高级）</span></p></li></ul></li></ul></li><li><p><span>消息传递</span></p><ul><li><p><span>以格式化的消息 Message 为单位，通过系统提供的发送和接收原语进行数据交换</span></p></li><li><p><span>隐藏了通信实现细节，使通信过程对用户透明，简化了通信程序设计，是当前用得最广泛的通信机制</span></p></li><li><p><span>分类</span></p><ul><li><p><span>直接通信方式</span></p><ul><li><p><span>发送进程直接将消息发送给接收进程</span></p></li><li><p><span>接收进程从消息缓冲队列中取得消息</span></p></li></ul></li><li><p><span>间接通信方式（信箱）</span></p><ul><li><p><span>消息发送到某个中间实体，称为信箱，然后接收进程从信箱中取</span></p></li></ul></li></ul></li></ul></li><li><p><span>管道通信</span></p><ul><li><p><span>管道也是一种文件，一般是单向通信，先进先出。若为空，则读进程阻塞，若为满，则写进程阻塞，以 </span><em><span>生产者-消费者</span></em><span> 的方式通信</span></p></li><li><p><span>必须提供</span><em><span>互斥、同步和确定对方存在</span></em><span>的协调能力</span></p></li><li><p><span>管道可以多个进程同时读和写，但为了数据正常一般只有一个进程读或写</span></p></li><li><p><span>读数据是一次性操作，数据一旦被读取，就立即释放空间。普通管道只允许单向通信，所以</span><em><span>双向通信要两个管道</span></em></p></li><li><p><span>子进程能继承父进程的管道</span></p></li><li><p><span>管道所克服的问题</span></p><ul><li><p><span>可限制管道的大小，因此文件不会不加检验的增长</span></p></li><li><p><span>读进程可能比写进程快，此时 read() 将被阻塞</span></p></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id='线程'><span>线程</span></h4><ul><li><p><span>特点</span></p><ul><li><p><em><span>进程是为了更好地支持多道程序并发，线程是为了减少程序在并发执行的时空开销</span></em></p></li><li><p><span>是</span><em><span>处理机调度的最小单位</span></em><span>，是基本的执行实体</span></p></li><li><p><span>自己</span><em><span>不拥有系统资源</span></em><span>，只有一点运行中必不可少的资源</span></p></li><li><p><span>线程之间可共享，</span><em><span>一个线程可创建和撤销另一个线程，同一进程的多个线程可并发执行</span></em></p></li><li><p><span>不同的线程可以执行相同的程序，即同一程序被不同用户调用时，被创建为不同的线程</span></p></li><li><p><span>进程之间的变量完全独立，</span><em><span>线程的局部变量在线程之间同样是独立的</span></em><span>，不需要互斥，而进程的全局变量是所有线程共享的，当写时需要互斥访问</span></p></li><li><p><span>线程和进程的比较</span></p><ul><li><p><span>调度</span></p><ul><li><p><span>线程是</span><em><span>独立调度的最小单位</span></em></p></li></ul></li><li><p><span>并发性</span></p><ul><li><p><span>相同和不同进程中的线程都可以并发</span></p></li></ul></li><li><p><span>拥有资源</span></p><ul><li><p><em><span>进程是拥有资源的基本单位</span></em></p></li><li><p><em><span>同一进程的所有线程都有相同的地址空间</span></em></p></li></ul></li><li><p><span>独立性</span></p><ul><li><p><span>同一进程中的所有线程共享资源、全局变量和地址空间，但</span><em><span>线程之间的栈指针相互独立</span></em><span>。而</span><em><span>进程与进程之间是全部独立的</span></em></p></li></ul></li><li><p><span>系统开销</span></p><ul><li><p><span>创建和销毁进程比线程的开销要高得多</span></p></li><li><p><span>线程之间的同步与通信非常容易实现</span></p></li></ul></li></ul></li></ul></li><li><p><span>组成</span></p><ul><li><p><span>线程ID、程序计数器、寄存器集合、堆栈</span></p></li></ul></li><li><p><span>状态</span></p><ul><li><p><span>执行、就绪、阻塞</span></p></li></ul></li><li><p><span>控制</span></p><ul><li><p><span>线程控制块（TCB）</span></p><ul><li><p><span>类似于进程控制块PCB</span></p></li><li><p><span>通常包含：线程标识符、程序计数器等寄存器、线程运行状态、优先级、堆栈指针等</span></p></li></ul></li><li><p><span>创建</span></p><ul><li><p><span>用户程序启动时，仅有一个初始化线程在执行，功能是创建新进程</span></p></li></ul></li><li><p><span>终止</span></p><ul><li><p><span>有些线程（系统线程）一旦创建，就不会被终止</span></p></li><li><p><span>线程被</span><em><span>终止后不立即释放资源</span></em><span>，只有进程中的其它线程执行了分离函数后才释放</span></p></li><li><p><span>被终止但未释放资源的线程可被其它线程调用，从而</span><em><span>恢复运行</span></em></p></li></ul></li></ul></li><li><p><span>实现</span></p><ul><li><p><span>用户级线程</span></p><ul><li><p><span>只在用户态运行和调度，管理代码在程序中</span></p></li><li><p><em><span>调度仍然以进程为单位</span></em><span>，内核意识不到线程的存在</span></p></li><li><p><span>缺点：</span><em><span>一个线程阻塞，整个进程阻塞</span></em><span>；不能发挥多处理机优势，进程中同一时刻只有一个线程能执行</span></p></li><li><p><span>优点：不需要切换到内核态，节省开销；调度算法是进程专用的，不同进程可使用不同调度算法；实现与OS无关，任何OS中都支持</span></p></li></ul></li><li><p><span>内核级线程</span></p><ul><li><p><span>进程和线程都是在内核支持下运行的；用户程序在</span><em><span>内核状态调度，用户态运行</span></em></p></li><li><p><span>一对一的形式，用户空间有用户线程，同时内核也创建对应的内核线程</span></p></li><li><p><span>优点</span></p><ul><li><p><span>能发挥多处理机的优势，一个线程阻塞，同一进程的其它线程可继续运行；线程切换快，开销小；内核本身也可采用多线程技术，提高效率</span></p></li></ul></li><li><p><span>缺点</span></p><ul><li><p><em><span>线程切换需要核心态和用户态切换</span></em><span>，系统开销较大</span></p></li></ul></li></ul></li><li><p><span>组合方式</span></p><ul><li><p><span>综合用户级和内核级线程的使用（有的是用户级线程，有的是内核级）</span></p></li><li><p><span>线程库是为程序员提供创建和管理线程的API，有POSIX Pthreads、Windows API、Java</span></p></li></ul></li></ul></li><li><p><span>多线程模型</span></p><ul><li><p><span>同时支持用户级和内核级线程的操作系统中，这些线程的具体实现</span></p></li><li><p><span>分为多对一、一对一、多对多模型</span></p></li><li><p><span>仅对内核空间的线程才设立TCB</span></p></li></ul></li></ul><h4 id='处理机调度'><span>处理机调度</span></h4><ol start='' ><li><p><span>概念</span></p><ul><li><p><span>对处理机的分配问题，是OS设计的核心问题</span></p></li><li><p><span>进程调度是OS的事，不是进程发起的，故不属于系统调用；创建新进程</span><em><span>可以是</span></em><span>系统调用</span></p></li><li><p><em><span>进程最开始获得CPU的时候，也是一次调度</span></em></p></li><li><p><span>层次</span></p><ul><li><p><span>高级调度（作业调度）</span></p><ul><li><p><span>从辅存调入到内存的调度</span></p></li></ul></li><li><p><span>中级调度（内存调度）</span></p><ul><li><p><span>将暂时不能运行的进程调至外存等待（挂起）</span></p></li><li><p><span>本质就是存储器管理中的对换功能</span></p></li></ul></li><li><p><span>低级调度（进程调度）</span></p><ul><li><p><span>是最基本的一种调度，频率很高</span></p></li><li><p><span>从就绪队列中选择一个进程，分配处理机</span></p></li></ul></li></ul></li></ul></li><li><p><span>目标</span></p><ul><li><p><span>CPU利用率</span></p><ul><li><p><span>CPU有效工作时间/总时间</span></p></li></ul></li><li><p><span>系统吞吐量</span></p><ul><li><p><span>单位时间CPU完成任务的数量</span></p></li><li><p><span>长作业因为比较耗时，所以会使吞吐量降低</span></p></li></ul></li><li><p><span>周转时间</span></p><ul><li><p><span>是</span><em><span>作业提交那一刻到作业完成那一刻</span></em><span>所花费的时间</span></p></li><li><p><span>平均周转时间：多个作业周转时间的平均值</span></p></li><li><p><span>相同程序的多次运行，变的是周转时间，</span><em><span>运行时间是不变的</span></em></p></li></ul></li><li><p><span>带权周转时间</span></p><ul><li><p><em><span>周转时间 / 作业实际运行时间</span></em></p></li><li><p><span>平均带权周转时间：多个作业带权周转时间的平均值</span></p></li></ul></li><li><p><span>等待时间：某个进程等待CPU的</span><em><span>总时间</span></em></p></li><li><p><span>响应时间：用户首次提交请求到 CPU 首次响应的时间</span></p></li><li><p><span>通过画甘特图解决周转时间相关题目，横坐标是时间，纵坐标是不同进程</span></p></li></ul></li><li><p><span>实现</span></p><ul><li><p><span>调度程序</span></p><ul><li><p><span>排队器</span></p><ul><li><p><span>将所有就绪进程按一定的策略排成一个或多个队列，便于调度选择</span></p></li></ul></li><li><p><span>分派器</span></p><ul><li><p><span>将调度所选的进程，分配CPU</span></p></li></ul></li><li><p><span>上下文切换器</span></p><ul><li><p><em><span>上下文即 PC、其它寄存器的值</span></em></p></li><li><p><span>每次切换会发生</span><em><span>两对</span></em><span>上下文切换：保存被切进程的信息到PCB，装入分配程序（即分派器）的上下文；移除分派器的上下文，装入（下一个）被分配程序的上下文</span></p></li><li><p><span>上下文切换需执行大量load、store指令。通常采用两组寄存器，一组供内核使用，一组给用户使用，这样上下文切换时只需改变指针</span></p></li></ul></li></ul></li><li><p><span>不能调度的情况</span></p><ul><li><p><span>中断处理中、进程在临界区（必须加锁）、原子操作</span></p></li></ul></li><li><p><span>调度方式</span></p><ul><li><p><span>非抢占</span></p><ul><li><p><span>即非剥夺方式，即使有更紧迫的进程进入就绪队列，也让当前进程继续执行，直到进入阻塞态</span></p></li><li><p><span>实现简单、系统开销小，适用广；但不能用于分时和实时操作系统</span></p></li></ul></li><li><p><span>抢占</span></p><ul><li><p><span>即剥夺方式，若有更紧迫的任务，马上去执行</span></p></li></ul></li></ul></li><li><p><span>闲逛进程</span></p><ul><li><p><span>进程切换时，若没有就绪进程，则闲逛进程开始运行</span></p></li><li><p><span>优先级最低，只要有进程就绪，就会立刻让出处理机</span></p></li><li><p><span>不需要CPU以外的资源，不会被阻塞</span></p></li></ul></li><li><p><span>两种线程的调度</span></p><ul><li><p><span>用户级</span></p><ul><li><p><span>内核不知道线程的存在，</span><em><span>只选择一个进程调度，让进程选择线程的调度</span></em></p></li></ul></li><li><p><span>内核级</span></p><ul><li><p><span>内核选择一个线程运行，</span><em><span>通常不需要考虑属于那个进程</span></em></p></li><li><p><span>内核级线程切换需要完整的上下文切换，修改内存映像等，</span><em><span>开销大</span></em></p></li></ul></li></ul></li></ul></li><li><p><span>调度算法</span></p><ul><li><p><span>FCFS 先来先服务</span></p><ul><li><p><span>最简单，可用户作业或线程调度</span></p></li><li><p><span>直到当前进程陷入阻塞才释放处理机，属于</span><em><span>不可剥夺算法</span></em></p></li><li><p><span>效率低，</span><em><span>对长作业有利</span></em><span>，</span><em><span>有利于CPU繁忙型任务，不利于IO繁忙型任务</span></em></p></li></ul></li><li><p><span>SJF 短作业优先</span></p><ul><li><p><span>选择预估执行时间最短的进程分配处理机</span></p></li><li><p><span>直到陷入阻塞才释放处理机，属于</span><em><span>不可剥夺算法</span></em></p></li><li><p><em><span>对长作业不利，会导致饥饿现象（非抢占式SJF同样有）</span></em><span>，且不一定能真正做到短作业优先</span></p></li><li><p><em><span>平均等待时间、平均周转时间最短</span></em></p></li></ul></li><li><p><span>优先级调度</span></p><ul><li><p><span>可用于作业调度、进程调度</span></p></li><li><p><span>一般是优先级数值越低则优先级越高</span></p></li><li><p><span>非抢占式</span></p><ul><li><p><span>有优先级更高的进程时，让当前进程继续运行，直到阻塞了，才重新分配处理机</span></p></li></ul></li><li><p><span>抢占式</span></p><ul><li><p><span>有优先级更高的进程时，立刻暂停当前进程，重新分配处理机</span></p></li></ul></li><li><p><span>静态优先级</span></p><ul><li><p><span>优先级在创建进程时决定，且运行时保持不变</span></p></li></ul></li><li><p><span>动态优先级</span></p><ul><li><p><span>在进程运行情况，动态调整优先级</span></p></li></ul></li><li><p><span>优先级的设置</span></p><ul><li><p><em><span>系统进程&gt;用户进程</span></em></p></li><li><p><em><span>IO型&gt;计算型</span></em></p></li></ul></li></ul></li><li><p><span>高响应比调度</span></p><ul><li><p><span class='math-in-toc'>$响应比=\frac{等待时间}{服务时间}+1$</span></p></li><li><p><span>主要用于作业调度，是对 FCFS 和 SJF 的综合</span></p></li><li><p><span>等待时间越长，响应比越高，克服了饥饿；作业越短，响应比越高，满足短作业优先</span></p></li></ul></li><li><p><span>时间片轮转调度</span></p><ul><li><p><span>分成时间片轮流来，主要适用于分时系统</span></p></li><li><p><span>一个进程运行完一个时间片后，必须被剥夺，重新排队</span></p></li><li><p><span>时间片轮转主要目标是让多个用户能及时干预系统，但它增大了系统开销</span></p></li></ul></li><li><p><span>多级队列调度</span></p><ul><li><p><span>多个就绪队列，可实行不同调度策略</span></p></li><li><p><span>一般由多处理机支持</span></p></li></ul></li><li><p><span>多级反馈队列</span></p><ul><li><p><span>综合前面几种算法的特点，可兼顾多方面的目标</span></p></li><li><p><span>可动态调整优先级和时间片的大小</span></p></li><li><p><em><span>多个队列，第一个优先级最高</span></em><span>，后面的逐级降低</span></p></li><li><p><em><span>优先级越高的队列中，赋予的时间片越短</span></em></p></li><li><p><em><span>每个队列都是 FCFS</span></em><span>。新进程就绪时，先放到第一级队列中，执行一遍后放到第二级，以此类推，直到到了</span><em><span>最后一级队列，采用时间片轮转调度</span></em></p></li><li><p><em><span>仅当高优先级队列为空时，才调度下一级的队列中的程序</span></em></p></li><li><p><span>若执行第 i 级的队列调度时，又有新进程到了优先级更高的队列，则立即暂停当前进程，去执行新进程，也就是</span><em><span>剥夺式</span></em></p></li></ul></li></ul></li><li><p><span>进程切换</span></p><ul><li><p><span>上下文：</span><em><span>某一时刻 CPU 寄存器和 PC 中的内容</span></em></p></li><li><p><span>上下文切换（进程切换）在内核支持下完成，其实质是处理机从一个进程转到另一个进程上运行</span></p></li><li><p><em><span>上下文切换只能发生在内核态</span></em></p></li><li><p><span>上下文切换流程</span></p><ol start='' ><li><p><span>挂起进程，保存上下文</span></p></li><li><p><span>更新 PCB 信息</span></p></li><li><p><span>把进程的 PCB 移入某个队列，如就绪、阻塞等</span></p></li><li><p><span>选择另一个进程执行，并更新它的 PCB</span></p></li><li><p><span>跳转到新进程 PCB 的程序计数器所指示的位置执行</span></p></li><li><p><span>恢复处理器上下文</span></p></li></ol></li><li><p><span>上下文切换需要消耗大量的CPU时间，而若提供了多个寄存器组，则只需要修改当前寄存器组的指针，减少了开销</span></p></li></ul></li></ol><h4 id='同步与互斥'><span>同步与互斥</span></h4><ol start='' ><li><p><span>概念</span></p><ul><li><p><span>临界资源：一次仅一个进程可使用，例如打印机。另外还有些数据、变量等虽然宏观上可共享，但仍然属于临界资源</span></p></li><li><p><span>同步和互斥常常是 while 循环，注意和 if 相区分</span></p></li><li><p><span>读与读之间不需要互斥，</span><em><span>仅读与写、写与写之间需要互斥</span></em></p></li><li><p><span>临界资源访问的四部分</span></p><ul><li><p><span>进入区（entry section）</span></p><ul><li><p><span>在此检查是否可进入临界区，若可以，则需要设置访问临界区的标志</span></p></li></ul></li><li><p><span>临界区（critical section）</span></p><ul><li><p><span>进程中访问临界资源的那段代码，又称临界段</span></p></li></ul></li><li><p><span>退出区（exit section）</span></p><ul><li><p><span>将正在访问临界区的标志清除</span></p></li></ul></li><li><p><span>剩余区（reminder section）</span></p><ul><li><p><span>代码中的其余部分</span></p></li></ul></li><li><p><em><span>互斥访问不同方法不同在进入区和退出区</span></em><span>，只有这两个区是和互斥访问相关的，需要代码实现，而临界区和剩余区，在代码里直接用英文表示就行了</span></p></li></ul></li><li><p><span>进程间的关系</span></p><ul><li><p><span>同步：直接制约关系，即相互合作引起的协调次序、传递信息所产生的制约关系</span></p><p><span>由于进程需要合作而它们是异步的，故需要同步</span></p></li><li><p><span>互斥：间接制约关系，即相互竞争资源</span></p></li><li><p><span>同步原则：</span><em><span>空闲让进、忙则等待、有限等待、让权等待（不一定得实现）</span></em></p></li><li><p><span>进程之间可同时有同步和互斥关系</span></p></li></ul></li></ul></li><li><p><span>互斥方法</span></p><ul><li><p><span>软件实现</span></p><ul><li><p><span>单标志法</span></p><ul><li><p><span>用一个变量 turn 标识允许进入的进程编号</span></p></li><li><p><span>如 turn0 表示进程 P0 允许进入临界区</span></p></li><li><p><span>进入临界区后，把 turn 改变成另外一个进程的标志，这导致两个进程必须交替进入临界区，一个进程不能连续访问临界区，违背了空闲让进原则</span></p></li></ul></li><li><p><span>双标志先检查</span></p><ul><li><p><span>设置一个布尔数组，长度和访问临界资源的进程数相同。某个进入临界区前先检查访问数组</span></p></li><li><p><span>flag[i]=False 表示 Pi 未进入临界区</span></p></li><li><p><span>两个进程可能同时进入（检测时都发现没有进程进入临界区），违背忙则等待原则</span></p></li></ul></li><li><p><span>双标志后检查</span></p><ul><li><p><em><span>先把布尔数组中自己值置为 True，再检查别人</span></em></p></li><li><p><span>若两个进程同时请求，则都设置自己的标志为 True，双方互相谦让，导致谁也没进去，产生</span><em><span>“饥饿”</span></em><span>现象，违背有限等待</span></p></li></ul></li><li><p><span>Peterson’s算法</span></p><ul><li><p><span>同时设置布尔数组和 turn，综合前面几种方法</span></p></li><li><p><span>进入时，</span><em><span>先设置自己为 True，再设置 turn为对方</span></em><span>。相当于每次想进入，但先和对方说声请，若没人就自己进，若有人，对方也会说请，这时自己不再客气，先进去</span></p></li><li><p><span>在两个进程同时访问时，turn被改动了两次，但总有一个进程能跳出 while 循环进入临界区，解决了饥饿现象</span></p></li><li><p><span>当只有一个进程时，由于另一个进程的标志为 false，因此它也能进入临界区，即解决了互斥访问</span></p></li><li><p><span>利用 turn 解决饥饿现象（flag互相谦让的情况），用 flag 数组解决互斥访问</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 392.792px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>7</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Pi进程</span>{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">flag</span>[<span class="cm-variable">i</span>]<span class="cm-operator">=</span><span class="cm-variable">True</span>;<span class="cm-variable">turn</span><span class="cm-operator">=</span><span class="cm-variable">j</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">while</span> (<span class="cm-variable">flag</span>[<span class="cm-variable">j</span>]<span class="cm-operator">&amp;&amp;</span><span class="cm-variable">turn</span><span class="cm-operator">=</span><span class="cm-variable">j</span>);<span class="cm-comment">//一二行都是进入区</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">critical</span> <span class="cm-variable">section</span>;<span class="cm-comment">//临界区</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">flag</span>[<span class="cm-variable">i</span>]<span class="cm-operator">=</span><span class="cm-atom">false</span>;<span class="cm-comment">//退出区</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">reminder</span> <span class="cm-variable">section</span>;<span class="cm-comment">//剩余区</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 196px;"></div><div class="CodeMirror-gutters" style="height: 196px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li></ul></li></ul></li><li><p><span>硬件实现</span></p><ul><li><p><span>中断屏蔽</span></p><ul><li><p><span>进入临界区前关中断</span></p></li><li><p><span>限制了处理机交替执行的能力，效率会降低；且将关中断的权力交给用户程序是不明智的</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 62.9167px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>5</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">...</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">关中断</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">临界区</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">开中断</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">...</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 140px;"></div><div class="CodeMirror-gutters" style="height: 140px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li></ul></li><li><p><span>硬件指令</span></p><ul><li><p><span>特点</span></p><ul><li><p><span>硬件指令指这些指令</span><em><span>直接由硬件实现</span></em><span>，</span><em><span>不会被中断</span></em><span>，其代码只是描述其功能而不是实现</span></p></li><li><p><span>TestAndSet 和 Swap 本质上都是不断测试 lock 的条件，当 lock 为 true 时，无论怎么测试都是true，而当前一个进程出临界区时会把标志改为 false，这样两个指令就能跳出循环了</span></p></li><li><p><span>硬件指令优缺点</span></p><ul><li><p><span>适用于</span><em><span>任意数目的进程</span></em><span>，简单，支持进程内有多个临界区</span></p></li><li><p><span>进程进入临界区要消耗处理机时间，不能实现让权等待，</span><em><span>可能导致饥饿现象</span></em></p></li></ul></li></ul></li><li><p><span>TestAndSet指令</span></p><ul><li><p><em><span>取出标志并设置为 true</span></em><span>，</span><em><span>是原子操作</span></em></p></li><li><p><span>可设置标志 lock（是一个指针），true 就是表示有进程正在访问资源，由于是原子操作，所以可以实现互斥</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 631.281px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>11</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">bool</span> <span class="cm-def">TestAndSet</span>(<span class="cm-variable-3">bool</span> <span class="cm-variable-3">*</span><span class="cm-variable">lock</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable-3">bool</span> <span class="cm-variable">old</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">old</span> <span class="cm-operator">=</span> <span class="cm-operator">*</span><span class="cm-variable">lock</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-operator">*</span><span class="cm-variable">lock</span><span class="cm-operator">=</span><span class="cm-atom">true</span>;<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-comment">// 加锁</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">return</span> <span class="cm-variable">old</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//实现互斥</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span> (<span class="cm-variable">TestAndSet</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">lock</span>));<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment">// 当返回old是false时，表明有进程改动了lock的值</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">critical</span> <span class="cm-variable">section</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">lock</span><span class="cm-operator">=</span><span class="cm-atom">false</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">reminder</span> <span class="cm-variable">section</span>;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 308px;"></div><div class="CodeMirror-gutters" style="height: 308px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><span>Swap指令</span></p><ul><li><p><span>交换两个字或者变量的内容</span></p></li><li><p><span>为每个临界资源设置一个lock，初值为false，同时每个进程设置bool变量key，用于与lock交换信息</span></p></li><li><p><span>进入临界区前，先使用 swap 交换 lock 和 key，然后检查key。有进程在临界区时，重复交换和检查过程，直到进程退出</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 571.49px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>14</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">Swap</span>(<span class="cm-variable-3">bool</span> <span class="cm-variable-3">*</span><span class="cm-variable">a</span>,<span class="cm-variable-3">bool</span> <span class="cm-variable-3">*</span><span class="cm-variable">b</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable-3">bool</span> <span class="cm-variable">temp</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">temp</span><span class="cm-operator">=*</span><span class="cm-variable">a</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-operator">*</span><span class="cm-variable">a</span><span class="cm-operator">=*</span><span class="cm-variable">b</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-operator">*</span><span class="cm-variable">b</span><span class="cm-operator">=</span><span class="cm-variable">temp</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//互斥访问</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">bool</span> <span class="cm-variable">key</span><span class="cm-operator">=</span><span class="cm-atom">true</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span>(<span class="cm-variable">key</span><span class="cm-operator">=</span><span class="cm-atom">true</span>){<span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 不断交换，直到有进程修改了lock的值，则跳出循环</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">Swap</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">lock</span>,<span class="cm-operator">&amp;</span><span class="cm-variable">key</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">critical</span> <span class="cm-variable">section</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">lock</span><span class="cm-operator">=</span><span class="cm-atom">false</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">reminder</span> <span class="cm-variable">section</span>;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 392px;"></div><div class="CodeMirror-gutters" style="height: 392px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li></ul></li></ul></li><li><p><span>互斥锁</span></p><ul><li><p><span>前面都是实现互斥的原理，而互斥锁是工具</span></p></li><li><p><span>进入临界区获得锁acquire，离开释放release，两者均为为原子操作，因此常采用硬件方法实现，下面的代码仅为演示</span></p></li><li><p><span>每个互斥锁都有一个 available 布尔变量，表示锁是否可用，若可用，使用acquire后锁将不可用，其它使用 acquire 的进程将被堵塞</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 269.938px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>9</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">acquire</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">while</span>(<span class="cm-operator">!</span><span class="cm-variable">available</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        ;  <span class="cm-comment">// 锁不可用则反复循环</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">available</span><span class="cm-operator">=</span><span class="cm-atom">false</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">release</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">available</span><span class="cm-operator">=</span><span class="cm-atom">true</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 252px;"></div><div class="CodeMirror-gutters" style="height: 252px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li><li><p><span>主要缺点：忙等待（上面的没代码的循环），即一边等待一边不断测试条件，占用了处理机。注意和忙则等待区分</span></p></li></ul></li><li><p><span>信号量</span></p><ul><li><p><span>wait(S)和signal(S)，即P、V操作，它们都是</span><em><span>原语</span></em><span>，这里S代表信号量</span></p></li><li><p><span>整型信号量</span></p><ul><li><p><span>被定义为用于表示资源数目的整型量S</span></p></li><li><p><span>P操作是让资源 S-1，V让 S+1</span></p></li><li><p><span>没有实现让权等待，而是处于忙等待中</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 145.573px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>7</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">wait</span>(<span class="cm-variable">S</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">while</span>(<span class="cm-variable">S</span><span class="cm-operator">&lt;=</span><span class="cm-number">0</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">S</span><span class="cm-operator">=</span><span class="cm-variable">S</span><span class="cm-operator">-</span><span class="cm-number">1</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">signal</span>(<span class="cm-variable">S</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">S</span><span class="cm-operator">=</span><span class="cm-variable">S</span><span class="cm-operator">+</span><span class="cm-number">1</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 196px;"></div><div class="CodeMirror-gutters" style="height: 196px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li></ul></li><li><p><span>记录型信号量</span></p><ul><li><p><span>不存在忙等的进程同步机制，遵循让权等待</span></p></li><li><p><span>除了代表资源数目的 value 外，还要有一个进程链表 L，用于链接所有等待该资源的进程</span></p></li><li><p><span>事实上 </span><em><span>S.value 代表空闲资源和现有申请该资源的进程的数目之差</span></em><span>，所以</span><em><span>S.value的自增和自减操作放在P、V操作的第一行</span></em></p></li><li><p><span>在P、V操作里，分别加入block和wakeup语句，用于进程的阻塞和唤醒</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 318.792px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>19</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">typedef</span> <span class="cm-keyword">struct</span>{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable-3">int</span> <span class="cm-variable">value</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">struct</span> <span class="cm-def">process</span> <span class="cm-operator">*</span><span class="cm-variable">L</span>; <span class="cm-comment">//进程指针</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}<span class="cm-variable">Semaphore</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//相应的wait(S)和signal(S)如下</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">wait</span>(<span class="cm-variable">Semaphore</span> <span class="cm-variable">S</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">S</span>.<span class="cm-variable">value</span><span class="cm-operator">--</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">if</span>(<span class="cm-variable">S</span>.<span class="cm-variable">value</span><span class="cm-operator">&lt;</span><span class="cm-number">0</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">add</span> <span class="cm-variable">this</span> <span class="cm-variable">process</span> <span class="cm-variable">to</span> <span class="cm-variable">S</span>.<span class="cm-variable">L</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">block</span>(<span class="cm-variable">S</span>.<span class="cm-variable">L</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">signal</span>(<span class="cm-variable">Semaphore</span> <span class="cm-variable">S</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">S</span>.<span class="cm-variable">value</span><span class="cm-operator">++</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">if</span>(<span class="cm-variable">S</span>.<span class="cm-variable">value</span><span class="cm-operator">&lt;=</span><span class="cm-number">0</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">remove</span> <span class="cm-variable">a</span> <span class="cm-variable">process</span> <span class="cm-variable">P</span> <span class="cm-variable">from</span> <span class="cm-variable">S</span>.<span class="cm-variable">L</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">wakeup</span>(<span class="cm-variable">P</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">18</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">19</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 532px;"></div><div class="CodeMirror-gutters" style="height: 532px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li><li><p><span>利用信号量实现同步</span></p><ul><li><p><em><span>同步时，信号量 S=0</span></em><span>，即第二个进程不能直接 P，而是得等所同步的进程 V 完才能使用</span></p></li><li><p><span>一个进程只有 P 操作，一个进程只有 V 操作</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 406.188px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>9</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Semaphore</span> <span class="cm-variable">S</span><span class="cm-operator">=</span><span class="cm-number">0</span>; <span class="cm-comment">//这个信号量应该是整型的不是结构体</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">P1</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">x</span>; <span class="cm-comment">//P2必须等x语句完成后才能进行</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">V</span>(<span class="cm-variable">S</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">P2</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">P</span>(<span class="cm-variable">S</span>);  <span class="cm-comment">//检查x的情况</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">y</span>;  <span class="cm-comment">//执行下一步</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 252px;"></div><div class="CodeMirror-gutters" style="height: 252px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li></ul></li><li><p><span>利用信号量实现互斥</span></p><ul><li><p><span>S的初值为1（或多个），即一开始就可用，等两个进程来抢</span></p></li><li><p><span>每个进程里都有一对 PV 操作，临界区被放在 PV 操作之间（紧紧夹住不能有冗余代码）</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 240.76px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>11</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Semaphore S=1;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">P1(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    P(S);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    critical section of P1;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    V(S);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">P2(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    P(S);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    critical section of P2;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    V(S);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 308px;"></div><div class="CodeMirror-gutters" style="height: 308px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><span>利用信号量实现前驱关系（同步的一种）</span></p><ul><li><p><span>前驱图中，</span><em><span>某个节点必须等所有入度箭头都完成了</span></em><span>，才能开始运作</span></p></li><li><p><span>设置若干个初值为 0 的信号量，</span><em><span>信号量的个数和图中总的入度相等</span></em></p></li><li><p><span>前一个进程完成了，就V，后面的进程在开始时就用P。</span><em><span>P和V的次数和入度、出度分别与该节点的入度、出度相等</span></em></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 188.812px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>11</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">semaphore a1=a2...=0;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">P1(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    ...;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    V(a1);V(a2);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">...</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Pi(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    P(a4);P(a5);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    ...;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    V(a6);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 308px;"></div><div class="CodeMirror-gutters" style="height: 308px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><span>分析同步和互斥问题的步骤</span></p><ul><li><p><span>关系分析：找出问题中的进程数，分析同步和互斥关系</span></p></li><li><p><span>整理思路：确定P、V操作的大致顺序</span></p></li><li><p><span>设置信号量，设置初值</span></p></li></ul></li></ul></li><li><p><span>答题时的写法</span></p><ul><li><p><span>设置信号量时最好说明该信号量控制的是哪两个操作的执行顺序</span></p></li><li><p><span>满足互斥并不难，难的是尽量保持高并发</span></p><ul><li><p><span>找准互斥关系，每一对互斥就设置一个信号量，一般而言要实现高并发，要设置多个信号量</span></p></li><li><p><span>例如</span><em><span>A读、B读、C写，那么就是AC、BC两对互斥，设置两个信号量分别实现互斥，使得A、B可同时读</span></em></p></li><li><p><span>若</span><em><span>某变量m个进程共享，n个进程写，m-n个只读，那么可设置m-n个互斥信号量，读进程仅需1个信号量，而写进程需拿到所有信号量（信号量个数和只读进程个数相同）</span></em></p></li></ul></li></ul></li></ul></li><li><p><span>管程</span></p><ul><li><p><span>专门管理资源而诞生的程序，变量中包含资源数等，不同资源和数据结构有不同管程</span></p></li><li><p><span>管程是语法范围，无法被创建或销毁</span></p></li><li><p><span>组成</span></p><ul><li><p><span>管程的名称</span></p></li><li><p><span>局部于管程内部的共享数据结构说明</span></p></li><li><p><span>对该数据结构进行操作的一组过程，例如 </span><em><span>takeaway 是申请一个资源，giveback 是归还一个资源</span></em></p></li><li><p><span>对共享数据结构设置初值的语句</span></p></li></ul></li><li><p><span>管程有点像一个类，可实现进程的同步和互斥</span></p></li><li><p><span>管程把对共享资源的操作封装起来，管程内的数据只能被管程的函数所访问，一个进程只有调用管程的函数才能访问管程资源</span></p></li><li><p><em><span>调用管程的进程获得管程的全部资源，每次仅允许一个进程进入管程</span></em><span>从而实现互斥</span></p></li><li><p><span>条件变量（condition）</span></p><ul><li><p><span>将</span><em><span>阻塞原因</span></em><span>定义为条件变量</span></p></li><li><p><span>在管程中设置多个条件变量，每个条件变量保存了一个队列，记录因该条件变量而阻塞的所有进程</span></p></li><li><p><span>条件变量只有两种操作</span></p><ol start='' ><li><p><span>x.wait</span></p><ul><li><p><span>当 x 对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件等待队列，并释放管程</span></p></li></ul></li></ol><ol start='2' ><li><p><span>x.signal</span></p><ul><li><p><span>x对应的条件发生了变化，则调用 x.signal，唤醒一个因 x 阻塞的进程</span></p></li></ul></li></ol></li></ul></li><li><p><span>条件变量的操作类似于信号量的 PV 操作，可实现进程的阻塞和唤醒</span></p><ul><li><p><span>和信号量的区别：</span><em><span>条件变量仅实现排队等待功能，没有值</span></em><span>；信号量的值反映了剩余资源数，而管程的剩余资源数用共享数据结构记录</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 288.042px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>20</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">monitor</span> <span class="cm-variable">Demo</span>{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">定义共享数据结构S</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">condition</span> <span class="cm-variable">x</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">init_code</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">S</span><span class="cm-operator">=</span><span class="cm-variable">初值</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        ...</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    };</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">take_away</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-keyword">if</span>(<span class="cm-variable">S</span><span class="cm-operator">&lt;=</span><span class="cm-number">0</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">            <span class="cm-variable">x</span>.<span class="cm-variable">wait</span>();<span class="cm-tab" role="presentation" cm-text="	">   </span><span class="cm-comment">// 阻塞中</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">资源足够，分配资源</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-variable">give_back</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">归还资源</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-keyword">if</span>(<span class="cm-variable">有进程在等待</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">            <span class="cm-variable">x</span>.<span class="cm-variable">signal</span>();</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">18</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">19</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">20</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 560px;"></div><div class="CodeMirror-gutters" style="height: 560px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><span>若是没有条件变量的纯管程定义，则没有 signal 和 wait，因此需要手动 S++ 和 S--;</span></p></li></ul></li><li><p><span>经典同步问题</span></p><ul><li><p><span>生产者-消费者问题</span></p><ul><li><p><span>只能先生产再消费，例如先写后读</span></p></li><li><p><span>一组生产者和消费者共享一个初始为空、大小为 n 的缓冲区。只有缓冲区没满，生产者才能写，只有缓冲区没空，消费者才能读。同一时刻只能读或写</span></p></li><li><p><span>生产者和消费者同时有互斥（互斥访问缓冲区）和同步（先写后读）关系</span></p></li><li><p><span>设置多个信号量，有用于互斥访问的，也有用于同步的，</span><em><span>互斥信号量初值为1，且只有1和0两个值。同步量初值可为 0 或 n</span></em></p></li><li><p><span>一种进程可以提供某种东西，另一个需要使用，则可以设置这个东西的信号量（例如缓冲区），初值视情况而定</span></p></li><li><p><span>基本上都是 while 循环</span></p></li><li><p><em><span>多个相同的临界资源，一般都是设置empty=n，full=0</span></em></p></li><li><p><span>多个临界资源，生产者和消费者</span><em><span>不一定是互斥的</span></em><span>，只要有满的或空的资源就行</span></p></li><li><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 40px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; min-width: 373.083px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>23</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">mutex</span><span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment">//实现互斥的信号量</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">empty</span><span class="cm-operator">=</span><span class="cm-variable">n</span>;<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment">//空闲缓冲区，为临界资源</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">full</span><span class="cm-operator">=</span><span class="cm-number">0</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">producer</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">while</span>(<span class="cm-number">1</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">produce</span> <span class="cm-variable">an</span> <span class="cm-variable">item</span> <span class="cm-variable">in</span> <span class="cm-variable">nextp</span>;<span class="cm-comment">//生产数据</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">P</span>(<span class="cm-variable">empty</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">P</span>(<span class="cm-variable">mutex</span>);<span class="cm-tab" role="presentation" cm-text="	">   </span><span class="cm-comment">// 互斥信号量在内部</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">add</span> <span class="cm-variable">nextp</span> <span class="cm-variable">to</span> <span class="cm-variable">buffer</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">V</span>(<span class="cm-variable">mutex</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">V</span>(<span class="cm-variable">full</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">consumer</span>(){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    <span class="cm-keyword">while</span>(<span class="cm-number">1</span>){</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">P</span>(<span class="cm-variable">full</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">P</span>(<span class="cm-variable">mutex</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">18</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">remove</span> <span class="cm-variable">an</span> <span class="cm-variable">item</span> <span class="cm-variable">from</span> <span class="cm-variable">buffer</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">19</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">V</span>(<span class="cm-variable">mutex</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">20</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">V</span>(<span class="cm-variable">empty</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">21</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">        <span class="cm-variable">consume</span> <span class="cm-variable">the</span> <span class="cm-variable">item</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">22</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">    }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">23</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 644px;"></div><div class="CodeMirror-gutters" style="height: 644px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><span>读者-写者问题</span></p><ul><li><p><em><span>多个读者可同时读，但同一时刻只允许一个写，写操作完成前不能读或写，写之前所有读者和写者都必须退出</span></em></p></li><li><p><span>由于有</span><em><span>多个读者，一对 PV 无法解决，可设置一个count记录当前读者的个数</span></em><span>，初值为0</span></p></li></ul></li><li><p><span>哲学家进餐问题</span></p><ul><li><p><span>设置不当（使用贪心算法）将导致死锁</span></p></li><li><p><span>只需设置一个互斥信号量，在同一时刻保证只有一个哲学家拿左右两边的筷子，即可解决</span></p></li><li><p><span>关于哲学家进餐的引申</span></p><ul><li><p><span>哲学家进餐的一个变体是中间有m个碗，必须有碗+筷子才能吃饭</span></p></li><li><p><span>引申：若有其他资源（如这里的碗）是取来就能用而不会发生死锁（每个进程只需一个），那么就可以通过控制碗的数量来限制同时抢筷子（可能发生死锁的资源）的进程的数量，</span><em><span>只有先抢到了碗才能抢筷子</span></em><span>，如：把碗设置成 min(n-1,m)，n为进程数量，那么最多n-1个进程抢筷子，不会发生死锁</span></p></li></ul></li></ul></li></ul></li></ul></li></ol><h4 id='死锁'><span>死锁</span></h4><ul><li><p><span>概念</span></p><ul><li><p><span>多进程抢资源引发相互等待，若无外力作用，这些进程都将无法推进</span></p></li><li><p><span>死锁和饥饿的区别</span></p><ul><li><p><span>进入</span><em><span>饥饿的进程可以只有一个</span></em><span>，但进入死锁的进程一定大于等于2个</span></p></li><li><p><span>发生</span><em><span>饥饿的进程可以是就绪态或阻塞态</span></em><span>，发生</span><em><span>死锁的进程一定是阻塞态</span></em></p></li><li><p><span>饥饿不一定会导致死锁，发生</span><em><span>死锁也不一定是饥饿</span></em><span>，两者概念和侧重点不同</span></p></li></ul></li><li><p><span>原因</span></p><ul><li><p><span>对不可剥夺资源的竞争</span></p><ul><li><p><span>对可剥夺资源的竞争不会引起死锁</span></p></li></ul></li><li><p><span>进程推进顺序非法</span></p><ul><li><p><span>请求和释放资源的顺序不当，如信号量的使用：两个进程都在等待对方发来的消息，导致死锁</span></p></li></ul></li></ul></li><li><p><span>必要条件（必须</span><em><span>同时满足</span></em><span>）</span></p><ul><li><p><span>互斥条件</span></p><ul><li><p><span>进程对所分配的资源要求进行排他性使用</span></p></li></ul></li><li><p><span>不剥夺条件</span></p><ul><li><p><span>进程所获得的资源使用完之前，不能被强行夺走</span></p></li></ul></li><li><p><span>请求并保持条件</span></p><ul><li><p><span>进程已经保持了至少一个资源，但又</span><em><span>申请新的资源，进程被阻塞时拿着自己的资源不放</span></em></p></li></ul></li><li><p><span>循环等待条件</span></p><ul><li><p><span>存在一种进程资源的循环等待链，链中每个进程所获得的资源同时被下一个进程所请求</span></p><ul><li><p><span>死锁的等待环形成的条件更严，Pi进程的资源必须由Pi+1来满足。而</span><em><span>循环等待条件，可由多个进程满足资源请求</span></em><span>，其中的某些进程可能不在环中</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>处理策略</span></p><ol start='' ><li><p><span>死锁预防</span></p><ul><li><p><span>破坏四个条件中的一个即可</span></p></li><li><p><span>破坏互斥条件</span></p><ul><li><p><span>即允许资源都能用，但这显然是不合理的</span></p></li></ul></li><li><p><span>破坏不剥夺条件</span></p><ul><li><p><span>申请不到请求的资源则剥夺已保持的资源</span></p></li><li><p><span>适用于状态易于保存和恢复的资源，但</span><em><span>不能用于打印机等资源</span></em></p></li></ul></li><li><p><span>破坏请求并保持条件</span></p><ul><li><p><span>预分配资源，进程在运行前一次性申请完它所需要的资源，运行时不再有新资源申请</span></p></li><li><p><span>系统资源浪费严重，且可能导致饥饿现象</span></p></li></ul></li><li><p><span>破坏循环等待条件</span></p><ul><li><p><span>采用顺序资源分配法，首先给资源编号，规定每个进程只能按编号递增的顺序请求资源，同类资源一次性申请完</span></p></li><li><p><span>只要进程提出申请分配资源Ri，则该进程在之后的资源申请中就只能申请编号大于Ri的资源</span></p></li><li><p><span>编号必须保持稳定，这就限制了新类型设备的增加，另外容易造成资源的浪费，和对用户编程带来麻烦</span></p></li></ul></li></ul></li><li><p><span>死锁避免</span></p><ul><li><p><span>在资源动态分配过程中，防止系统进入不安全状态，避免发生死锁</span></p></li><li><p><span>同样是事先预防的策略。允许进程动态地申请资源，但在资源分配前，应当计算分配的安全性</span></p></li><li><p><span>系统安全状态</span></p><ul><li><p><span>系统能按某种进程推进顺序，为每个进程分配所需的资源，让每个进程都能完成</span></p></li><li><p><span>不是每个不安全状态都会变成死锁，但只要是</span><em><span>安全状态就一定不会有死锁</span></em></p></li></ul></li><li><p><span>银行家算法</span></p><ul><li><p><span>最著名的死锁避免算法，它并不是“限制了申请资源的顺序”，而是判断某个顺序是否合法</span></p></li><li><p><span>数据结构描述</span></p><ul><li><p><span>可利用资源向量Available</span></p></li><li><p><span>最大需求矩阵Max</span></p></li><li><p><span>分配矩阵Allocation</span></p></li><li><p><span>需求矩阵Need</span></p><ul><li><p><span>Need=Max-Allocation</span></p></li><li><p><span>一般而言Max和Allocation是已知条件，求出Need是解题的第一步</span></p></li><li><p><span>请求向量request不一定和need相等，因为可能有多次请求</span></p></li></ul></li></ul></li><li><p><span>银行家算法描述</span></p><ul><li><p><span>设requesti是进程Pi的请求向量，request[j]=K表示需要j类资源K个。系统按下列顺序检查</span></p></li><li><p><span>若</span><code>request[j]&lt;=need[i,j]</code><span>，则继续下一步，否则认为出错，因为申请量已经超过的声明的最大量</span></p></li><li><p><span>若</span><code>request[j]&lt;=available[j]</code><span>，则继续下一步，否则表示没有充足的资源，Pi必须等待</span></p></li><li><p><span>系统试探着分配资源给Pi，并且修改下列数据结构的数值：</span></p><ul><li><p><span>available=available-request</span></p></li><li><p><span>allocation=allocation+request</span></p></li><li><p><span>need=need-request</span></p></li></ul></li><li><p><span>系统执行安全性算法，若安全才正式分配，否则分配作废，所有数据改回之前的值，并让Pi等待</span></p></li></ul></li><li><p><span>安全性算法</span></p><ul><li><p><span>设置工作向量Work，表示系统中剩余的可用资源数目，在开始时work=available</span></p><ul><li><p><span>work是安全性算法的，用来检测是否有安全序列，和available作用不同</span></p></li></ul></li><li><p><em><span>初始时安全序列为空</span></em></p></li><li><p><span>在</span><em><span>need矩阵</span></em><span>中，找出以下行</span></p><ul><li><p><span>该行对应的进程不在安全序列中</span></p></li><li><p><span>该行的每个数值都小于等于work的对应数值</span></p></li><li><p><span>找到该行后，将该进程加入安全序列。若找不到这一行，则转到最后一步</span></p></li><li><p><em><span>Pi进入安全序列后，可顺利执行完毕，并释放资源，计算work=work+allocation</span></em><span>，然后返回上一步</span></p></li><li><p><span>若安全序列里</span><em><span>已有所有进程，则系统处于安全状态</span></em><span>，若没有则是不安全状态</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>死锁检测和解除</span></p><ul><li><p><span>不采取任何行动，允许发生死锁，检测出死锁产生后，采取某种措施解除死锁</span></p></li><li><p><span>资源分配图</span></p><ul><li><p><span>用</span><em><span>圆圈代表一个进程，用框代表一类资源</span></em><span>，框中圆的个数代表资源的个数</span></p></li><li><p><em><span>进程到资源的箭头表示请求边</span></em><span>，该进程申请一个资源</span></p></li><li><p><em><span>资源到进程的箭头表示分配边</span></em><span>，n个箭头表示n个资源已分配给该进程</span></p></li></ul></li><li><p><span>死锁定理</span></p><ol start='' ><li><p><span>在资源分配图中找出不阻塞又不孤立的进程</span></p></li></ol><ul><li><p><span>也就是某进程</span><em><span>所申请的资源数量都还够</span></em></p></li></ul><ol start='2' ><li><p><span>若找到了，则它能运行完成并释放资源。</span><em><span>消去它和它所有的请求边和分配边</span></em><span>，使之成为孤立的节点</span></p></li><li><p><span>进程Pi释放的资源可能使某些阻塞的进程醒来</span></p></li><li><p><span>重复前面的步骤，继续消除边</span></p></li><li><p><span>若某资源分配图中能消去所有的边，则是可以完全简化的</span></p><ul><li><p><span>当资源分配图不可完全简化则出现死锁</span></p></li></ul></li></ol></li><li><p><span>最少出现死锁的进程个数</span></p><ul><li><p><span>画资源分配图，但先不分配资源，而仅画出申请箭头</span></p></li><li><p><span>死锁必须有循环等待条件，根据资源分配图中的循环等待确定最少死锁进程</span></p></li><li><p><span>死锁公式：</span><span class='math-in-toc'>$m&gt;n*(w-1)$</span><span>，则不会发生死锁，m为资源数，n为互斥进程数，w为所有进程中需求资源最多的数量</span></p></li></ul></li><li><p><span>死锁解除</span></p><ul><li><p><span>资源剥夺</span></p><ul><li><p><span>挂起某些死锁进程，并抢占它的资源</span></p></li></ul></li><li><p><span>撤销进程</span></p><ul><li><p><span>强制撤销部分甚至全部的死锁进程并剥夺这些进程的资源</span></p></li></ul></li><li><p><span>进程回退</span></p><ul><li><p><span>让一个或多个进程回退到足以回避死锁的地步。进程回退时自愿释放资源而非被剥夺</span></p></li><li><p><span>需要系统保持进程的历史信息，设置还原点</span></p></li></ul></li></ul></li></ul></li><li><p><span>有关并发进程代码执行可能的结果</span></p></li></ol><ul><li><p><span>首先遮盖掉必然成立的语句、和另一个进程无关的语句、结果可以确定的语句，再分析</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='内存管理'><span>内存管理</span></h2><h4 id='概念-2'><span>概念</span></h4><ul><li><p><span>操作系统对内存的划分和动态分配即内存管理</span></p></li><li><p><span>功能</span></p><ul><li><p><span>内存的分配与回收</span></p><ul><li><p><span>由操作系统完成，降低对程序员的压力</span></p></li></ul></li><li><p><span>地址转换</span></p><ul><li><p><span>多道程序下，程序中的逻辑地址和内存中的物理地址可能不一致</span></p></li></ul></li><li><p><span>内存空间的扩充</span></p><ul><li><p><span>利用虚拟存储技术和自动覆盖技术，</span><em><span>逻辑上</span></em><span>扩充内存</span></p></li></ul></li><li><p><span>内存共享和存储保护</span></p><ul><li><p><span>允许多个进程访问内存的同一部分，但也保证各道作业在各自的存储空间运行，互不干扰</span></p></li></ul></li></ul></li><li><p><span>程序的链接和装入</span></p><ol start='' ><li><p><span>编译</span></p></li></ol><ul><li><p><span>由编译程序将源代码编译成若干目标模块</span></p></li></ul><ol start='2' ><li><p><span>链接</span></p></li></ol><ul><li><p><span>由链接模块将目标模块和所需的库函数链接在一起，形成一个完整的装入模块</span></p></li><li><p><span>编译仅形成每个模块内的逻辑地址，而整个程序的逻辑地址是在链接时得到的</span></p></li><li><p><span>链接方式</span></p><ul><li><p><span>静态链接</span></p><ul><li><p><span>程序运行前，链接成完整的模块，链接完成后不能拆开</span></p></li></ul></li><li><p><span>装入时动态链接</span></p><ul><li><p><span>装入内存时，一边装入一边链接</span></p></li><li><p><span>便于修改和更新，便于实现对目标模块的共享</span></p></li></ul></li><li><p><span>运行时动态链接</span></p><ul><li><p><span>对某些目标模块的链接，是在程序执行过程中需要该模块时才进行的</span></p></li><li><p><span>能加快程序的装入过程，还可节省大量内存空间</span></p></li><li><p><span>仅虚拟存储器（请求型离散分配）才可以使用</span></p></li></ul></li></ul></li></ul><ol start='3' ><li><p><span>装入</span></p></li></ol><ul><li><p><span>由装入程序将装入模块装入内存运行</span></p></li><li><p><span>装入方式</span></p><ul><li><p><span>绝对装入</span></p><ul><li><p><span>只适合</span><em><span>单道</span></em><span>程序环境</span></p></li><li><p><span>编译时已知程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码</span></p></li><li><p><span>程序中的</span><em><span>逻辑地址和实际地址相同</span></em><span>，不需要修改</span></p></li></ul></li><li><p><span>可重定位装入</span></p><ul><li><p><span>多道程序下，多个目标模块的起始地址通常都是0开始</span></p></li><li><p><span>装入时</span><em><span>对目标程序中的指令和数据地址的修改过程称为重定位</span></em></p></li><li><p><span>地址变换通常是在进程装入时</span><em><span>一次完成</span></em><span>的，也称静态重定位</span></p></li><li><p><span>装入时，必须分配程序所要求的</span><em><span>全部内存空间</span></em><span>，若空间不足就无法装入；</span><em><span>作业一旦装入内存就无法移动，也不能再申请内存空间</span></em></p></li><li><p><span>仅支持固定或单一连续分配</span></p></li></ul></li><li><p><span>动态运行时装入</span></p><ul><li><p><span>也称动态重定位，</span><em><span>程序可以在内存中发生移动</span></em></p></li><li><p><span>装入程序把装0入模块装入内存后，不立即把装入模块中的相对地址转化为绝对地址，而是</span><em><span>推迟到程序要真正执行的时候</span></em><span>才进行</span></p></li><li><p><span>装入内存后所有地址均为相对地址</span></p></li><li><p><span>这种方法需要一个重定位寄存器的支持，</span><em><span>相对地址+重定位寄存器的值=绝对地址</span></em></p><ul><li><p><span>重定位寄存器整个系统仅需一个</span></p></li></ul></li><li><p><span>可以将程序分配到不连续的存储区，程序运行前只需装入部分代码即可运行，程序运行时可动态申请内存，便于程序段的共享</span></p></li><li><p><span>支持可变分区连续分配、离散分配</span></p></li></ul></li></ul></li></ul></li><li><p><span>地址</span></p><ul><li><p><span>逻辑地址</span></p><ul><li><p><span>编译后每个模块的地址都是从0开始的，称为相对地址或逻辑地址。</span><em><span>链接时</span></em><span>，将多个模块的地址构成统一的从0开始的逻辑地址</span></p></li><li><p><span>进程在运行时，</span><em><span>看到和使用的都是逻辑地址</span></em><span>，</span><em><span>内存管理机制对应用程序员透明</span></em></p></li><li><p><span>不同进程可以有</span><em><span>相同逻辑地址</span></em><span>，能够映射到主存的不同位置</span></p></li></ul></li><li><p><span>物理地址</span></p><ul><li><p><span>进程的执行指令和访问数据，最后都要通过物理地址从主存中存取</span></p></li><li><p><span>物理地址根据装入方式不同，在不同时期形成</span></p></li></ul></li><li><p><span>操作系统通过内存管理部件 MMU 将进程使用的逻辑地址转化为物理地址，其核心是</span><em><span>页表</span></em><span>，</span><em><span>页表由操作系统维护</span></em><span>，并被处理器引用</span></p></li></ul></li><li><p><span>内存映像</span></p><ul><li><p><span>组成</span></p><ol start='' ><li><p><span>代码段：程序的二进制代码，</span><em><span>只读</span></em><span>，可被多个进程共享</span></p></li><li><p><span>数据段</span></p><ul><li><p><span>包含全局变量和静态变量</span></p></li><li><p><span>代码段和数据段在程度调入内存时就指定了大小</span></p></li></ul></li><li><p><span>进程控制块PCB</span></p><ul><li><p><span>存放在系统区，OS通过PCB来管理进程</span></p></li></ul></li><li><p><span>堆</span></p><ul><li><p><span>存放动态分配的变量（程序员手动分配），通过调用malloc函数向高地址分配空间</span></p></li></ul></li><li><p><span>栈</span></p><ul><li><p><span>用来实现函数的调用，从用户空间的</span><em><span>高地址往低地址分配</span></em></p></li><li><p><span>堆和栈都能在程序运行时动态扩展和收缩</span></p></li></ul></li></ol></li><li><p><span>程序的内存映像，就是程序在运行时，在内存中的“样子”</span></p></li></ul></li><li><p><span>内存保护</span></p><ul><li><p><span>确保每个进程都有一个单独的内存空间</span></p></li><li><p><span>是操作系统的任务，但由硬件来实现</span></p></li><li><p><span>实现</span></p><ol start='' ><li><p><span>设置一对上下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，</span><em><span>分别和两个寄存器的值对比，判断是否越界</span></em></p></li><li><p><span>或采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）。</span><em><span>重定位寄存器含最小的物理地址，界地址寄存器含逻辑地址最大值</span></em><span>。</span><em><span>逻辑地址先和界地址寄存器的值比较，若无越界，就和重定位寄存器相加得到物理地址</span></em></p></li></ol><ul><li><p><span>加载这两个寄存器</span><em><span>必须使用特权指令</span></em><span>，只有内核才能加载它们</span></p></li><li><p><span>允许内核修改这两个寄存器的值，而不允许用户程序修改</span></p></li></ul></li></ul></li><li><p><span>内存共享</span></p><ul><li><p><span>只有那些只读的区域才能共享</span></p></li><li><p><span>可重入代码又称纯代码，是允许多个进程同时访问但不允许修改的代码</span></p></li><li><p><span>但在实际执行时，每个进程配备局部数据区，把可能改变的部分复制到该数据区，就可以实现不改变共享代码而得到改动的数据</span></p></li><li><p><span>段的共享非常简单易行，因为段是以程序段为单位的，但页式是以页为单位的，每个页都要有一个页表项</span></p></li></ul></li><li><p><span>内存分配与回收</span></p><ul><li><p><span>单一连续、固定分区、动态分区、离散分配</span></p></li></ul></li></ul><h4 id='覆盖与交换'><span>覆盖与交换</span></h4><ul><li><p><span>覆盖：把用户空间分成一个固定区和若干覆盖区</span></p><ul><li><p><span>已成历史</span></p></li></ul></li><li><p><span>交换：把处于等待的程序从内存移到外存</span></p></li><li><p><span>是多道程序环境下用来扩充内存的两种方法</span></p></li></ul><h4 id='连续分配'><span>连续分配</span></h4><ul><li><p><span>指为用户程序分配一个</span><em><span>连续的内存空间</span></em></p></li><li><p><span>单一连续分配</span></p><ul><li><p><span>有系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；用户区</span><em><span>仅一个进程</span></em></p></li></ul></li><li><p><span>固定分区分配</span></p><ul><li><p><em><span>将内存分为多个区域，每个区域装入一道程序</span></em></p><ul><li><p><span>分区大小不等</span></p></li><li><p><span>分区大小相等</span></p><ul><li><p><span>程序太小会造成浪费，太大又装不下，缺乏灵活性</span></p></li></ul></li></ul></li><li><p><span>建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配）</span></p></li><li><p><span>会产生</span><em><span>内部碎片</span></em><span>，且存储空间利用率低</span></p></li></ul></li><li><p><span>可变分区分配</span></p><ul><li><p><span>又称动态分区分配，动态地分配内存给程序的，换句话说，</span><em><span>系统中的分区的大小可变，也可能产生分区的移动</span></em></p></li><li><p><span>会</span><em><span>产生外部碎片</span></em><span>，即空闲空间存在分区的外部</span></p></li><li><p><span>外部碎片可通过紧凑技术解决，即操作系统不断对进程进行移动和整理，但需要动态重定位寄存器的支持</span></p></li><li><p><span>分配策略</span></p><ol start='' ><li><p><span>首次适应</span></p><ul><li><p><span>空闲分区以</span><em><span>地址递增</span></em><span>的次序链接，顺序查找到大小能满足的第一个分区分配给作业</span></p></li><li><p><span>通常也是最好和最快的</span></p></li></ul></li><li><p><span>邻近适应</span></p><ul><li><p><span>和首次适应类似，但</span><em><span>从上次查找结束的地方开始查找</span></em></p></li><li><p><span>常常导致在内存空间的尾部分裂成小碎片</span></p></li></ul></li><li><p><span>最佳适应</span></p><ul><li><p><span>空闲分区按</span><em><span>容量递增</span></em><span>的次序链接，找到第一个能满足要求且最小的空闲分区分配</span></p></li><li><p><span>每次分配会产生很小的内存块，会</span><em><span>产生最多的外部碎片</span></em></p></li></ul></li><li><p><span>最坏适应</span></p><ul><li><p><span>空闲分区按容量递减的次序链接，找到第一个能满足要求且最大的空闲分区分配</span></p></li><li><p><span>会很快没有大的内存块，性能差</span></p></li></ul></li><li><p><span>其它方法：基于索引搜索的分配</span></p><ul><li><p><span>空闲区链可能很长，因此对空闲区块按大小分类，设置多个分区链，分配时在索引表中查找</span></p></li><li><p><span>快速适应算法：根据进程长度找到能容纳它的最小分区链表，取出第一块分区进行分配。不产生内部碎片，但回收时须合并分区</span></p></li><li><p><span>伙伴算法：规定所有分区大小为</span><span class='math-in-toc'>$2^k$</span><span>，若分区不够了，就将大一级的分区掰成两半，一个用于分配，一个加入小一级分区的链中，这两个分区称为一对伙伴</span></p></li></ul></li></ol></li><li><p><span>与固定分区分配类似，设置一张空闲分区链表，并按始址排序，分配内存时检索该表，并按分配算法进行分配</span></p></li><li><p><span>内存回收</span></p><ul><li><p><span>若本段内存前面是空闲区，就将空闲链表的前一段空闲区的大小加上本段内存大小</span></p></li><li><p><span>若后一段是空闲的，就修改后一个空闲区的大小</span></p></li><li><p><span>若前后都是空闲的，则修改前面空闲区大小，同时取消后面空闲区表项</span></p></li><li><p><span>若回收区没有相邻的空闲分区，就新建一个表项并插入空闲链表</span></p></li></ul></li></ul></li></ul><h4 id='离散分配'><span>离散分配</span></h4><ul><li><p><span>基本分页存储</span></p><ul><li><p><span>把主存空间划分为大小相等且固定的块，作为主存的基本单位。每个进程同样以块为单位进行划分，以块为单位申请主存的块空间，这个块就是</span><em><span>页</span></em></p></li><li><p><span>基本的离散分配中，必须将程序一次性装入内存，这是和请求型分配的区别</span></p></li><li><p><span>注意：</span><em><span>主存的访问总是以字节或字为单位，仅在交换时以块（与Cache）或页（与辅存）为单位</span></em></p></li><li><p><span>进程中的块称为页或页面，内存中的块称为页框或页帧，它们大小相等</span></p><ul><li><p><span>共享时，页框在内存中是固定的，在特定的进程的地址空间的页的地址可能不同</span></p></li></ul></li><li><p><span>页的大小必须适当，太大将产生内部碎片，太小又会使进程页数过多，让页表变大</span></p></li><li><p><span>分页或分段后，由于页表或段表占空间，导致给用户的物理空间将减小</span></p></li><li><p><span>地址结构</span></p><ul><li><p><em><span>页号+页内偏移量（页内地址）</span></em></p></li><li><p><span>一般每个页大小4KB，即32位的地址中，20位是页号，12位是页内地址（字节寻址）</span></p></li><li><p><span>页的大小和逻辑地址的划分由</span><em><span>硬件直接实现</span></em></p></li></ul></li><li><p><span>页表</span></p><ul><li><p><em><span>存放在内存中</span></em><span>，用于记录进程的页面在内存中对应的页框号</span></p></li><li><p><span>作用是实现</span><em><span>页号到页框号的变换</span></em></p></li><li><p><span>结构：</span><em><span>页号+该页的页框号</span></em></p><ul><li><p><span>注意查找页表时，</span><em><span>逻辑地址中的页号字段能直接指示页表的第几个表项，故不是一一对比</span></em></p></li><li><p><span>页表项连续存放，因此</span><em><span>页号可以隐含</span></em><span>，不占用存储空间，后面的段表同理</span></p></li><li><p><span>页表中的页号是用于调入 Cache 中等特殊情况，不能直接通过虚拟页号得到第几个页表项的时候用的</span></p></li><li><p><span>基本分页存储中，页表只有页号和该页的物理块号，而请求分页存储中新增了修改位、脏位、访问位、外存物理地址。在计组中说页表有修改位啥的，是把请求分页弄一起了</span></p></li></ul></li><li><p><em><span>每个进程一个页表</span></em></p></li></ul></li><li><p><span>基本地址变换机构</span></p><ul><li><p><span>从逻辑地址到物理地址，是借助页表实现的</span></p></li><li><p><span>系统中常设置一个</span><em><span>页表寄存器，存放页表在内存中的起始地址F和页表长度M</span></em></p><ul><li><p><span>进程未执行时，页表的始址和页表长度存放在PCB中，而运行时始址和页表长度进入页表寄存器</span></p></li></ul></li><li><p><span>转化的计算</span></p><ol start='' ><li><p><span>设逻辑地址为 A，页面大小为 L</span></p></li><li><p><span>页号 P= A/L（向下取整），页内偏移量W = A%L</span></p></li><li><p><span>比较页号和页表长度 M，若 P 大于等于 M，则产生越界中断</span></p></li><li><p><span class='math-in-toc'>$页表项地址=页表始址+页号*页表项长度$</span><span>，取出该页表项内容b，即物理块号</span></p><ul><li><p><span>页表长度指总的</span><em><span>页数</span></em></p></li><li><p><span>页表项是页表中的</span><em><span>某一项</span></em><span>，其主要存储的是某一个页的物理地址</span></p></li></ul></li><li><p><span>计算E= b*L+W，此即物理地址</span></p></li><li><p><span>注意给出的逻辑地址是十进制的还是二进制的</span></p></li></ol></li><li><p><span>地址变换过程由硬件自动完成</span></p></li><li><p><span>页表项大小的确定</span></p><ul><li><p><span>必须保证表示范围能够容纳所有页面</span></p></li><li><p><span>同时考虑到是以字节 B 为编址单位，因此</span><em><span>必须是 B 的整数倍</span></em></p></li></ul></li><li><p><span>分页的两个问题</span></p><ul><li><p><span>地址转化速度必须够快，否则访存速度会降低</span></p><ul><li><p><span>使用快表TLB解决</span></p></li></ul></li><li><p><span>页表不能太大，否则内存利用率会降低</span></p><ul><li><p><span>二级和多级页表解决</span></p></li></ul></li></ul></li></ul></li><li><p><span>快表TLB</span></p><ul><li><p><span>若页表全部放在内存中，则存取一个数据或指令至少两次访存</span></p></li><li><p><span>在地址变换机构中增设一个具有</span><em><span>并行查找</span></em><span>能力的Cache，也就是快表，又称相联存储器</span></p></li><li><p><em><span>快表存放部分页表项</span></em></p></li><li><p><span>若某次查找中，快表没有匹配的页号，则需访问页表，还要将该页表项存入TLB，若已满则需要按特定算法淘汰一个旧页表项</span></p></li><li><p><span>快表</span><em><span>不一定</span></em><span>采用全相联映射</span></p></li><li><p><em><span>每访问一个地址，都需要访问TLB，且缺页调页后，仍然需要重新访问 TLB</span></em></p></li></ul></li><li><p><span>两级页表</span></p><ul><li><p><span>即建立页表的页表，称为页目录，即多级索引</span></p></li><li><p><span>不用把页表都调入内存，只有在需要它时才调用，能解决内存空间占用过大的问题</span></p></li><li><p><span>为了查询方便，</span><em><span>顶级页表所占的空间一般最多只能是一个页面，通常是 4KB</span></em></p><ul><li><p><span>一般而言，多级页表中，</span><em><span>每级的地址长度相同</span></em></p></li></ul></li><li><p><span>逻辑地址的格式为：</span><em><span>一级页号（页目录号）+二级页号+页内偏移量</span></em><span>。例如一级页表的页表项个数为1K，则占用10位高位的地址，而页内偏移量和页内的地址个数有关，剩下的位数就是留给二级页号的位数</span></p></li><li><p><span>多级页表的目的在于索引，不用浪费主存空间去存储无用的页表项，也不用盲目地顺序查找页表项</span></p></li><li><p><span>多级页表建议画图，能理清它们之间的逻辑关系</span></p></li><li><p><span>回答页号、页目录号等问题时可以用十六进制，但别忘了带 H</span></p></li></ul></li></ul></li><li><p><span>基本分段存储</span></p><ul><li><p><em><span>分页对用户透明</span></em><span>，而</span><em><span>分段不透明（可见）</span></em><span>，是为了方便程序员和用户</span></p></li><li><p><span>分段在用户编程时决定，有利于程序的动态链接，因为动态链接和程序的逻辑有关</span></p></li><li><p><span>段号是根据进程段得到的，两个进程使用共享段的位置不一定相同，故</span><em><span>段号不一定相同</span></em></p></li><li><p><span>逻辑地址结构</span></p><ul><li><p><em><span>段号+段内偏移量（段内地址）</span></em></p></li><li><p><em><span>段内要求连续，而同一进程的段与段之间不要求连续。段的长度可变，因此整个作业的地址空间是二维的</span></em><span>（分页是一维的）</span></p></li></ul></li><li><p><span>段表结构：段号+段长+本段在主存的地址</span></p></li><li><p><span>分段系统中，段号和段内偏移量必须由用户显式提供，这一过程也可由编译器完成</span></p></li><li><p><span>地址变换机构</span></p><ul><li><p><span>在系统中设置了段表寄存器，用于</span><em><span>存放段表始址 F 和段表长度 M</span></em></p></li><li><p><span>地址变换过程</span></p><ol start='' ><li><p><span>比较段号和段表长度，若段号大于等于段表长度，则产生越界中断</span></p></li><li><p><span>段表中段表项的查找：</span><span class='math-in-toc'>$段表始址+段号*段表项长度$</span><span>。取出段长部分C，若段内偏移量 W 大于等于C，则产生越界中断</span></p></li><li><p><span>取出本段在主存的地址 b，物理地址E=b+W</span></p></li></ol></li></ul></li><li><p><span>段的共享与保护</span></p><ul><li><p><span>段的共享通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的</span></p></li><li><p><span>不可修改的代码称为纯代码或可重入代码，它</span><em><span>不属于临界资源</span></em></p><ul><li><p><span>可修改的代码和数据不能共享</span></p></li><li><p><span>可重入技术通过共享，减少了调入调出块（对换），从而提升了系统性能</span></p></li></ul></li><li><p><span>主要有两种保护方法</span></p><ul><li><p><span>存取控制保护</span></p></li><li><p><span>地址越界保护</span></p><ul><li><p><em><span>需要判断段号和段内偏移量是否越界</span></em><span>，而页式由于页的大小是固定的，只需判断页号是否越界</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>段页式存储</span></p><ul><li><p><em><span>作业先分段再分页，内存仅分页，分配仍以页为单位</span></em></p></li><li><p><em><span>用分段方法管理用户地址空间，用分页的方法管理物理地址空间</span></em></p></li><li><p><em><span>作业的逻辑地址分为：段号+页号+页内偏移量</span></em></p></li><li><p><em><span>一个进程一个段表，进程的每个段都有一个页表</span></em></p></li><li><p><span>段表表项包含：段号+页表长度+页表始址。页表表项包含页号和块号</span></p></li><li><p><span>系统中还有一个段表寄存器，指出作业段表始址和段表长度</span></p></li><li><p><span>使用段页式存储，对某地址的访问实际需要三次访存，当然也可以使用快表技术</span></p><ul><li><p><span>快表的关键字由段号+页号组成，值是对应的页帧号和保护码</span></p></li></ul></li><li><p><span>段页式管理的地址空间是二维的</span></p></li></ul></li><li><p><span>离散分配需要存储离散地区的索引，使得存储密度低于连续分配</span></p></li></ul><h4 id='虚拟内存'><span>虚拟内存</span></h4><ul><li><p><span>传统存储器管理方式</span></p><ul><li><p><span>一次性：作业必须一次性装入内存后才能开始运行</span></p></li><li><p><span>驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出</span></p></li></ul></li><li><p><span>局部性原理</span></p><ul><li><p><span>既适用于程序结构，也适用于数据结构</span></p></li><li><p><em><span>TLB、Cache、虚拟内存等都依赖于局部性原理</span></em></p></li></ul></li><li><p><span>虚拟内存的概念</span></p><ul><li><p><span>特征</span></p><ol start='' ><li><p><span>多次性</span></p><ul><li><p><span>作业无需一次全部装入内存，而是分多次调入</span></p></li><li><p><span>可使用动态运行时链接</span></p></li></ul></li><li><p><span>对换性</span></p><ul><li><p><span>作业无需一直常驻内存，而是会换出</span></p></li></ul></li><li><p><em><span>虚拟性</span></em></p><ul><li><p><em><span>逻辑上</span></em><span>扩充内存的容量</span></p></li><li><p><span>是虚拟存储器表现出的最重要特征，也是最重要的目标</span></p></li></ul></li></ol></li><li><p><span>虚拟存储器由主存+辅存在逻辑上构成，程序装入时只要当前运行的少数页面或段装入内存即可</span></p></li><li><p><span>虚拟存储器的</span><em><span>最大容量是理论上的，由地址的长度决定</span></em></p></li><li><p><span>虚拟空间（地址）的大小由OS和底层虚存管理程序决定，不一定等于物理地址大小</span></p></li><li><p><span>内存+硬盘大小仅决定实际可用大小，</span><em><span>malloc和new返回的都是虚拟地址</span></em></p></li></ul></li><li><p><span>虚拟内存的实现</span></p><ul><li><p><span>虚拟内存建立在离散分配基础上，虚拟硬件支持</span></p></li><li><p><span>实现方式</span></p><ul><li><p><span>请求分页、请求分段、请求段页式存储管理</span></p></li></ul></li><li><p><span>硬件支持</span></p><ul><li><p><span>内存+外存、页表或段表机制、中断机构、地址变换机构</span></p></li></ul></li></ul></li><li><p><span>请求分页</span></p><ul><li><p><span>建立在基本分页系统上，</span><em><span>增加了请求调页和页面置换功能</span></em></p></li><li><p><span>页表构成</span></p><ul><li><p><span>传统的：页号、物理块号</span></p></li><li><p><span>状态位（存在位、合法位）P</span></p><ul><li><p><span>用于指示该页是否被调入内存</span></p></li></ul></li><li><p><span>访问字段A</span></p><ul><li><p><span>用于记录本页在一段时间的访问次数，供置换算法参考</span></p></li></ul></li><li><p><span>修改位M</span></p><ul><li><p><span>标识该页在调入内存后是否被修改，以确定是否写回外存</span></p></li></ul></li><li><p><span>外存地址</span></p><ul><li><p><span>指出该页在外存的地址，通常是物理块号，供该页调入时参考</span></p></li></ul></li></ul></li><li><p><span>缺页中断</span></p><ul><li><p><span>即：要访问的页面不在内存中</span></p></li><li><p><span>缺页又称页故障，由存在位决定</span></p></li><li><p><em><span>由访存指令引起</span></em><span>。当处理完后，需要再次执行这条指令</span></p></li><li><p><span>缺页中断时，会把缺页的</span><em><span>进程阻塞</span></em><span>，直到页面被调入内存</span></p></li><li><p><span>缺页中断也是一种中断，和中断的处理方式一样，但和中断相比有以下不同</span></p><ul><li><p><em><span>在指令执行期间产生，属于内部异常</span></em></p></li><li><p><em><span>一条指令在执行时，可能产生多次缺页中断</span></em></p></li></ul></li></ul></li><li><p><span>地址变换</span></p><ul><li><p><span>新增产生缺页中断、换页等功能</span></p></li><li><p><span>仍然有快表等东西，快表也仍然是多个页表表项组成的</span></p></li></ul></li></ul></li><li><p><span>页框分配</span></p><ul><li><p><span>驻留集</span></p><ul><li><p><span>给一个进程分配的</span><em><span>物理页框的个数</span></em></p></li><li><p><span>给进程分配的驻留集越小，则驻留在主存中的进程就越多，从而可提高CPU的利用率</span></p></li><li><p><span>但驻留集太小，尽管有局部性原理，但缺页率仍然会非常高，甚至出现抖动</span></p></li><li><p><span>分配的页框过多，根据局部性原理，缺页率基本不变</span></p></li></ul></li><li><p><span>内存分配策略</span></p><ul><li><p><span>固定分配局部置换</span></p><ul><li><p><span>固定分配：为每个进程</span><em><span>分配数量一定的物理块</span></em><span>，在程序运行期间不变</span></p></li><li><p><span>局部置换：如果发生缺页，则在分配给该进程的页面中选择一页换出，</span><em><span>不改变分配给该进程的内存空间大小</span></em></p></li><li><p><span>这种策略难以确定每个进程分配的物理块数</span></p></li></ul></li><li><p><span>可变分配全局置换</span></p><ul><li><p><span>可变分配：为每个进程分配一定的物理块，</span><em><span>在进程运行期间可适当增加或减少</span></em></p></li><li><p><span>全局置换：若发生缺页，系统从空闲物理块队列中取出一块分配给该进程，并将所缺的页调入</span></p></li><li><p><span>这种策略会盲目地给进程增加物理块，导致多道程序并发能力下降</span></p></li></ul></li><li><p><span>可变分配局部置换</span></p><ul><li><p><span>可变分配+局部置换</span></p></li><li><p><span>若进程在运行期间</span><em><span>频繁发生缺页中断，才分配新的块给该进程</span></em><span>，直到缺页率趋于适度</span></p></li><li><p><span>同样，若进程缺页率特别低，则系统可能会减少分配给该进程的物理块，但不能引起缺页率的明显上升</span></p></li></ul></li></ul></li><li><p><span>物理块分配（调入）算法</span></p><ul><li><p><span>平均分配算法</span></p><ul><li><p><span>将所有物理块平均分配给每个进程</span></p></li></ul></li><li><p><span>按比例分配算法</span></p><ul><li><p><span>按进程的大小比例分配物理块</span></p></li></ul></li><li><p><span>优先权分配算法</span></p><ul><li><p><span>为重要的和紧迫的任务分配较多的物理块</span></p></li></ul></li></ul></li><li><p><span>页面调入时机</span></p><ul><li><p><span>预调页</span></p><ul><li><p><span>即运行前调入</span></p></li><li><p><span>主要用于进程的首次调入，由程序员指出应先调入哪些页</span></p></li></ul></li><li><p><span>请求调页</span></p><ul><li><p><span>即运行期间调入</span></p></li><li><p><span>若产生了缺页，就发起缺页中断，调入所缺的页面</span></p></li><li><p><span>缺点是</span><em><span>每次只调入一个页面</span></em><span>，增大了IO开销</span></p></li></ul></li></ul></li><li><p><span>何处调入</span></p><ul><li><p><span>外存分为</span></p><ul><li><p><span>文件区</span></p><ul><li><p><span>存放文件，采用离散分配方式</span></p></li></ul></li><li><p><span>对换区</span></p><ul><li><p><span>存放对换页面，采用连续分配方式</span></p></li><li><p><span>以提高换入/换出速度为主要目标</span></p></li><li><p><em><span>磁盘交换区使用率非常高时，本质是抖动</span></em><span>，故要加大内存或减少进程，提升对换区大小或速度是没用的</span></p></li></ul></li></ul></li><li><p><span>系统拥有足够对换区时</span></p><ul><li><p><span>进程在运行前，将进程相关的文件都从文件区复制到对换区。可以全部从对换区调入所需的页面，提高了调页速度</span></p></li></ul></li><li><p><span>系统缺少足够的对换区时</span></p><ul><li><p><span>凡是</span><em><span>不会被修改的文件都直接从文件区调入</span></em><span>，而当调出这些页面时，因为它们未被修改，不用写回；那些可能修改的部分，换出时要换到对换区，以后需要时再读进来</span></p></li></ul></li><li><p><span>UNIX方式</span></p><ul><li><p><span>与进程有关的文件都放在文件区，因此</span><em><span>未运行过的页面都要从文件区调入</span></em></p></li><li><p><em><span>曾经运行过但又被换出的页放在对换区</span></em><span>，下次调入时从对换区调入</span></p></li><li><p><span>进程请求的共享页面若已被其它进程调入，则无需从外存调入</span></p></li></ul></li></ul></li><li><p><span>如何调入</span></p><ul><li><p><span>当所需要的页面的存在位==0时，产生缺页中断-找到物理块并调入</span></p></li><li><p><span>调出时，若未修改则直接被覆盖，若脏位为1，则需要先写回再覆盖</span></p></li></ul></li></ul></li><li><p><span>页面置换算法</span></p><ul><li><p><span>最佳置换OPT</span></p><ul><li><p><span>淘汰页面是以后永远不使用的页面，或是最长时间内不再被访问的页面，有着最低的缺页率，但这不可能实现的理想情况</span></p></li><li><p><span>可以用该算法去评价其它算法</span></p></li><li><p><span>注意最长时间不被访问和以后访问的次数最小是不同的</span></p></li><li><p><em><span>引用串</span></em><span>：</span><em><span>是进程运行时访问的页号序列，可重复</span></em><span>。这一概念以及页面置换图在页面置换算法中很重要</span></p></li><li><p><span>在开始访问时，前面几个都是缺页的，因为内存是空的，</span><em><span>只有当内存满了，置换算法才起作用</span></em></p></li></ul></li><li><p><span>先进先出置换FIFO</span></p><ul><li><p><span>淘汰进来最久的页面</span></p></li><li><p><span>实现：只需将已调入内存的页面根据先后次序链接成队列，设置一个指针指向最老的页面</span></p></li><li><p><span>不科学，因为</span><em><span>进来最久的也可能是经常访问的页面</span></em></p></li><li><p><span>还会出现Belady异常（只有FIFO会出现），也就是对某个进程分配的物理块数增大但缺页率反而上升的情况</span></p></li></ul></li><li><p><span>最近最久未使用LRU</span></p><ul><li><p><span>即把</span><em><span>最长时间没有访问的页面给替换掉</span></em></p></li></ul></li><li><p><span>为每个页面设置一个访问字段，用来记录页面上次被访问以来所经历的时间</span></p><ul><li><p><span>性能较好，但需要寄存器和栈的支持，因为要排序，开销大。是</span><em><span>堆栈类算法</span></em></p></li></ul></li><li><p><span>简单时钟置换Clock</span></p><ul><li><p><span>为每帧设置一个访问位，</span><em><span>被访问或调入时置为1</span></em></p></li></ul></li><li><p><span>又称最近未用算法NRU</span></p><ul><li><p><span>将内存中的所有页面视作一个</span><em><span>循环队列</span></em><span>，有一个替换指针与之相关联。某一页被替换时，该指针指向下一个页</span></p></li><li><p><em><span>替换时，若访问位为0，则替换掉该页，若为1，则置为0，暂不换出，并继续往后检查</span></em><span>。若到了队尾还是没有访问位为0的，就从头开始重新检查</span></p></li></ul></li><li><p><span>改进型Clock</span></p><ul><li><p><span>增加了一个置换代价——修改位，优先考虑淘汰未使用又未修改的页面（即同时检查修改位和访问位）。注意队列仍然是循环队列</span></p></li></ul></li><li><p><em><span>最近未被访问且未修改，是最佳淘汰页；最近未被访问但已被修改，是次级淘汰页</span></em><span>；最近被访问但未修改，再次级，最近访问且被修改，是最不适合淘汰的页（</span><em><span>未访问优先级更高</span></em><span>）</span></p><ul><li><p><span>算法执行过程</span></p><ol start='' ><li><p><span>指针</span><em><span>从当前位置开始</span></em><span>扫描，寻找</span><em><span>最适合淘汰</span></em><span>的，这一轮中不改变访问位A</span></p></li></ol></li></ul><ol start='2' ><li><p><span>若前一步失败，则第二轮寻找最近未访问但修改了的页面，将第一个遇到的这一类的页面淘汰；这一轮扫描期间，</span><em><span>将所有扫描过的页面访问位都置0（未访问）</span></em></p></li><li><p><span>若还是失败，则回到开始的位置，并重复第一步，第一步失败时再重复第二步，此时一定能找到被替换的页面</span></p></li></ol><ul><li><p><span>实现该算法需要多次比较，开销增大，但可减少磁盘IO的次数</span></p></li></ul></li></ul></li><li><p><span>抖动和工作集</span></p><ul><li><p><span>抖动（颠簸）</span></p><ul><li><p><span>刚刚调出的页面又要调入，一种频繁的页面调动行为</span></p></li><li><p><em><span>直接原因（主要原因）是算法不行</span></em></p></li><li><p><em><span>根本原因是分配给每个进程的物理块太少</span></em></p></li></ul></li><li><p><span>工作集</span></p><ul><li><p><span>某段时间间隔内（或某个窗口内），</span><em><span>进程要访问的页面集合（尽管可能该页面不在内存里）</span></em><span>，注意和驻留集区分</span></p></li><li><p><span>注意和页面引用串区分</span></p></li><li><p><span>若工作集窗口为 n，</span><em><span>则 t 时刻的工作集为 t 时刻的前 n 个页面中的非重复页面</span></em></p></li><li><p><span>给某个进程分配的物理块数（驻留集）必须要大于工作集大小，否则可能出现抖动</span></p></li></ul></li></ul></li><li><p><span>内存映射文件</span></p><ul><li><p><span>磁盘文件映射到内存指定地址，进程操作这一内存就类似于直接操作磁盘文件</span></p></li><li><p><span>进程可直接访问被映射的文件，不必执行文件IO操作，也无需进行缓存管理</span></p></li><li><p><span>特别适合管理大尺寸文件</span></p></li><li><p><span>多进程可并发共享同一内存映射文件，即允许数据共享，该方法本质上就是进程通信的共享内存</span></p></li></ul></li><li><p><span>虚拟存储器性能影响因素</span></p><ul><li><p><em><span>缺页率是影响虚拟存储器性能主要因素</span></em></p><ul><li><p><span>缺页率高即抖动</span></p></li><li><p><span>缺页率也受到页面大小、分配给进程的物理块数、页面置换算法等影响</span></p></li><li><p><span>编写程序的</span><em><span>局部化程度越高，执行时的缺页率越低</span></em></p></li></ul></li><li><p><span>页面较大则缺页率较低，较小则缺页率较高</span></p><ul><li><p><span>页面较大虽然能减少页表长度，但容易产生页内碎片</span></p></li><li><p><span>页面较小减少了页内碎片，但增大了页表长度</span></p></li></ul></li><li><p><span>分配给进程的物理块数越多则缺页率越小</span></p></li><li><p><span>可以建立一个换出已修改页面的链表，等页面数到了一定量才</span><em><span>统一写回</span></em><span>外存，减少IO次数</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='文件管理'><span>文件管理</span></h2><h4 id='概念-3'><span>概念</span></h4><ul><li><p><span>基本概念</span></p><ul><li><p><span>文件 File 是以硬盘为载体存储在计算机上的信息集合</span></p></li><li><p><span>系统以进程为资源分配的基本单位，而 </span><em><span>IO 中，以文件为基本单位</span></em></p></li><li><p><em><span>大多数应用程序的输入都是通过文件来实现的，其输出也保存在文件中</span></em></p></li><li><p><span>文件的结构</span></p><ol start='' ><li><p><span>数据项</span></p></li></ol><ul><li><p><span>是文件系统中最低级的数据组织形式</span></p></li><li><p><span>基本数据项</span></p><ul><li><p><span>用于描述一个对象的某种属性的一个值，是数据中最小的逻辑单位</span></p></li></ul></li><li><p><span>组合数据项：由多个基本数据项组成，例如三围就是三个指标</span></p></li></ul><p>&nbsp;</p></li></ul><ol start='2' ><li><p><span>记录</span></p></li></ol><ul><li><p><span>是一组相关的数据项集合，用于描述一个对象在某一方面的属性，例如表格中的一行</span></p></li></ul><ol start='3' ><li><p><span>文件</span></p></li></ol><ul><li><p><span>由创造者所定义的、具有文件名的一组相关元素的集合</span></p><ul><li><p><span>有结构文件</span></p></li><li><p><span>文件由若干个相似的记录组成</span></p></li></ul></li><li><p><span>无结构文件</span></p><ul><li><p><span>被视为一个字符流，比如一个二进制文件或字符文件</span></p></li></ul></li></ul></li><li><p><span>文件控制块FCB</span></p><ul><li><p><span>文件的属性</span></p><ul><li><p><span>通常包含：文件名、类型、创建者、所有者、位置、大小、保护信息、创建时间等</span></p></li><li><p><span>OS通过FCB来维护文件的属性信息，也就是文件元数据</span></p></li></ul></li><li><p><span>FCB用于存放控制文件需要的各种信息的数据结构，以实现“</span><em><span>按名存取</span></em><span>”</span></p></li><li><p><em><span>FCB的有序集合称为文件目录，一个FCB是一个文件目录项</span></em></p></li><li><p><em><span>文件目录也被视为一个文件，称为目录文件</span></em></p></li><li><p><span>创建新文件时，系统将分配一个FCB并存放在文件目录中</span></p></li><li><p><span>FCB主要包含：基本信息，如文件名、物理位置等；存取控制信息，如文件的存取权限等；使用信息，如创建时间、修改时间等</span></p></li><li><p><em><span>FCB必须连续存放</span></em></p></li><li><p><span>传统方案中文件名在FCB中，因此要按名读取就必须逐次取出FCB，比较麻烦，这也导致了下面索引结点的提出和文件名与文件信息相分离的设计</span></p></li></ul></li><li><p><span>索引结点</span></p><ul><li><p><span>提出原因</span></p><ul><li><p><span>在查找的时候，只需要比较文件名，也就是按名查找，仅当找到一个目录项后，才需要将其取出并读出物理地址</span></p></li><li><p><span>因此可以</span><em><span>将文件名和目录项的其他部分分开，仅将文件名部分调入内存</span></em></p></li><li><p><span>如UNIX系统，使</span><em><span>文件描述信息（文件名以外的信息）单独形成一个索引结点</span></em><span>的数据结构，也称为 i 结点，其文件目录结构是</span><em><span>文件名+索引结点编号（即指向 i 结点的指针）</span></em></p></li></ul></li><li><p><span>将FCB中文件名和文件信息分割开来</span></p></li><li><p><span>有了索引结点后，FCB实际上只有文件名和索引节点物理地址两部分了</span></p></li><li><p><span>磁盘索引结点</span></p><ul><li><p><span>指存放在磁盘上的索引结点</span></p></li><li><p><span>每个文件有唯一的磁盘索引结点</span></p></li><li><p><span>主要包含：文件主标识符、文件类型、存取权限、物理地址、文件长度（单位为B）等</span></p></li></ul></li><li><p><span>内存索引结点</span></p><ul><li><p><span>指存放在内存中的索引结点</span></p></li><li><p><em><span>当文件被打开时，要将磁盘索引结点复制到内存的索引结点中</span></em><span>，便于以后使用</span></p></li><li><p><span>新增了：</span><em><span>索引结点编号（用于标识内存索引结点）</span></em><span>、状态、访问计数、链接指针等</span></p></li></ul></li></ul></li><li><p><span>文件操作</span></p><ul><li><p><span>创建</span></p><ol start='' ><li><p><span>为新文件分配必要的外存空间</span></p></li><li><p><span>在目录中创建一个目录项</span></p></li></ol></li></ul></li><li><p><span>写和读</span></p><ul><li><p><em><span>两者都是 IO 操作，故都要执行系统调用</span></em></p><ul><li><p><span>系统必须分别维护读指针和写指针，以便实现继续读和继续写（类似于断点续传）</span></p></li><li><p><span>每个进程共享同一个文件时其读和写指针可能不同，故共享进程的</span><em><span>打开文件表的这一项不一定相同</span></em></p></li></ul></li><li><p><span>文件定位</span></p><ul><li><p><span>不涉及读写文件，只是重新找文件然后</span><em><span>更改目录项的索引值（指针）</span></em></p></li></ul></li></ul></li><li><p><span>删除</span></p><ul><li><p><span>先检索该文件的目录项，找到该文件并释放其所占的空间，</span><em><span>然后删掉目录项</span></em></p></li><li><p><span>截断文件</span></p><ul><li><p><span>允许文件所有属性不变，删除文件内容，将长度置为0并释放空间</span></p></li></ul></li></ul></li><li><p><span>打开与关闭</span></p><ul><li><p><span>文件使用之前必须通过系统调用 open 被显式地打开，防止多次重复检索目录</span></p><ul><li><p><span>操作系统维护一个打开文件表，文件名</span><em><span>可以不是</span></em><span>打开文件表的一部分</span></p><ul><li><p><span>一旦完成对 FCB 在磁盘上的定位，系统就不再使用文件名，只要文件没关闭，就可以通过打开文件表来找到该文件。对于访问打开文件表的索引，UNIX 称为文件描述符，而 Windows 称为文件句柄</span></p></li></ul></li><li><p><em><span>open 参数包含文件名</span></em><span>，返回文件标识符，在 read 之前必须打开文件，故 </span><em><span>read 不用文件名</span></em></p></li><li><p><span>打开的含义：使用 open 系统调用，根据文件名搜索目录，</span><em><span>将文件的属性信息（FCB）从外存复制到内存打开文件表的一个表目中，并将该表目的编号（索引）返回给用户</span></em></p><ul><li><p><span>只有实际进行 IO 操作，才会将文件从外存复制到内存中，打开只是获取文件信息（</span><em><span>FCB中也包含了文件外存物理地址</span></em><span>）</span></p></li></ul></li></ul></li><li><p><span>当用户再次发出文件操作命令时，可通过索引在打开文件表中查找到文件信息，从而节省再次搜索目录的开销</span></p><ul><li><p><span>当文件不再使用时，使用 close 系统调用关闭它，将这一条目从打开文件表中删除，并将文件写回外存</span></p></li><li><p><span>不同进程可以打开文件的操作系统中，常采用两级打开文件表</span></p><ul><li><p><span>系统表：存放 FCB 的副本及其他信息</span></p></li><li><p><em><span>进程表（每个进程一个）</span></em></p><ul><li><p><span>根据它所打开的文件，包含指向系统表中适当条目的指针</span></p></li></ul></li><li><p><span>一旦有进程打开了一个文件，则系统表中增加一个条目，进程表中增加指向该条目的指针</span></p><ul><li><p><span>系统打开文件表为每个文件打开表关联一个打开计数器，以记录多少进程打开了这个文件，open使count+1，close使count-1。</span><em><span>当count==0时，表示该文件不再使用，可在系统打开表中删除该条目，并将内存中的文件写回外存</span></em></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>文件保护</span></p><ul><li><p><span>即解决对文件的读写、执行的许可问题</span></p></li><li><p><span>实现</span></p><ul><li><p><span>口令保护、加密保护</span></p><ul><li><p><span>为了防止用户文件被他人存取或窃取</span></p></li><li><p><span>除此之外，还常采用备份法保护文件</span></p></li></ul></li><li><p><span>访问控制</span></p><ul><li><p><span>用于控制用户对文件的访问方式</span></p></li><li><p><span>文件的访问由用户访问权限和文件属性（含文件访问控制信息）共同决定</span></p></li><li><p><em><span>控制矩阵常用于多用户的权限控制</span></em></p></li><li><p><span>方法</span></p><ul><li><p><span>根据用户身份</span></p><ul><li><p><span>为每个文件和目录新增一个访问控制列表ACL，以规定每个用户名及其所允许访问的类型，但该方法比较复杂</span></p></li><li><p><span>精简的访问列表的用户类型</span></p><ul><li><p><span>拥有者：创建文件的用户</span></p></li><li><p><span>组：一组需要共享文件且具有类似访问的用户</span></p></li><li><p><span>其它：系统中的其它用户</span></p></li></ul></li><li><p><em><span>文件权限是针对文件本身而言的</span></em><span>，文件有一个</span><span class='math-in-toc'>$m*n$</span><span>的“权限矩阵”，1表示某用户具有该权限，0表示没有，m和n分别是用户种类和权限种类</span></p></li></ul></li><li><p><span>口令</span></p><ul><li><p><span>类似于PIN。文件在建立时还要创建一个口令，用户访问时必须提供该口令</span></p></li><li><p><span>实现的开销不大，但不够安全</span></p></li></ul></li><li><p><span>密码</span></p><ul><li><p><span>类似于有密码的ZIP，密码就是密钥，访问时必须提供密钥以对文件进行解密</span></p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p><span>逻辑结构</span></p><ul><li><p><em><span>逻辑结构是从用户观点看到的文件组织形式；物理结构（存储结构）是从实际观点出发看到的文件组织形式</span></em></p></li><li><p><em><span>逻辑结构与存储介质无关</span></em></p></li><li><p><span>无结构</span></p><ul><li><p><span>即流式文件，将数据按顺序组织并积累，以</span><em><span>字节</span></em><span>为单位</span></p></li><li><p><span>由于没有结构，对（其内部的）记录的访问</span><em><span>只能通过穷举搜索</span></em><span>的方式</span></p></li><li><p><span>管理简单，操作方便</span></p></li></ul></li><li><p><span>有结构</span></p><ol start='' ><li><p><span>顺序文件</span></p></li></ol><ul><li><p><span>文件的记录一个接一个排列，通常记录是</span><em><span>定长</span></em><span>的，可采用</span><em><span>顺序存储或链表</span></em><span>形式</span></p></li><li><p><span>类型</span></p><ul><li><p><span>串结构（无序）</span></p><ul><li><p><span>记录之间的顺序和关键字无关，对其</span><em><span>检索必须从头开始顺序查找</span></em></p></li></ul></li><li><p><span>顺序结构</span></p><ul><li><p><span>关键字有序，可采用折半查找</span></p></li></ul></li></ul></li><li><p><span>对记录进行</span><em><span>批量操作（读或写一大批记录），顺序文件是所有逻辑文件中效率最高的</span></em></p></li><li><p><span>经常需要</span><em><span>查找</span></em><span>、修改等对</span><em><span>单个单元的操作时，顺序存储性能较差</span></em></p></li></ul><ol start='2' ><li><p><span>索引文件</span></p></li></ol><ul><li><p><span>建立一张索引表（</span><em><span>一个文件一张索引表</span></em><span>），</span><em><span>记录每项的长度和指向该项首地址（逻辑地址）的指针，适用于变长记录</span></em></p></li><li><p><span>索引表中每条记录和索引项是</span><em><span>一一对应</span></em><span>的</span></p></li><li><p><em><span>索引表按关键字排序，它本身也是一个定长记录的顺序文件</span></em></p></li></ul><ol start='3' ><li><p><span>索引顺序文件</span></p></li></ol><ul><li><p><span>索引文件和顺序文件的结合，</span><em><span>将所有文件按照一定次序划分为组，用索引找到组，再在组内顺序查找</span></em></p></li><li><p><em><span>组间必须有序，但组内可以无序</span></em></p></li><li><p><em><span>每个组在索引表中都有一个索引项，指向组的第一条记录</span></em></p></li><li><p><span>索引文件是每个记录都要配置一个索引项，而索引顺序文件是每个组一个索引项</span></p></li><li><p><span>平均下来，索引顺序文件最少查找</span><span class='math-in-toc'>$\sqrt{n}+1$</span><span>次即可找到记录，n 为总的记录数目，此时划分标准为：</span><span class='math-in-toc'>$\sqrt{n}$</span><span>组，每组</span><span class='math-in-toc'>$\sqrt{n}$</span><span>条记录</span></p></li></ul><ol start='4' ><li><p><span>散列文件</span></p></li></ol><ul><li><p><em><span>没有顺序，直接计算得到物理地址</span></em></p></li><li><p><span>也称直接文件，通过给定的键值或通过散列函数转化得到的值，直接决定记录的物理地址</span></p></li><li><p><span>有很高的存取速度，但会引起冲突，即不同关键字的散列函数值相同</span></p></li></ul><p><span>可以发现，有结构文件的组织逻辑，是便于查找的（顺序查找、索引查找、索引顺序查找、哈希查找）</span></p></li></ul></li><li><p><span>物理结构</span></p><p><span>注意：不同存储介质，通常采用不同的物理结构</span></p><ul><li><p><span>连续分配</span></p><ul><li><p><span>每个文件在磁盘上占有连续的块，即</span><em><span>逻辑上相邻的块在物理上也是相邻的</span></em></p></li><li><p><span>文件的目录项中的文件物理地址字段，应当</span><em><span>包含第一块的地址和总占用的块的长度</span></em></p></li><li><p><span>支持直接访问（也就是随机访问）和顺序访问</span></p></li><li><p><span>实现简单、存取速度快。但文件长度不宜动态增加（若后续的块已被分配，就需要大量移动元素）；不适合插入和删除元素；反复增删文件后有</span><em><span>外部碎片</span></em></p></li></ul></li><li><p><span>链接分配</span></p><p><span>是一种离散分配的方式，消除了外部碎片，提高了磁盘的利用率。无需事先知道文件大小，对文件的删除和修改也很方便</span></p><ul><li><p><span>隐式链接</span></p><ul><li><p><em><span>目录项只有第一个和最后一个块的指针，除最后一块外每块有一指针指向下一块，块内指针对用户透明</span></em></p></li><li><p><span>只能</span><em><span>顺序访问</span></em><span>，且稳定性不高</span></p></li><li><p><span>可将几个盘块组成簇，按簇来分配而不是按块，可成倍减少查找时间，但有内部碎片</span></p><ul><li><p><em><span>一个簇最多只能存放一个文件</span></em><span>，就算没有占满也无法存放第二个文件，计算时需注意</span></p></li></ul></li></ul></li><li><p><span>显式链接</span></p><ul><li><p><span>将每个物理块末尾的指针提取出来，显式地放在一张表中，即文件分配表FAT，</span><em><span>该表在整个磁盘中仅一张</span></em></p></li><li><p><span>目录项物理地址字段记录文件的第一个盘块号，后续的盘块通过查FAT找到</span></p></li><li><p><em><span>FAT表的每条记录为：盘块号+下一块的盘块号（伪指针），用-1表示最后一块，-2表示是空闲盘块</span></em></p></li><li><p><em><span>盘块号只要用相对的逻辑位置即可，因为每个盘块大小固定</span></em></p></li><li><p><span>FAT在系统启动时就会被读入内存，查找过程中在内存中进行，显著减少了IO次数</span></p></li><li><p><span>支持</span><em><span>随机访问</span></em><span>，但FAT占用空间较大</span></p></li></ul></li></ul></li><li><p><span>索引分配</span></p><ul><li><p><em><span>用一个专门的块存放某一文件所有盘块号，目录文件中只指明这个块的盘块号</span></em></p></li><li><p><em><span>索引块的第 i 个条目指向文件的第 i 块</span></em></p></li><li><p><span>文件所有的块通过索引块直接指示，</span><em><span>索引块里的条目次序和文件块的顺序是一致的</span></em></p></li><li><p><span>索引分配</span><em><span>支持顺序访问和随机访问</span></em><span>，且没有外部碎片问题，但由于索引块的分配，增加了系统存储的开销</span></p></li><li><p><em><span>索引块的大小直接决定了最大支持的文件大小</span></em><span>，因此需要解决索引块大小问题</span></p></li><li><p><span>索引块对不同大小文件的支持</span></p><ul><li><p><span>链接方案</span></p><ul><li><p><span>一个索引块通常为一个磁盘块，因此本身能直接读写。为了支持大文件，可以将多个索引块链接起来（因为一个大文件所占的块数太多导致一个块存不下所有块的索引）</span></p></li></ul></li><li><p><span>多层索引</span></p><ul><li><p><span>类似于多级页表，第一级的索引块指向第二级的索引块，第二级的索引块再指向文件块</span></p></li></ul></li><li><p><span>混合索引分配</span></p><ul><li><p><span>可以全面照顾到大中小文件</span></p></li><li><p><span>对于</span><em><span>小文件，最好可以将它们每个盘块的地址直接放到 FCB，这样可以直接寻址</span></em></p></li><li><p><span>对于</span><em><span>中型文件，可以采用单级索引的方式，即 FCB 中放的指针是指向索引表的指针</span></em><span>，从索引表可获得文件块地址</span></p></li><li><p><span>对于大型文件，可采用二级或多级索引分配</span></p></li></ul></li></ul></li><li><p><span>UNIX的索引分配（混合索引分配）</span></p><ul><li><p><span>索引结点中既有直接块，也有多级间址块。</span><em><span>FCB地址项指向的是索引结点，索引结点中包含各块的物理地址</span></em></p></li><li><p><span>在索引结点（inode）中，共有</span><em><span>13个地址项</span></em><span>，即 i.addr(0)~i.addr(12)</span></p><ul><li><p><span>直接地址占据前10个地址项，每个地址指向一个文件块</span></p><ul><li><p><span>一个块 4KB，文件最大 40KB</span></p></li></ul></li><li><p><span>一次间接地址</span></p><ul><li><p><span>第11个地址项，也就是i.addr(10)是一次间址，指向一个索引块</span></p></li><li><p><span>索引块中每一项一般是 4B（32位），一级索引能存 </span><span class='math-in-toc'>$2^{10}$</span><span> 个地址</span></p></li><li><p><span>文件最大</span><span class='math-in-toc'>$ 40KB+ 2^{10} * 4KB=40KB+4MB$</span></p></li></ul></li><li><p><span>二次间接地址</span></p><ul><li><p><span>第12个地址项</span></p></li><li><p><span>一般允许文件达到4GB</span></p></li></ul></li><li><p><span>三次间接地址</span></p><ul><li><p><span>第13个地址项</span></p></li><li><p><span>允许文件达到4TB</span></p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id='目录'><span>目录</span></h4><p><span>FCB的有序集合称为目录，</span><em><span>一个FCB就是一个文件目录项</span></em></p><p><span>文件目录也是一个文件，称为目录文件</span></p><p><span>若目录文件已在内存中，则读取某个文件仅需读取该文件的索引结点以及文件所占用的块</span></p><ul><li><p><span>目录结构</span></p><ul><li><p><span>单级目录结构</span></p><ul><li><p><em><span>整个文件系统建立一张目录表，一个文件占一个目录项</span></em></p></li><li><p><span>实现了按名存取，但查找速度慢、文件</span><em><span>不允许重名</span></em><span>，不便于文件共享等</span></p></li></ul></li><li><p><span>两级目录结构</span></p><ul><li><p><span>分为</span><em><span>主目录文件和多个用户的文件目录</span></em><span>，主目录文件每个项都指向用户的目录文件，而用户的目录文件才记录该用户文件的FCB</span></p></li><li><p><span>提高了检索速度，解决了多用户间文件的重名问题，也在一定程度上保证了文件的安全，但缺乏灵活性，不能对文件分类（例如使用文件夹来存储特定工程的项目文件）</span></p></li><li><p><span>多级目录主要是为了</span><em><span>解决命名冲突</span></em></p></li></ul></li><li><p><span>树形目录结构</span></p><ul><li><p><span>能提升检索速度和性能</span></p></li><li><p><span>根目录、当前目录，绝对路径和相对路径</span></p></li><li><p><span>每个用户登录后都有各自的“当前目录”，默认路径是以当前目录来的，可使用系统调用cd来改变目录</span></p></li><li><p><span>方便对文件进行分类，层次结构清晰，也能进行文件管理和保护；但查找一个文件需要按路径名逐级查找中间结点，</span><em><span>增加了磁盘访问次数</span></em></p></li></ul></li><li><p><span>无环图目录</span></p><ul><li><p><span>树形目录基础上加了一些有向边，使整个目录成为有向无环图，便于共享文件</span></p></li><li><p><span>为每一个共享结点（文件）设置一个计数器count，每当增加一个共享链，就+1，每当一个用户提出删除该文件时就-1，当count==0时才删除这个文件，否则仅删除共享链</span></p></li><li><p><span>共享文件只存在一个文件，没有副本，任何改变都会让其它用户所见</span></p></li><li><p><span>无环图目录方便了文件的共享，但让系统的管理变得很复杂</span></p></li></ul></li></ul></li><li><p><span>操作</span></p><ul><li><p><span>搜索、创建和删除文件、创建和删除目录、移动和修改目录</span></p></li><li><p><span>目录检索（查询）</span></p><ul><li><p><span>顺序检索法：常用，检索后得到的是文件的逻辑地址，需要转化才是物理地址</span></p></li><li><p><span>Hash 法</span></p></li></ul></li></ul></li><li><p><span>共享</span></p><p><span>一般共享文件只有一个副本，若副本太多则对存储空间要求太大</span></p><ul><li><p><span>基于索引节点</span></p><ul><li><p><span>也称硬链接，</span><em><span>在索引结点中设置链接计数count</span></em><span>，用于记录链接到本索引结点上的用户个数</span></p></li><li><p><span>共享文件的基本信息不再放在目录项中，而是放在索引结点中，文件目录只设置文件名及指向索引结点的指针，共享用户的这一目录项指向同一个索引结点</span></p></li><li><p><span>被共享文件只有</span><em><span>计数为0才完全删掉</span></em><span>，否则只让count-1</span></p></li><li><p><span>硬链接的查找速度比软链接快</span></p></li></ul></li><li><p><span>基于符号链</span></p><ul><li><p><span>也称软链接，由系统创建一个LINK类型的文件，取名和被共享的文件名字相同，并写入被共享用户的目录中</span></p></li><li><p><span>LINK文件中仅包含被共享文件的路径。操作系统看到是LINK文件，就拿着文件中的地址去找真正的共享文件</span></p></li><li><p><span>只有文件拥有者才有指向文件索引结点的指针，而共享该文件的只有该文件的路径名，没有指向索引结点的指针，因此文件拥有者可直接删除文件。而当LINK访问失败，就将该符号链删除即可</span></p></li><li><p><span>其他用户读共享文件时，需要根据文件路径名逐级查找目录，最终找到该文件的索引结点，而文件拥有者能通过指针直接访问</span></p></li><li><p><span>被共享者访问共享文件时可能需要多次读盘，增大了开销</span></p></li><li><p><span>link文件逻辑上等价于被共享文件，快捷方式就是一个LINK文件</span></p></li></ul></li></ul><p><span>硬链接和软链接都是静态共享，而动态共享是两个进程同时对同一个文件进行操作</span></p><p><em><span>设置软链接时 count 不发生改变</span></em><span>，软链接本身引用值恒为1；硬链接个数和共享文件引用值始终相等</span></p></li></ul><h4 id='文件系统'><span>文件系统</span></h4><p><span>文件系统的目的是提供高效和便捷的磁盘访问</span></p><ul><li><p><span>文件系统结构</span></p><ul><li><p><span>IO控制</span></p><ul><li><p><span>包括设备驱动程序和中断处理程序，在内存和磁盘之间传输信息，是文件系统最底层的部分</span></p></li><li><p><span>设备驱动程序将输入的命令翻译成底层硬件的特定指令，硬件控制器利用这些指令使IO设备与系统交互</span></p></li></ul></li><li><p><span>基本文件系统</span></p><ul><li><p><span>向对应设备驱动程序发送通用命令，以读取和写入磁盘的物理块</span></p></li><li><p><span>也管理内存缓冲区，保存各种文件系统、目录和数据块的缓存</span></p></li></ul></li><li><p><span>文件组织模块</span></p><ul><li><p><span>主要功能是组织文件及其逻辑块和物理块</span></p></li><li><p><span>可以将逻辑块地址转换成物理块地址</span></p></li><li><p><span>还包含空闲空间管理器，以跟踪未分配的块</span></p></li></ul></li><li><p><span>逻辑文件系统</span></p><ul><li><p><span>用于管理元数据信息，元数据包含文件系统所有结构，而不包含实际数据（实际的文件）</span></p></li><li><p><span>用于管理目录结构，以便根据给定文件名称为文件组织模块提供所需要的信息</span></p></li><li><p><span>负责文件保护，并通过文件控制块来维护文件结构，是文件系统顶层部分</span></p></li></ul></li></ul></li><li><p><span>布局</span></p><ul><li><p><span>文件系统在磁盘中的结构</span></p><ul><li><p><span>磁盘的结构：最开始是</span><em><span>MBR</span></em><span>，然后跟着的是</span><em><span>分区表</span></em><span>，后面是</span><em><span>一个或多个磁盘分区</span></em><span>，每个磁盘分区中都有一个文件系统</span></p></li><li><p><span>MBR主引导记录</span></p><ul><li><p><span>位于磁盘0号扇区，用来引导计算机</span></p></li></ul></li></ul></li><li><p><span>分区表</span></p><ul><li><p><span>位于MBR之后，和磁盘分区是同一层级上的</span></p><ul><li><p><span>该表给出每个分区的起始和结束地址</span></p></li></ul></li><li><p><span>文件系统布局</span></p><ul><li><p><span>引导块</span></p></li><li><p><span>MBR执行引导块中的程序，该程序负责启动该分区中的操作系统</span></p><ul><li><p><span>为统一起见，</span><em><span>每个分区都从一个引导块开始</span></em><span>，即使这个分区没有操作系统</span></p></li></ul></li><li><p><span>Windows称引导块为分区引导扇区</span></p><ul><li><p><span>引导块是每种文件系统都有的，后面的布局可能随着文件系统的变化而变化</span></p></li></ul></li><li><p><span>超级块</span></p></li><li><p><span>包含文件系统所有关键信息</span></p><ul><li><p><span>在计算机启动时或该文件系统首次使用时，超级块会被读入内存</span></p></li></ul></li><li><p><span>包含：分区中块的数量、块的大小、空闲块的数量和指针、空闲FCB数量和FCB指针等</span></p></li><li><p><span>空闲空间管理</span></p></li><li><p><span>使用位示图或指针链接的形式所给出的空闲块的信息</span></p></li></ul></li><li><p><span>一组 inode</span></p><ul><li><p><span>也就是索引结点，一个文件对应一个inode，inode说明了文件的各种属性</span></p></li></ul></li><li><p><span>根目录</span></p><ul><li><p><span>存放文件系统目录树的底部</span></p></li></ul></li><li><p><span>目录文件和所有文件</span></p></li></ul></li><li><p><span>文件系统在内存中的结构</span></p><ul><li><p><span>内存中的信息用于管理文件系统并通过</span><em><span>缓存</span></em><span>来提高性能，这些信息在安装（或开机）文件系统时被加载，在文件操作期间被更新，在卸载时被丢弃</span></p></li><li><p><span>内存中的信息</span></p><ul><li><p><span>安装表</span></p><ul><li><p><span>包含</span><em><span>每个已安装文件系统分区</span></em><span>的有关信息</span></p></li></ul></li><li><p><span>最近访问目录的信息</span></p><ul><li><p><span>位于内存的目录结构的缓存中</span></p></li><li><p><span>可以包含一个指向安装表的指针</span></p></li></ul></li><li><p><span>整个系统的打开文件表</span></p><ul><li><p><span>包含每个打开文件的 FCB 副本和其他信息</span></p></li></ul></li><li><p><span>每个进程的打开文件表</span></p><ul><li><p><span>包含一个指向整个系统打开文件表中适当条目的指针，以及其他信息</span></p></li></ul></li></ul></li><li><p><span>文件的创建</span></p><ul><li><p><span>应用程序创建文件需要调用逻辑文件系统</span></p></li><li><p><span>逻辑文件系统为文件分配一个 FCB，然后系统将相应目录读入内存，使用新文件名和FCB进行更新，并将其写回硬盘</span></p></li></ul></li><li><p><span>文件的打开</span></p><ul><li><p><span>总体来说，是系统调用 open 将文件名传递给逻辑文件系统</span></p></li><li><p><span>具体来说，open首先搜索系统的整个系统的打开文件表，以确定该文件是否被其他进程打开；如果已打开，则只需在本进程的打开文件表中新增指向系统打开文件表的指定条目即可；如果文件未打开，则</span><em><span>根据给定的文件名来搜索目录结构</span></em><span>，找到文件后，</span><em><span>将其FCB复制到系统打开文件表中</span></em><span>，然后在本进程的打开文件表中新建条目</span></p></li><li><p><em><span>进程通过指针找到被打开的文件，而内核使用文件描述符</span></em><span>，两者注意区分</span></p></li></ul></li><li><p><span>文件的关闭</span></p><ul><li><p><span>当一个进程关闭文件，则删除本进程打开文件表中指定条目，系统打开表中该条目的计数值也会-1，当所有用户都关闭该文件时，系统打开文件表也会删除这一条目</span></p></li></ul></li></ul></li></ul></li><li><p><span>外存空闲空间管理</span></p><ul><li><p><span>一个硬盘可以划分为多个分区，每个分区都有单独的文件系统；包含文件系统的分区通常称为卷（volume），也可以多个物理磁盘组成一个分区。卷中分为文件区和目录区</span></p></li><li><p><span>现代操作系统中有很多不同的文件管理模块，通过它们可以访问不同格式的卷中的文件</span></p></li><li><p><span>卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块</span></p></li><li><p><span>文件存储设备划分为许多</span><em><span>大小相等的物理块</span></em><span>，以块为信息交换单位</span></p></li><li><p><span>文件存储设备（外存）管理主要是对空闲块的组织和管理，包含块的组织、分配、回收等</span></p></li><li><p><span>组织方法</span></p><ul><li><p><span>空闲表法</span></p><ul><li><p><span>属于</span><em><span>连续分配</span></em><span>方式，</span><em><span>为每个文件分配一块连续的存储空间</span></em></p></li><li><p><span>系统将外存中所有空闲区（即未被使用的块的聚集区）建立一张空闲表，每个空闲区对应一个空闲表项，包含表项序号、该空闲区的</span><em><span>第一个块号</span></em><span>、该空闲区的</span><em><span>空闲盘块数</span></em><span>等，再将所有空闲区按块号递增的次序排列</span></p></li><li><p><span>空闲块的分配跟</span><em><span>内存的动态分配</span></em><span>类似，同样采用首次适应、最佳适应等算法，也会产生</span><em><span>外部碎片</span></em></p></li><li><p><span>释放时也采取内存回收的方法，即考虑回收区是否和空闲表项中前后相邻，相邻则合并成一个大的空闲区</span></p></li></ul></li><li><p><span>空闲链表法</span></p><p><span>是一种</span><em><span>离散分配</span></em><span>的方法</span></p><ul><li><p><span>空闲盘块链</span></p><ul><li><p><em><span>将磁盘上所有空闲空间以盘块为单位拉成一条链</span></em></p></li><li><p><span>当分配空间时，系统从链首开始依次摘下适量的空闲盘块分配给用户</span></p></li><li><p><span>当回收空间时，将回收的盘块依次插入空闲盘块链的尾部</span></p></li><li><p><span>分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时，可能要重复多次，效率低；且</span><em><span>以盘块为单位，空闲盘块链会很长</span></em></p></li></ul></li><li><p><span>空闲盘区链</span></p><ul><li><p><em><span>将磁盘上所有空闲盘区（包含多个空闲的盘块）拉成一条链</span></em></p></li><li><p><span>和空闲表法差不多，只是一个只能连续分配一个可以离散分配</span></p></li><li><p><span>链中的每个盘区除了有指向下一个盘区的指针，还有能指明本盘区的空闲块数目</span></p></li><li><p><span>分配盘区的方法和内存动态分配类似，通常采用首次适应算法</span></p></li><li><p><span>在回收盘区时，通常也要进行盘区合并</span></p></li><li><p><span>分配和回收的过程较复杂，但通常效率较高，且空闲盘区链较短</span></p></li></ul></li></ul></li><li><p><span>位示图法</span></p><p><span>利用矩阵中的0、1来表示每个块的分配情况，</span><em><span>0表示未分配，1表示已分配</span></em><span>，这样一个</span><span class='math-in-toc'>$m * n$</span><span>的矩阵就可以表示</span><span class='math-in-toc'>$m * n$</span><span>个盘块的使用情况</span></p><ul><li><p><span>盘块的分配</span></p><ol start='' ><li><p><span>顺序扫描位示图，</span><em><span>从左到右，从上到下</span></em><span>，从中找出一个或一组值为0的二进制位</span></p></li><li><p><span>将找到的二进制位转换成与之对应的盘块号</span></p></li><li><p><span>修改位示图，令被找到的这些二进制位变为1</span></p></li></ol></li></ul></li><li><p><span>盘块的回收</span></p><ol start='' ><li><p><span>将回收盘块转化为位示图中的行号和列号</span></p></li><li><p><span>修改位示图，将这些二进制位改为 0</span></p></li></ol><ul><li><p><span>在计算过程中注意行和列是从 0 还是 1 开始的</span></p></li></ul></li><li><p><span>成组链接法</span></p><p><span>空闲表和空闲链表都不适合大型文件系统，因为会使空闲表或空闲链表太大，而成组链接法结合了空闲表和空闲链表两种方法，被 UNIX 系统采用</span></p><p><img src="assets/96cdb4180f32d61125dad4290c8a56cf.png" alt="img" style="zoom:50%;" /></p><ul><li><p><span>成组链块</span></p><ul><li><p><span>是用于</span><em><span>存放一组空闲盘块的块号的盘块</span></em><span>，设每个成组链块都能存放 n 个</span><em><span>盘块号</span></em><span>（指针）</span></p></li><li><p><em><span>每组空闲盘块的最后一个盘块，将作为成组链块</span></em><span>，记录下一个空闲块组的块号。成组链块第一个格为本链块中存储的空闲盘块数，第二格存储下一个成组链块地址，分配时指针从下往上移动</span></p></li></ul></li><li><p><span>实现</span></p><ul><li><p><span>先拿一个空盘块作为第一个成组链块，把顺序的 n 个空闲盘块号保存在它之中，并将这n个空闲盘块的最后一个空闲盘块作为成组链块，用于保存另一组空闲盘块号。如此继续，直到所有空闲盘块均被链接</span></p></li><li><p><span>系统只需要保存指向第一个成组链块的指针</span></p></li><li><p><span>注意这里不是按空闲区来分配的，而是按块，每隔 n-1 个空闲盘块，那下一个块就作为成组链块，所以</span><em><span>每个成组链块记录 n-1 个空闲的盘块和下一个成组链块的块号</span></em></p></li></ul></li><li><p><span>盘块的分配</span></p><ul><li><p><span>根据第一个成组链块的指针，将所记录的空闲盘块号分配给用户，指针从下往上移动</span></p></li><li><p><span>当盘块号指针指向的是下一个成组链块时，表示这个空闲区已被占满，则读入下一个成组链块，本成组链块被分配，然后按照其记录的下一组空闲盘块继续分配</span></p></li></ul></li><li><p><span>盘块的回收</span></p><ul><li><p><span>回收与分配都在第一个成组链块</span></p></li><li><p><span>成组链块的指针下移一格，再计入回收盘块号</span></p></li><li><p><span>当成组的链接数达到 n 时，表示已满，便将现有记录 n 个空闲盘块的成组链块号记录进新回收的盘块作为新的成组链块</span></p></li></ul></li><li><p><span>超级块</span></p><ul><li><p><span>存放空闲空间的位向量表或第一个成组链块的位置，以及卷中的目录区、文件区划分信息等</span></p></li><li><p><span>一般放在卷头位置</span></p></li><li><p><span>在对卷中的文件进行操作前，</span><em><span>超级块需要预先读入主存</span></em><span>，并经常保持主存超级块和磁盘卷中超级块的一致性（比如成组链块改了）</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>虚拟文件系统</span></p><ul><li><p><span>虚拟文件系统 VFS 为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节</span></p></li><li><p><span>在内核空间，用户程序可使用 VFS 提供的统一调用函数（如open）来操作不同文件系统（如ext3、Fat32等）的文件，而无需考虑具体的文件系统和实际的存储介质</span></p></li><li><p><span>VFS 在内核空间，往上是用户空间的 C 标准库，再往上是各类应用程序；而 VFS 往下是各种具体的文件系统</span></p></li><li><p><span>采用面向对象思想，抽象出一个通用的文件系统模型，定义了通用文件都支持的接口</span></p></li><li><p><span>一个Linux例子</span></p><ul><li><p><span>调用 write()，在 VFS 中通过 sys_write 函数处理，该函数找到具体的文件系统，将控制权交给该文件系统，由该文件系统与物理介质交互（读写）</span></p></li><li><p><span>Linux 将目录当作文件来处理，文件操作能同时用于目录和文件</span></p></li></ul></li><li><p><span>VFS对象</span></p><p><span>每个VFS对象都需要存放在适当的数据结构中</span></p><ul><li><p><span>超级块对象</span></p><ul><li><p><span>对应磁盘上特定扇区的文件系统超级块</span></p></li><li><p><span>表示一个已安装（也称挂载）的特定文件系统，同时也存放该文件系统的元信息，如基本属性、文件系统类型、文件系统的块大小、操作方法（函数）指针等</span></p></li><li><p><span>操作方法指针指向该超级块的操作方法表，包含一系列可在超级块对象上调用的操作函数，主要有分配、销毁、读写 inode，文件同步等</span></p></li></ul></li><li><p><span>索引结点对象</span></p><ul><li><p><span>索引结点 inode 存放文件的基本属性，</span><em><span>一个文件一个inode</span></em></p></li><li><p><em><span>只有当文件被访问时，才在内存中创建索引结点对象</span></em><span>，它是磁盘中索引结点的一部分，并且有脏位（状态字）</span></p></li><li><p><span>索引结点对象还提供许多操作接口，如创建新的索引结点、创建硬链接、创建新目录等</span></p></li></ul></li><li><p><span>目录项对象</span></p><ul><li><p><span>目录项对象是一个路径的组成部分，要么是目录名要么是文件名</span></p></li><li><p><span>目录项对象在磁盘中</span><em><span>没有对应的数据结构</span></em><span>，而前两者都有实体数据结构</span></p></li></ul></li><li><p><span>文件对象</span></p><ul><li><p><span>表示一个与进程相关的已打开的文件</span></p></li><li><p><span>多个进程可能打开同一个文件，所以</span><em><span>同一个文件在内存中可能有多个对应的文件对象，但对应的索引结点和目录项是唯一的</span></em></p></li><li><p><span>包含与该文件相关联的目录项对象，该文件的文件系统、文件指针等，还包含在该文件对象上调用的一系列操作函数</span></p></li></ul></li></ul></li><li><p><span>多个进程打开同一个文件，则</span><em><span>每个进程都有一个文件对象</span></em><span>，目录项对象则和共享方式有关（</span><em><span>一个硬链接一个目录项</span></em><span>），而索引结点对象只有一个</span></p></li><li><p><span>VFS能提高系统性能</span></p><ul><li><p><span>最近最常使用的目录项对象被放在目录项的高速缓存的磁盘缓存中，以加速从文件路径名到最后一个路径分量的索引结点的转化过程</span></p></li></ul></li><li><p><span>VFS并不是一种实际的文件系统，</span><em><span>只存在于内存中</span></em><span>，在系统启动时建立，在系统关闭时消亡</span></p></li></ul></li><li><p><span>分区和安装</span></p><ul><li><p><span>一个磁盘可划分多个分区，每个分区可有单独的文件系统，每个分区还可以有单独的操作系统</span></p></li><li><p><span>当分区中没有文件系统，则可以使用原始磁盘</span></p></li><li><p><span>OS的引导</span></p><ul><li><p><span>系统启动，首先载入MBR，由MBR识别活动分区，并加载该分区中的引导程序</span></p></li><li><p><em><span>引导程序位于引导块中</span></em><span>，</span><em><span>引导块是每个分区的第一个部分</span></em></p></li><li><p><span>引导时系统并未载入文件系统代码，不能解释文件系统格式</span></p></li><li><p><span>执行引导程序后，由它启动一个操作系统</span></p></li></ul></li><li><p><span>文件系统在进程使用前必须安装，也称挂载</span></p></li><li><p><span>Windows维护一个扩展的两级目录结构，路径为：</span><code>驱动器号:\path\to\file</code></p></li><li><p><span>UNIX使用系统的根文件系统，由内核在引导阶段直接安装。UNIX必须给根目录分配空间，才能操作目录树</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='io管理'><span>IO管理</span></h2><h4 id='io设备'><span>I/O设备</span></h4><ul><li><p><span>分类</span></p><ul><li><p><span>块设备</span></p><ul><li><p><span>信息交换</span><em><span>以数据块为单位</span></em><span>，是有结构设备，如磁盘</span></p></li><li><p><em><span>传输速率较高，可寻址</span></em></p></li></ul></li><li><p><span>字符设备</span></p><ul><li><p><span>信息交换</span><em><span>以字符为单位</span></em><span>，属于无结构设备，如打印机</span></p></li><li><p><em><span>传输速率低、不可寻址，常采用中断IO方式</span></em></p></li></ul></li></ul></li><li><p><span>IO的功能</span></p><ul><li><p><span>状态跟踪：实时掌握外部设备的状态</span></p></li><li><p><span>设备存取：数据的存取</span></p></li><li><p><span>设备分配：设备的分配和回收</span></p></li><li><p><span>设备控制：包含设备的驱动、故障的中断等</span></p></li></ul></li><li><p><span>I/O接口</span></p><ul><li><p><span>设备控制器的一部分</span></p></li><li><p><span>既要与CPU通信，又要和设备通信，还要具有按CPU发来的命令去控制设备工作的功能</span></p></li><li><p><span>组成</span></p><ol start='' ><li><p><span>设备控制器与CPU的接口</span></p></li></ol><ul><li><p><span>有</span><em><span>数据线、地址线、控制线</span></em></p></li><li><p><span>数据线通常连接数据寄存器和控制/状态寄存器</span></p></li><li><p><span>控制线只能IO到CPU的单向传输</span></p></li><li><p><span>数据寄存器和可以是CPU向IO设备发送的数据，也可以是IO向CPU发送的数据（双向）</span></p></li></ul><ol start='2' ><li><p><span>设备控制器与设备的接口</span></p></li></ol><ul><li><p><em><span>一个设备控制器可连接多个IO设备，因此控制器中有多个接口</span></em></p></li><li><p><em><span>每个接口中都存在数据、控制、状态三种类型的信号</span></em></p></li></ul><ol start='3' ><li><p><span>IO逻辑</span></p></li></ol><ul><li><p><span>用于实现对设备的控制</span></p></li><li><p><span>通过一组控制线与CPU交互，对从CPU发来的IO命令进行译码</span></p></li><li><p><span>CPU启动设备时，将启动命令发送给控制器，并通过地址线将地址发送给控制器，IO逻辑译码命令，并通过地址控制指定设备</span></p></li></ul></li></ul></li><li><p><span>功能</span></p><ul><li><p><span>接收和识别CPU发来的命令、数据交换、标识和报告设备的状态、地址识别、数据缓冲、差错控制</span></p></li></ul></li><li><p><span>I/O端口</span></p><ul><li><p><span>是设备控制器中，能被 CPU 直接访问的</span><em><span>寄存器</span></em></p></li><li><p><em><span>端口只是接口的一部分</span></em></p></li><li><p><span>组成</span></p><ul><li><p><span>数据寄存器</span></p><ul><li><p><span>实现CPU和外设的</span><em><span>数据缓冲</span></em></p></li></ul></li><li><p><span>状态寄存器</span></p><ul><li><p><span>获取执行结果和设备的状态信息，</span><em><span>让CPU知道是否准备好</span></em></p></li></ul></li><li><p><span>控制寄存器</span></p><ul><li><p><em><span>由CPU写入</span></em><span>，以便启动命令或更改设备模式</span></p></li></ul></li></ul></li><li><p><span>编址</span></p><ul><li><p><span>因为是按地址进行访问的，因此必须对IO设备进行编址，CPU才能访问</span></p></li><li><p><span>独立编址</span></p><ul><li><p><span>为</span><em><span>每个端口分配一个IO端口号，所有IO端口形成IO端口空间，这种地址和内存地址不同</span></em></p></li><li><p><span>普通用户程序不能对端口进行访问，只有操作系统使用</span><em><span>特殊的IO指令</span></em><span>才能访问端口</span></p></li></ul></li><li><p><span>统一编址</span></p><ul><li><p><span>又称内存映射IO，</span><em><span>每个端口被分配唯一的内存地址</span></em><span>，且不会有内存被分配这个地址</span></p></li><li><p><span>通常分配给端口的地址靠近地址空间的顶端</span></p></li><li><p><span>绝对号：将每台设备统一编号，作为识别设备的代号</span></p></li></ul></li></ul></li></ul></li><li><p><span>I/O控制方式</span></p><ul><li><p><span>程序直接控制方式</span></p><ul><li><p><span>计算机从外部设备读取的</span><em><span>每个字</span></em><span>，CPU需要对外设状态进行循环检查，直到确定该字已在IO控制器的数据寄存器中</span></p></li><li><p><em><span>CPU和IO设备串行工作</span></em><span>，CPU利用率非常低</span></p></li></ul></li><li><p><span>中断驱动方式</span></p><ul><li><p><span>允许IO设备主动打断CPU的运行并请求服务</span></p></li><li><p><span>从IO设备的角度看，IO控制器从CPU接收一个读命令，然后从外部设备读数据，一旦数据放到数据寄存器，就通过控制线给CPU发中断信号，表示数据已备好。若收到CPU发出的数据请求后，就将数据放到数据总线上，传到CPU寄存器里</span></p></li><li><p><span>从CPU角度看，CPU发送读命令，然后保存当前程序的上下文，转而运行其他程序，</span><em><span>在每个指令周期的末尾，CPU检查中断</span></em><span>，当有IO中断时，保存当前程序上下文，转而去处理中断</span></p></li><li><p><span>尽管 IO 和 CPU 并行，但由于</span><em><span>数据中的每个字的传输都要经过CPU，因此仍然会消耗较多CPU时间</span></em></p></li></ul></li><li><p><span>DMA方式</span></p><ul><li><p><span>在IO设备和内存之间直接开辟数据交换通路</span></p></li><li><p><em><span>数据交换单位是数据块而不是字，但每次传送的仍然是字</span></em><span>（因为数据线就那么几位）</span></p><ul><li><p><em><span>块的大小和磁盘控制器中的数据缓冲区大小相同，即缓冲区每充满一次就要发送一次总线请求</span></em></p></li></ul></li><li><p><span>所传输的数据是从设备直接到内存的，或者相反</span></p></li><li><p><span>DMA控制器组成</span></p><ul><li><p><span>命令/状态寄存器CR</span></p><ul><li><p><span>接收从CPU发来的IO命令和控制信息，或设备的状态</span></p></li></ul></li><li><p><span>内存地址寄存器MAR</span></p><ul><li><p><em><span>输入时，存放的是要传输到的内存起始地址</span></em><span>；输出时，存放的是内存到设备的内存源地址</span></p></li></ul></li><li><p><span>数据寄存器DR</span></p><ul><li><p><span>暂存从设备到内存或从内存到设备的数据</span></p></li></ul></li><li><p><span>数据计数器DC</span></p><ul><li><p><em><span>存放本次传输的字(节)数，也就是数据大小</span></em></p></li></ul></li></ul></li><li><p><span>DMA方式只有在</span><em><span>开始和结束时有CPU介入</span></em><span>，</span><em><span>只有在结束时会中断</span></em></p></li><li><p><em><span>中断会在每个字传送完成时中断CPU，而DMA则是在一组数据传送完后才中断；DMA的数据传送在DMA控制器的控制下完成，而中断方式是在CPU控制下完成的</span></em></p></li></ul></li><li><p><span>通道控制方式</span></p><ul><li><p><span>IO通道是DMA方式的发展</span></p></li><li><p><span>IO通道也能执行指令，可以看作一个小型CPU，但指令单一，且没有自己的内存（和CPU共享内存），通道程序放在内存中</span></p></li><li><p><span>DMA一次只能一台设备传送，而通道可以控制多台设备和内存交换数据</span></p></li></ul></li></ul></li><li><p><span>I/O软件层次</span></p><ul><li><p><span>用户层IO软件</span></p><ul><li><p><span>用户程序IO接口，即实现和用户交互的接口</span></p></li><li><p><span>必须通过系统调用来实现IO操作</span></p></li><li><p><span>注意用户层 IO 软件是</span><em><span>用户软件</span></em><span>，不属于 IO 系统</span></p></li></ul></li><li><p><span>设备独立性软件</span></p><ul><li><p><span>即</span><em><span>系统调用的处理软件</span></em></p></li><li><p><span>用于实现用户程序和设备驱动的统一接口、设备命令、设备的保护和设备的分配及释放</span></p></li><li><p><span>设备独立性指</span><em><span>应用程序独立于具体使用的物理设备</span></em><span>，为此引入了逻辑设备名和物理设备名</span></p></li></ul></li><li><p><span>设备驱动程序</span></p><ul><li><p><span>与硬件直接相关，负责解释上层对硬件的指令，驱动IO设备工作的驱动程序，例如读入键盘输入</span></p></li><li><p><span>介于硬件和操作系统之间，为OS隐藏具体的细节</span></p></li><li><p><span>驱动程序可初始化设备，且和具体的IO控制方式有关，如DMA方式要求驱动程序能设置DMA接口中的寄存器</span></p></li><li><p><em><span>同一种类的设备只需要一个驱动程序</span></em><span>，更换物理设备后，只需更换驱动程序而无序修改应用</span></p></li></ul></li><li><p><span>中断处理程序</span></p><ul><li><p><span>用于保存被中断的CPU环境，转入相应的中断处理程序进行处理</span></p></li><li><p><span>中断处理和硬件紧密相关，被放在OS的</span><em><span>最底层</span></em></p></li></ul></li><li><p><span>硬件</span></p><ul><li><p><span>如显卡就是IO设备</span></p></li></ul></li></ul></li><li><p><span>应用程序I/O接口</span></p><ul><li><p><span>即用户层 IO 软件的接口</span></p></li><li><p><span>字符设备接口</span></p><ul><li><p><em><span>数据的存取和传输以字符为单位，如键盘、打印机等</span></em></p></li><li><p><em><span>只能顺序存取，有字符缓冲区</span></em></p></li><li><p><em><span>速率低，不可寻址，一般是中断驱动</span></em></p></li><li><p><span>都属于独占设备，需要实现互斥访问</span></p></li><li><p><span>get和put操作，分别表示从缓冲区获得字符和将字符输出到缓冲区</span></p></li><li><p><span>in-control指令：接口中提供的一种通用的指令，包含了许多参数，每个参数表示和一个具体设备相关的特定功能</span></p></li></ul></li><li><p><span>块设备接口</span></p><ul><li><p><em><span>数据的存取和传输以数据块为单位，如磁盘</span></em></p></li><li><p><em><span>速率高，可寻址，一般是DMA方式</span></em></p></li><li><p><span>内存映射接口通过内存的字节数组来访问磁盘，而不提供读写磁盘操作，它的访问简单，方便了程序员</span></p></li></ul></li><li><p><span>网络设备接口</span></p><ul><li><p><span>也就是网络通信接口，使得计算机能够访问互联网</span></p></li><li><p><span>许多网络IO接口也是网络套接字接口</span></p></li></ul></li><li><p><span>阻塞/非阻塞IO</span></p><ul><li><p><em><span>阻塞IO是进程调用IO时，会被阻塞，需要等待IO完成，才被唤醒继续执行</span></em><span>，目前大多数IO接口都是阻塞的</span></p></li><li><p><span>非阻塞是调用IO时，不阻塞该进程，IO调用返回一个错误值，通常需要通过轮询的方式查询IO操作是否完成</span></p></li></ul></li></ul></li></ul><h4 id='设备独立性软件'><span>设备独立性软件</span></h4><p><span>设备独立性软件是 IO 系统最高层软件，向上是用户app，向下是驱动程序</span></p><ul><li><p><span>磁盘高速缓存</span></p><ul><li><p><em><span>逻辑上属于磁盘，物理上属于内存</span></em></p></li><li><p><span>提高磁盘的IO速度</span></p></li><li><p><span>形式</span></p><ul><li><p><span>在内存中开辟一个单独的空间作为磁盘高速缓存，大小是固定的</span></p></li><li><p><span>把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘IO共享，大小可变</span></p></li></ul></li></ul></li><li><p><span>缓冲区（Buffer）</span></p><ul><li><p><span>引入目的</span></p><ol start='' ><li><p><span>缓和CPU和IO设备速度的不匹配矛盾</span></p></li><li><p><span>减少CPU中断频率，放宽对CPU中断响应时间的限制（鼠标也有缓冲）</span></p></li><li><p><span>解决基本数据单元大小（数据粒度）不匹配问题</span></p></li><li><p><span>提高CPU和IO的并行性</span></p></li></ol></li><li><p><span>单缓冲</span></p><ul><li><p><span>主存中仅设置一个缓冲区</span></p></li><li><p><em><span>工作区：用户进程中存放IO数据的地方</span></em><span>，缓冲区的数据将传送到工作区，一般和缓冲区大小相等</span></p></li><li><p><span>一方</span><em><span>读或写</span></em><span>时，另一方需等待</span></p></li><li><p><span>每块数据的总时间为</span><span class='math-in-toc'>$max(C,T)+M$</span><span>，C 是CPU对单块数据的处理时间，T 为单块数据从磁盘传输到缓冲区的时间，M 为OS将缓冲区数据传送到工作区的时间（</span><em><span>磁盘-缓冲区-CPU（工作区）</span></em><span>）</span></p></li><li><p><span>研究耗时的公式时，可</span><em><span>假定工作区是满的（CPU可以立即处理数据），而缓冲区为空（可以写缓冲）</span></em></p></li></ul></li><li><p><span>双缓冲</span></p><ul><li><p><span>单缓冲区，在传送时间M，CPU处于空闲状态</span></p></li><li><p><span>设置两个缓冲区，</span><em><span>数据先写入缓冲区1，1填满后才开始装填缓冲区2，与此同时CPU可读取缓冲区1的数据</span></em></p></li><li><p><span>双缓冲提高了CPU和IO的并行性</span></p></li><li><p><span>时间为</span><span class='math-in-toc'>$max(C+M，T)$</span><span>，C 处理，T 写入，M 缓冲区传输到工作区时间。在研究处理一块时间的用时，假定缓冲区1为空，而缓冲区2为满，工作区为空</span></p></li></ul></li><li><p><span>循环缓冲</span></p><ul><li><p><span>含多个大小相等的缓冲区，</span><em><span>每个缓冲区有一个指针指向下一个缓冲区</span></em><span>，最后一个缓冲区指向第一个缓冲区，逻辑成环</span></p></li><li><p><span>必须有 in 和 out 两个指针，</span><em><span>in 指向可以输入的第一个空缓冲</span></em><span>，out 指向可以读数据的第一个满缓冲</span></p></li></ul></li><li><p><span>缓冲池</span></p><ul><li><p><em><span>除缓冲池外，其余缓冲都为专用缓冲，即前面几个都是临界资源</span></em></p></li><li><p><span>由多个系统公用的缓冲区组成，按使用情况排列成三个队列：</span><em><span>空缓冲、装满输入数据的输入队列、装满输出数据的输出队列</span></em></p></li><li><p><span>当输入进程需要输入数据时，将空缓冲队列的队首摘下一个空缓冲区，作为收容输入工作缓冲区，然后装入数据，装满后将其挂到输入队列队尾，输出也是类似的</span></p></li></ul></li><li><p><span>缓冲区和高速缓存的对比</span></p><ul><li><p><span>都介于高速和低速设备之间</span></p></li><li><p><em><span>Cache存放的是数据副本，而缓冲里的数据却不一定在别的地方有副本</span></em></p></li><li><p><span>高速和低速设备的通信必须经过缓冲区，高速设备永远不会直接访问低速设备；</span><em><span>若数据不在Cache中，则高速设备要访问低速设备（CPU访问内存）</span></em></p></li></ul></li></ul></li><li><p><span>设备的分配与回收</span></p><ul><li><p><span>分配：根据用户的IO请求分配所需的设备</span></p></li><li><p><span>分配原则：尽可能让设备忙碌，又要避免不合理的分配方式造成进程死锁</span></p></li><li><p><span>分配方式</span></p><ul><li><p><span>独占式</span></p><ul><li><p><span>某进程</span><em><span>从头到尾独占</span></em><span>，直到进程释放该设备</span></p></li></ul></li><li><p><span>分时式共享使用</span></p><ul><li><p><span>对于共享设备，可以通过分时共享使用，但仍然不能同时使用</span></p></li></ul></li><li><p><span>SPOOLing方式</span></p><ul><li><p><span>假脱机技术实现了虚拟设备功能，可以将设备同时分配给多个进程</span></p></li><li><p><span>该技术本质上实现了对设备IO操作的批处理</span></p></li></ul></li></ul></li><li><p><span>数据结构</span></p><ul><li><p><span>DCT（device control table）</span></p><ul><li><p><span>设备控制表，</span><em><span>一个表对应一个设备</span></em><span>，表项就是设备的各个属性</span></p></li><li><p><span>表中含有设备队列的队首指针，设备队列是所有请求本设备而暂未得到满足的进程</span></p></li></ul></li><li><p><span>COCT（controler）</span></p><ul><li><p><span>控制器控制表，表示设备控制器，它的有一个表项中存放着指向相应通道控制表CHCT的指针</span></p></li><li><p><span>设备控制器请求通道为它服务</span></p></li></ul></li><li><p><span>CHCT（channel）</span></p><ul><li><p><span>通道控制表，由于</span><em><span>一个通道可以为多个设备控制器服务</span></em><span>，因此CHCT中有一个指针指向一个表，表中记录的是该通道可以为哪几个设备控制器服务</span></p></li><li><p><em><span>CHCT和COCT是一对多的关系</span></em></p></li></ul></li><li><p><span>SDT（system device）</span></p><ul><li><p><em><span>系统设备表，整个系统只有一张</span></em><span>，每个表目记录着一个连接到系统的物理设备的情况</span></p></li></ul></li></ul></li><li><p><span>分配策略</span></p><ul><li><p><span>分配原则</span></p><ul><li><p><span>充分提高设备效率，同时避免造成进程死锁，还要将用户程序和具体设备隔离开来</span></p></li><li><p><span>设备类型、访问权限、设备占用状态、逻辑-物理设备的映射关系都需要考虑</span></p></li></ul></li><li><p><span>分配方式</span></p><ul><li><p><span>静态分配</span></p><ul><li><p><span>主要用于</span><em><span>独占式</span></em><span>设备的分配</span></p></li><li><p><span>在作业开始前，由系统一次性分配该作业所要求的全部设备，一旦分配，该设备就一直为该作业所占用</span></p></li><li><p><span>不会出现死锁，但设备使用率低</span></p></li></ul></li><li><p><span>动态分配</span></p><ul><li><p><span>在进程执行过程中根据需要动态分配</span></p></li><li><p><span>当某作业需要某设备时，通过系统调用命令向系统提出设备请求，系统按策略分配设备和控制器</span></p></li><li><p><span>一旦用完，便立即释放设备</span></p></li><li><p><span>该方法有利于提高设备利用率，但可能造成死锁</span></p></li></ul></li></ul></li><li><p><span>分配算法</span></p><ul><li><p><span>动态分配算法有先请求先分配、按优先级分配等</span></p></li><li><p><span>独占式设备既</span><em><span>可采用静态</span></em><span>也</span><em><span>可采用动态</span></em><span>分配</span></p></li><li><p><span>共享设备一般是动态分配，但它在每个IO传输的单位时间内仍然是仅被一个进程占有</span></p></li></ul></li></ul></li><li><p><span>分配的安全性</span></p><ul><li><p><span>指设备分配中应防止发生死锁</span></p></li><li><p><span>安全分配方式</span></p><ul><li><p><span>当进程发出IO请求后便陷入阻塞，直到IO完成才将其唤醒</span></p></li><li><p><span>这样，陷入阻塞后进程便不能请求任何资源，在阻塞时也不保持任何资源</span></p></li><li><p><span>优点是设备分配安全，缺点是CPU和IO是串行工作的（CPU等待IO完成）</span></p></li></ul></li><li><p><span>不安全分配方式</span></p><ul><li><p><span>进程在发出IO请求</span><em><span>仍然可以请求其他资源</span></em><span>，仅当请求的资源已被其它进程占用，才进入阻塞态</span></p></li><li><p><span>优点是一个进程可以操控多个设备，使进程推进迅速，缺点是可能造成死锁</span></p></li></ul></li></ul></li><li><p><span>从逻辑设备名到物理设备名</span></p><ul><li><p><span>设备视为特殊的文件，故</span><em><span>应用程序可用文件名访问物理设备，该文件名为逻辑设备名</span></em></p></li><li><p><span>在系统中设置一张 LUT（look up table），即逻辑设备表，将逻辑设备名映射到物理设备</span></p></li><li><p><span>LUT表项包含逻辑设备名、物理设备名和设备驱动入口地址</span></p></li><li><p><span>LUT的设置</span></p><ul><li><p><span>整个系统中仅设置一张LUT，因此不允许两个设备有相同的逻辑名，适用于单用户系统</span></p></li><li><p><span>为每个用户设置一张LUT，当用户登录时便为其建立一个进程，同时也建立一张LUT，放到该进程的PCB中</span></p></li></ul></li></ul></li></ul></li><li><p><span>SPOOLing假脱机技术</span></p><ul><li><p><em><span>为了缓和高速的CPU和低速的IO设备之间的矛盾</span></em><span>，引入脱机输入/输出技术，是OS中采用的一项</span><em><span>将独占设备改造成共享设备的技术</span></em></p></li><li><p><span>利用专门的外围控制机，将低速</span><em><span>IO设备</span></em><span>上的数据传输到高速磁盘上，或者相反</span></p></li><li><p><span>组成</span></p><p><em><span>进程和井是基本条件</span></em></p><ul><li><p><span>输入井和输出井（数据暂存区域）</span></p><ul><li><p><span>在</span><em><span>磁盘</span></em><span>上开辟的两个存储区域</span></p></li><li><p><em><span>输入井模拟脱机输入的磁盘，用于收容IO设备的输入</span></em><span>；输出井模拟脱机输出的磁盘，用于收容用户程序的输出数据（从磁盘到输出设备）</span></p></li><li><p><span>一个进程的输入或输出数据保存为一个文件，所有进程的数据输入或输出文件链接成一个输入（输出）队列</span></p></li></ul></li><li><p><span>输入进程和输出进程</span></p><ul><li><p><span>用于模拟脱机输入/输出时的外围控制机</span></p></li><li><p><span>用户要求的数据从输入设备经过经过输入缓冲区送到输入井，当CPU需要输入数据时，直接从输入井读入内存</span></p></li><li><p><span>用户的输出数据先输出到输出井，等到输出设备空闲时，再将输出井的数据经过输出缓冲区传送到输出设备</span></p></li></ul></li><li><p><span>输入缓冲区和输出缓冲区</span></p><ul><li><p><span>在</span><em><span>内存</span></em><span>开辟的两个缓冲区</span></p></li><li><p><em><span>输入缓冲区用于暂存输入设备送来的数据，以后再传送到输入井</span></em><span>；输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备</span></p></li></ul></li></ul></li><li><p><span>共享打印机就是 SPOOLing 技术的实例。就像一个进程要输出，它把数据放到了快递站，快递站准备好后，告诉进程你可以走了，这边马上开始传送数据</span></p></li><li><p><span>假脱机技术是一种以</span><em><span>空间换时间</span></em><span>的技术，提高了IO速度，将独占设备改造成各项设备，实现了虚拟设备功能，好像每个进程都使用了设备</span></p></li></ul></li><li><p><span>设备驱动程序接口</span></p><ul><li><p><span>如果设备驱动程序和操作系统的接口都不一样，那么每次出现一个新设备都要修改操作系统，因此要求每个设备驱动程序和操作系统之间有着相近的接口</span></p></li><li><p><span>驱动程序中包含一张特殊表格，这张表格具有针对这些函数（读写等）</span><em><span>指向驱动程序自身的指针</span></em></p></li><li><p><span>当装载驱动程序时，操作系统记录这个函数指针表的地址，所以当操作系统调用函数时，可以通过这张表格发出间接调用</span></p></li></ul></li></ul><h4 id='磁盘与固态硬盘'><span>磁盘与固态硬盘</span></h4><ul><li><p><span>磁带存储</span></p><ul><li><p><span>磁盘是共享设备（分时共享），</span><em><span>磁带是独占设备</span></em></p></li><li><p><span>只有</span><em><span>磁带只能顺序访问</span></em><span>，</span><em><span>光盘、磁盘等均可随机读写</span></em></p></li><li><p><em><span>磁带中，每个逻辑记录就占一个块</span></em></p></li></ul></li><li><p><span>磁盘上的数据存储在一组同心圆上，称为磁道；一个盘面有上千个磁道，磁道又划分为几百个扇区，</span><em><span>每个扇区固定存储大小，一个扇区称为一个盘块</span></em><span>。磁盘的存储能力受限于</span><em><span>最内道的最大记录密度</span></em></p></li><li><p><span>扇区是磁盘可寻址的最小单位，磁盘上能存储的物理块数由扇区数、磁道数、盘面数决定</span></p></li><li><p><span>磁盘地址由</span><em><span>柱面号-盘面号-扇区号</span></em><span>表示</span></p></li><li><p><span>磁盘管理</span></p><ul><li><p><span>初始化</span></p><ul><li><p><span>一个</span><em><span>新的磁盘没有扇区</span></em><span>等东西，必须格式化才能进行读写操作</span></p></li><li><p><span>即</span><em><span>低级格式化（物理格式化），主要是划分扇区</span></em><span>，划分扇区时使用特殊的数据结构填充磁盘，该数据结构通常由头部、数据区域、尾部组成</span></p></li></ul></li><li><p><span>分区</span></p><ol start='' ><li><p><span>第一步：分为一个或多个柱面组成的分区，每个分区的起始扇区和大小都记录在磁盘的主引导记录的分区表中</span></p></li><li><p><span>第二步：</span><em><span>逻辑格式化，创建文件系统及根目录，此时产生了引导扇区</span></em></p><p><span>常</span><em><span>将多个相邻的扇区组合在一起，形成簇（也称块），一个簇只能存放一个文件的内容，如果文件大小小于1簇，也占用一簇的空间</span></em></p></li></ol></li><li><p><span>引导块</span></p><ul><li><p><span>计算器启动时需要运行一个初始化程序（自举程序），通常存放在ROM中</span></p></li><li><p><span>通常ROM里面只保存很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块（引导块）上</span></p></li><li><p><span>首先运行ROM里面的自举装入程序，接着运行MBR里的引导代码，然后查分区表去找含有操作系统的分区，接着读取该分区的第一个扇区，称为引导扇区，然后加载OS</span></p></li></ul></li><li><p><span>坏块</span></p><ul><li><p><span>磁盘是机械部件，容易导致一个或多个扇区损坏</span></p></li><li><p><span>低级格式化可以保留一些备用块，用于逻辑上替代坏块，这种方法称为扇区备用</span></p></li><li><p><span>坏块的处理实际上就是使用某种机制让系统不使用坏块</span></p></li></ul></li></ul></li><li><p><span>磁盘调度</span></p><ul><li><p><span>读写时间的组成</span></p><ul><li><p><span>寻道时间 </span><span class='math-in-toc'>$T_s$</span></p><ul><li><p><span>将磁头移动到指定磁道所需要的时间，包含跨越 n 条磁道的时间和启动磁臂的时间</span></p></li><li><p><span class='math-in-toc'>$T_s=m * n+s$</span><span>，m 为跨越一条磁道的时间，s 为启动磁臂的时间</span></p></li></ul></li><li><p><span>旋转延迟时间 </span><span class='math-in-toc'>$T_r$</span></p><ul><li><p><span>磁头找到磁道后，还要定位到该扇区，即旋转延迟时间</span></p></li><li><p><span>其</span><em><span>平均值就是转半个圈</span></em><span>，即</span><span class='math-in-toc'>$\frac{1}{2r}$</span><span>，r 为每秒转速</span></p></li><li><p><span>旋转延迟时间和磁盘空闲管理分配程序</span><em><span>有关</span></em><span>（顺序存储还是离散存储等）</span></p></li></ul></li><li><p><span>传输时间 </span><span class='math-in-toc'>$T_t$</span></p><ul><li><p><span>磁盘读取数据或写入数据的时间，取决于每次读写的字节数 b 和磁盘的旋转速度 r</span></p></li><li><p><span class='math-in-toc'>$T_t=\frac{b}{rN}$</span><span>，N 为一个磁道上的字节数</span></p></li></ul><p><span>从上述公式可以看出，磁盘转速非常重要（且为线性相关）</span></p></li></ul></li><li><p><span>磁盘调度算法（减少寻道时间）</span></p><ul><li><p><span>先来先服务 FCFS</span></p><ul><li><p><span>根据请求访问磁盘的先后顺序访问，具有公平性</span></p></li><li><p><em><span>固态硬盘</span></em><span>几乎无寻道、旋转等延迟，适合使用该算法</span></p></li></ul></li><li><p><span>最短寻找时间优先 SSTF</span></p><ul><li><p><span>选择当前磁头所在的距离最短的请求磁道</span></p></li><li><p><span>会产生饥饿现象</span></p></li></ul></li><li><p><span>扫描调度 SCAN</span></p><ul><li><p><span>又称电梯调度算法，可以把磁道的移动想象成电梯上下</span></p></li><li><p><span>每次前往本次运动方向上的最近磁道，且</span><em><span>必须到达端点处才能改变方向</span></em></p></li><li><p><span>局部访问性不太好，对最近扫描过的区域不公平（</span><em><span>没有使用局部性原理</span></em><span>），且不利于远离磁头那一端的请求</span></p></li></ul></li><li><p><span>循环扫描调度 C-SCAN</span></p><ul><li><p><span>在 SCAN 算法上规定了</span><em><span>磁盘单向移动</span></em><span>，即</span><em><span>每次扫描一遍后立即返回启动时的端点</span></em><span>，再次扫描</span></p></li><li><p><span>消除了远离磁头一端的不平等</span></p></li><li><p><span>磁臂黏着现象</span></p><ul><li><p><span>即磁臂一直停留在某个磁道附近，尽管有更先到达的请求</span></p></li><li><p><em><span>除了 FCFS 都会有磁臂黏着现象</span></em></p></li><li><p><span>磁臂黏着也是造成饥饿的原因</span></p></li><li><p><span>其本质是：同一方向上，算法会优先处理靠得近的，如果这个磁道有很多请求扎堆出现，则远处的请求仍然要等很久</span></p></li></ul></li></ul></li><li><p><span>LOOK 和 C-LOOK 算法</span></p><ul><li><p><span>分别是 SCAN 和 C-SCAN 的改进，即</span><em><span>不一定得移动到端点，而是移动到最远处的一个请求即可</span></em></p></li><li><p><span>做题时若无说明，默认 SCAN 和 C-SCAN 就是 LOOK 与 C-LOOK 算法</span></p></li></ul></li></ul></li><li><p><span>减少旋转延迟时间</span></p><ul><li><p><span>盘面扇区交替编号：磁头读完一个扇区有一定处理时间，若下一个扇区是接着的数据，可能因为这个处理时间而错过</span></p></li><li><p><span>不同盘面错位命名：所有盘面同步转动。若同一柱面上，不同盘面上的扇区编号不同，则读入相邻盘面上的连续数据时能减少延迟</span></p></li></ul></li><li><p><span>改善磁盘IO性能的方法</span></p><ul><li><p><span>磁盘高速缓存</span></p></li><li><p><span>好的磁盘调度算法</span></p></li><li><p><span>提前读：把下一块也一起读出来</span></p></li><li><p><span>延迟写：针对缓冲区数据而言，可以先不删除，直到要占用这一块缓冲区再删</span></p></li></ul></li></ul></li><li><p><span>固态硬盘</span></p><ul><li><p><span>一种基于闪存技术的存储器，本质上是 ROM 的一种，和 U 盘无本质区别</span></p></li><li><p><span>一个 SSD 由多个闪存芯片和闪存翻译层组成</span></p></li><li><p><span>有多个块，块中有多个页，数据以</span><em><span>页</span></em><span>为单位读写，只有在一页所属的整个块被擦除后，才能写这一页</span></p></li><li><p><span>磨损均衡</span></p><ul><li><p><span>动态磨损均衡</span></p><ul><li><p><span>写入数据时，自动选择较新的闪存块</span></p></li></ul></li><li><p><span>静态磨损均衡</span></p><ul><li><p><span>更为先进，就算没有数据写入，SSD也会自动检测并进行数据分配</span></p></li></ul></li></ul></li></ul></li></ul><p>&nbsp;</p></div></div>

<script>(function(){function e(e,n,i){document.addEventListener(e,function(e){if(!e.defaultPrevented)for(var t=e.target;t&&t!=this;t=t.parentNode)if(t.matches(n)){!1===i.call(t,e)&&(e.preventDefault(),e.stopPropagation());break}},!1)}var t=document.body.parentElement,i=[],r=null,o=document.body.classList.contains("typora-export-collapse-outline");function a(){return t.scrollTop}e("click",".outline-expander",function(e){var t=this.closest(".outline-item-wrapper").classList;return t.contains("outline-item-open")?t.remove("outline-item-open"):t.add("outline-item-open"),u(),!1}),e("click",".outline-item",function(e){var t=this.querySelector(".outline-label");location.hash="#"+t.getAttribute("href"),o&&((t=this.closest(".outline-item-wrapper").classList).contains("outline-item-open")||t.add("outline-item-open"),d(),t.add("outline-item-active"))});function s(){var e=a();r=null;for(var t=0;t<i.length&&i[t][1]-e<60;t++)r=i[t]}function n(){c=setTimeout(function(){var n;i=[],n=a(),document.querySelector("#write").querySelectorAll("h1, h2, h3, h4, h5, h6").forEach(e=>{var t=e.getAttribute("id");i.push([t,n+e.getBoundingClientRect().y])}),s(),u()},300)}var l,c,d=function(){document.querySelectorAll(".outline-item-active").forEach(e=>e.classList.remove("outline-item-active")),document.querySelectorAll(".outline-item-single.outline-item-open").forEach(e=>e.classList.remove("outline-item-open"))},u=function(){if(r&&(d(),t=document.querySelector('.outline-label[href="#'+(CSS.escape?CSS.escape(r[0]):r[0])+'"]')))if(o){var e=t.closest(".outline-item-open>ul>.outline-item-wrapper");if(e)e.classList.add("outline-item-active");else{for(var t,n=(t=t.closest(".outline-item-wrapper")).parentElement.closest(".outline-item-wrapper");n;)n=(t=n).parentElement.closest(".outline-item-wrapper");t.classList.add("outline-item-active")}}else t.closest(".outline-item-wrapper").classList.add("outline-item-active")};window.addEventListener("scroll",function(e){l&&clearTimeout(l),l=setTimeout(function(){s(),u()},300)});window.addEventListener("resize",function(e){c&&clearTimeout(c),n()}),n()})();</script></body>
</html>