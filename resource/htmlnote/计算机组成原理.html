<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex: 2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }
.md-alert.md-alert-note { border-left-color: rgb(9, 105, 218); }
.md-alert.md-alert-important { border-left-color: rgb(130, 80, 223); }
.md-alert.md-alert-warning { border-left-color: rgb(154, 103, 0); }
.md-alert.md-alert-tip { border-left-color: rgb(31, 136, 61); }
.md-alert.md-alert-caution { border-left-color: rgb(207, 34, 46); }
.md-alert { padding: 0px 1em; margin-bottom: 16px; color: inherit; border-left: 0.25em solid rgb(0, 0, 0); }
.md-alert-text-note { color: rgb(9, 105, 218); }
.md-alert-text-important { color: rgb(130, 80, 223); }
.md-alert-text-warning { color: rgb(154, 103, 0); }
.md-alert-text-tip { color: rgb(31, 136, 61); }
.md-alert-text-caution { color: rgb(207, 34, 46); }
.md-alert-text { font-size: 0.9rem; font-weight: 700; }
.md-alert-text svg { fill: currentcolor; position: relative; top: 0.125em; margin-right: 1ch; overflow: visible; }
.md-alert-text-container::after { content: attr(data-text); text-transform: capitalize; pointer-events: none; margin-right: 1ch; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


/* you can override the default max-width size here or override each style by your custom css */

#write {
    font-size: 1.25rem;
    line-height: 1.625rem;
    max-width: 80rem;
}

p {
    line-height: 2rem;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875em;
}
@import "";
@import "";

/* FONTS */

/* VARIABLES */

:root {
  --theme-0: rgb(255, 255, 255);

  /* Slate grayscale */
  --theme-50: #f8fafc;
  --theme-100: #f1f5f9;
  --theme-200: #e2e8f0;
  --theme-300: #cbd5e1;
  --theme-400: #94a3b8;
  --theme-500: #64748b;
  --theme-600: #475569;
  --theme-700: #334155;
  --theme-800: #1e293b;
  --theme-900: #0f172a;

  /* Tailwind variables */
  --tw-primary: #62bbf3;

  --tw-prose-body: var(--theme-700);
  --tw-prose-headings: var(--theme-900);
  --tw-prose-lead: var(--theme-600);
  --tw-prose-links: var(--theme-900);
  --tw-prose-bold: var(--theme-900);
  --tw-prose-counters: var(--theme-500);
  --tw-prose-bullets: var(--theme-300);
  --tw-prose-hr: var(--theme-200);
  --tw-prose-quotes: var(--theme-900);
  --tw-prose-quote-borders: var(--theme-200);
  --tw-prose-captions: var(--theme-500);
  --tw-prose-code: var(--theme-900);
  --tw-prose-pre-code: var(--theme-100);
  --tw-prose-pre-bg: var(--theme-800);
  --tw-prose-th-borders: var(--theme-300);
  --tw-prose-td-borders: var(--theme-200);
  --tw-prose-bg: var(--theme-0);
  --tw-prose-meta: var(--theme-500);
  --tw-prose-meta-bg: var(--theme-100);

  --tw-prose-invert-body: var(--theme-300);
  --tw-prose-invert-headings: var(--theme-0);
  --tw-prose-invert-lead: var(--theme-400);
  --tw-prose-invert-links: var(--theme-0);
  --tw-prose-invert-bold: var(--theme-0);
  --tw-prose-invert-counters: var(--theme-400);
  --tw-prose-invert-bullets: var(--theme-600);
  --tw-prose-invert-hr: var(--theme-700);
  --tw-prose-invert-quotes: var(--theme-100);
  --tw-prose-invert-quote-borders: var(--theme-700);
  --tw-prose-invert-captions: var(--theme-400);
  --tw-prose-invert-code: var(--theme-0);
  --tw-prose-invert-pre-bg: var(--theme-900);
  --tw-prose-invert-th-borders: var(--theme-600);
  --tw-prose-invert-td-borders: var(--theme-700);
  --tw-prose-invert-bg: var(--theme-800);
  --tw-prose-invert-meta: var(--theme-400);
  --tw-prose-invert-meta-bg: var(--theme-700);

  --tw-highlight-color: #fde047; /* yellow-300 */
  --tw-drop-shadow-md: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07))
    drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));
  --tw-button-hover-bg: var(--theme-100);

  --tw-button-hover-bg-inverted: var(--theme-700);

  /* Typora variables */

  --background: var(--tw-prose-bg);
  --bg-color: var(--tw-prose-bg);
  --text-color: var(--tw-prose-body);
  --primary-color: var(--tw-primary);
  --md-char-color: var(--theme-400);
  --meta-content-color: var(--theme-500);
  --typora-source-body: var(--theme-800);
  --heading-char-color: var(--md-char-color);
  --mermaid-theme: neutral;
  --active-toggle-btn-color: var(--theme-200);

  --md-char-color-inverted: var(--theme-500);
  --meta-content-color-inverted: var(--theme-400);
  --typora-source-body-inverted: var(--theme-300);
  --mermaid-theme-inverted: dark;
  --active-toggle-btn-color-inverted: var(--theme-400);

  /* Sidebar */
  --side-bar-bg-color: var(--tw-prose-bg);
  --active-file-bg-color: var(--theme-100);
  --active-file-text-color: var(--tw-prose-bold);
  --active-file-border-color: var(--theme-100);
  --panel-border-color: var(--theme-300);
  --blur-text-color: var(--theme-300);
  --window-border: 1px solid var(--theme-200);
  --item-hover-bg-color: var(--theme-100);
  --search-hit-text-bg-color: var(--theme-200);
  --search-hit-text-font-color: inherit;
  --search-select-text-color: var(--select-text-font-color);
  --search-select-bg-color: var(--select-text-bg-color);

  --blur-text-color-inverted: var(--theme-500);
  --panel-border-color-inverted: var(--theme-700);
  --active-file-bg-color-inverted: var(--theme-700);
  --window-border-inverted: 1px solid var(--theme-700);
  --search-hit-text-bg-color-inverted: var(--theme-700);
  --search-hit-text-font-color-inverted: var(--theme-0);
  --search-select-bg-color-inverted: var(--theme-400);
  --rawblock-edit-panel-bd: var(--tw-prose-pre-bg);
  --item-hover-bg-color-inverted: var(--theme-700);

  --monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", "Courier New", monospace;

  /* Custom */
  --footnote: var(--tw-prose-body);
  /* I'd love to use the --theme grayscale for --footnote-bg, but there's (currently)
  no way to add an alpha-channel to a CSS variable (and we need the transparency
  because otherwise the caret wil not be visible), so I here just used a hardcoded
  copy of --theme-500 */
  --footnote-bg: #94a3b855;
  --button-bg: var(--theme-200);

  --button-bg-inverted: var(--theme-600);

  --md-grid-header: var(--theme-100);
  --md-grid-header-ext: var(--theme-400);
  --md-grid-ext: var(--theme-300);
  --md-grid-header-active: var(--theme-500);
  --md-grid-active: var(--theme-400);
  --md-grid-border-color: var(--theme-500);

  --md-grid-header-inverted: var(--theme-600);
  --md-grid-header-ext-inverted: var(--theme-500);
  --md-grid-ext-inverted: var(--theme-600);
  --md-grid-header-active-inverted: var(--theme-400);
  --md-grid-active-inverted: var(--theme-500);
  --md-grid-border-color-inverted: var(--theme-200);

  --code-blocks-font-size: 0.9em;
  --inline-code-font-size: 0.9em;
}

.ty-file-search-match-text {
  background-color: var(--search-hit-text-bg-color);
}

/* TAILWIND RESET */

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: currentColor;
  /* 2 */
}

::before,
::after {
  --tw-content: "";
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
*/

#text {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
  tab-size: 4;
  /* 3 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

#text {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

#write {
    background: #131b29;
    color: #a9aaab;
    margin: 0 auto;
    max-width: 800px;
    padding: 30px;
    padding-bottom: 100px;
    position: static;
    width: 90%;
}

#write>ul:first-child,
#write>ol:first-child {
    margin-top: 30px;
}

a {
    color: #71bfd9;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    cursor: text;
    font-weight: bold;
    line-height: 1.4;
    margin-bottom: 1rem;
    margin-top: 1rem;
    position: relative;
}

#write h1,
#write h2,
#write h3,
#write h4,
#write h5,
#write h6,
#write pre {
    color: #dfb057;
    width: auto;
}

#write h1::before,
#write h2::before,
#write h3::before,
#write h4::before,
#write h5::before,
#write h6::before {
    border-radius: 0;
    bottom: 0;
    color: #517090;
    float: none;
    font-size: 1rem;
    font-variant: 'small-caps';
    font-weight: bold;
    left: auto;
    line-height: 20px;
    padding: 0;
    position: absolute;
    right: calc(100% + 10px);
    vertical-align: baseline;
}

#write h1 {
    font-size: 3.2rem;
    margin: 3rem 0;
    text-align: center;
}

#write h1::before {
    bottom: 1.45rem;
    content: 'H1';
}

#write h2 {
    font-size: 2.2rem;
    margin: 1.4rem 0;
}

#write h2::before {
    bottom: 0.2rem;
    content: 'H2';
}

#write h3 {
    font-size: 2rem;
    margin: 1rem 0;
}

#write h3::before {
    bottom: 0.18rem;
    content: 'H3';
}

#write h4 {
    font-size: 1.7rem;
    margin: 0.8rem 3;
}

#write h4::before {
    content: 'H4';
    bottom: 0.15rem;
}

#write h5 {
  font-size: 1.5rem;
  margin: 0.5rem 0;
}

#write h6 {
    font-size: 1.3rem;
    margin: 0.2rem,0;
}

#write h5::before,
#write h6::before {
    bottom: 0.1rem;
}

#write h5::before {
    content: 'H5';
}

#write h6::before {
    content: 'H6';
}

h1::after, h2::after {
  content: ""; /* 必须设置 content */
  display: block; /* 确保伪元素占据一行 */
  border-bottom: 2px solid #ccc; /* 分割线样式：颜色为灰色，厚度为 1px */
  margin-top: 4px; /* 分割线与标题的间距 */
  margin-bottom: 8px; /* 分割线与下文的间距 */
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
  font-family: "LXGWWenKai-Blod";
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured `mono` font family by default.
2. Correct the odd `em` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: var(--monospace);
  /* 1 */
  font-size: 1em;
  /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  line-height: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/* TAILWIND PROSE IMPLEMENTATION */

#write {
  font-size: 1.25rem;
  line-height: 1.625rem;
  max-width: 80rem;
}

html,
body {
  font-family: "LXGWWenKai-Regular";
}

/* on Windows/Linux, it is the part that is not titlebar or status bar. */
content,
titlebar {
  background: var(--tw-prose-bg);
}

#write {
  padding-top: 100px;
  padding-bottom: 100px;
  color: var(--tw-prose-body);
  max-width: 60ch;
}

#write > :where(:first-child) {
  margin-top: 0;
}

#write > :where(:last-child) {
  margin-bottom: 0;
}

/**
  * ---------------------
  * Block Elements
  */

/* yaml */
pre.md-meta-block {
  color: var(--tw-prose-meta);
  background-color: var(--tw-prose-meta-bg);
  font-weight: 400;
  font-size: var(--code-blocks-font-size);
  line-height: 1.7777778;
  border-radius: 0.5rem /* 8px */;
  padding: 1.1111111em 1.3333333em;
  margin-bottom: 2.8em;
}

/* headings */
h1 {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.5rem;
  margin-top: 0;
  margin-bottom: 1.5rem;
  line-height: 2.75rem;
  letter-spacing: -1.5px;
}

h1 strong {
  font-weight: 900;
}

h2 {
  color: var(--tw-prose-headings);
  font-weight: bold;
  font-size: 1.63rem;
  margin-top: 1.5555556em;
  margin-bottom: 1.5rem;
  line-height: 1.875rem;
  letter-spacing: -1px;
}

h2 strong {
  font-weight: 800;
}

h3 {
  color: var(--tw-prose-headings);
  font-weight: bold;
  font-size: 1.17rem;
  margin-top: 1.6em;
  margin-bottom: 1.5rem;
  line-height: 1.5rem;
  letter-spacing: -1px;
}

h3 strong {
  font-weight: 700;
}

h4 {
  color: var(--tw-prose-headings);
  font-size: 1.12rem;
  font-weight: 600;
  margin-top: 1.8em;
  margin-bottom: 1.5rem;
  line-height: 1.375rem;
}

h4 strong {
  font-weight: 700;
}

h2 code {
  font-size: 0.8611111em;
}

h3 code {
  font-size: 0.9em;
}

h2 + * {
  margin-top: 0;
}

h3 + * {
  margin-top: 0;
}

h4 + * {
  margin-top: 0;
}

h5 {
  font-size: 0.97rem;
  line-height: 1.25rem;
  margin-bottom: 1.5rem;
  font-weight: bold;
}

h6 {
  font-size: 0.93rem;
  line-height: 1rem;
  margin-bottom: 0.75rem;
}

/* table */

table {
  width: 100%;
  table-layout: auto;
  text-align: left;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.9em;
  line-height: 1.5555556;
}

/* table header */

thead {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}

thead th {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-right: 0.6666667em;
  padding-bottom: 0.8888889em;
  padding-left: 0.6666667em;
}

thead th:first-child {
  padding-left: 0;
}

thead th:last-child {
  padding-right: 0;
}

tbody tr {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}

tbody tr:last-child {
  border-bottom-width: 0;
}

tbody td {
  vertical-align: baseline;
  padding-top: 0.8888889em;
  padding-right: 0.6666667em;
  padding-bottom: 0.8888889em;
  padding-left: 0.6666667em;
}

tbody td:first-child {
  padding-left: 0;
}

tbody td:last-child {
  padding-right: 0;
}

.md-grid-board tr[row="1"] {
  background-color: var(--md-grid-header);
}

.md-grid-board a:hover,
.md-grid-board a.md-active {
  background: var(--md-grid-active);
}

.md-grid-board tr[row="1"] a:hover,
.md-grid-board tr[row="1"] a.md-active {
  background: var(--md-grid-header-active);
}

.md-grid-board .md-grid-ext {
  background: var(--md-grid-ext);
}

.md-grid-board tr[row="1"] .md-grid-ext {
  background: var(--md-grid-header-ext);
}

.md-grid-board a {
  border-color: var(--md-grid-border-color) !important;
}

/* lists */

ol {
  list-style-type: decimal;
  padding-left: 1em;
}

li {
  margin-top: 0.6em;
  margin-bottom: 0.6em;
}

ul {
  list-style-type: disc;
  padding-left: 1em;
}

#write ul.task-list {
  padding-left: 0;
}

#write li.task-list-item {
  padding-left: 0.4em;
}

#write input[type="checkbox"] {
  margin-left: -1em;
}

input[checked] ~ * {
  opacity: 0.7;
  text-decoration: line-through;
}

ol > li::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}

ul > li::marker {
  color: var(--tw-prose-bullets);
}

ul > li,
ol > li {
  padding-left: 0.4em;
}

ul > li p,
ol > li p {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}

#write > ul > li > :not(input):first-child,
#write > ol > li > :not(input):first-child,
#write > ul > li > input + *,
#write > ol > li > input + * {
  margin-top: 1.2em;
}

#write > ul > li > *:last-child,
#write > ol > li > *:last-child {
  margin-bottom: 1.2em;
}

#write ul > li > p:only-child,
#write ol > li > p:only-child,
#write ul > li > input + p:last-child,
#write ol > li > input + p:last-child {
  margin-top: 0;
  margin-bottom: 0;
}

ul ul,
ul ol,
ol ul,
ol ol {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}

/* blockquote */
blockquote {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-left-width: 0.25rem;
  border-left-color: var(--tw-prose-quote-borders);
  quotes: "\201C""\201D""\2018""\2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-left: 1.0666667em;
}

blockquote p:first-of-type::before {
  content: open-quote;
}

blockquote p:last-of-type::after {
  content: close-quote;
}

/* hr */
hr {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
}

[mdtype="hr"] {
  margin-top: 2.8em;
  margin-bottom: 2.8em;
}

p {
  margin-top: 1.2em;
  margin-bottom: 1.2em;
  color: #eeeeee;
}

.in-text-selection,::selection {
  background-color: var(--select-text-bg-color);
}

/* diagram panel */
.md-diagram-panel {
  color: var(--tw-prose-body);
}

.enable-diagrams .md-diagram .code-tooltip {
  bottom: -1.9em;
  right: 0;
}

.md-fences-adv-panel {
  margin-top: 1.3em;
}

/* footnote definition */
sup.md-footnote {
  color: var(--footnote);
  background-color: var(--footnote-bg);
}

.footnotes {
  font-size: 0.85em;
}

.md-reverse-footnote-area a {
  font-family: "LXGWWenKai-Regular";
  text-decoration: none;
  color: var(--tw-primary);
  border-radius: 3px;
}

.md-hover-tip .code-tooltip-content {
  font-size: 1.05rem;
  line-height: 1.6;
  padding: 0.8em 1.2em;
}

.md-reverse-footnote-area a:hover {
  background-color: var(--item-hover-bg-color);
}

.md-def-name:before {
  color: var(--md-char-color);
}

.md-rawblock.md-rawblock-on-edit,
.md-rawblock:hover {
  color: var(--tw-prose-pre-code);
}

.md-inline-math script {
  color: var(--tw-prose-code);
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: var(--tw-highlight-color) !important;
}

g[data-mml-node="merror"] > g {
  fill: #000 !important;
  stroke: #000 !important;
}

.code-tooltip {
  color: var(--tw-prose-pre-code);
}

.code-tooltip .md-mathjax-preview {
  color: var(--tw-prose-body);
}

.md-htmlblock-container,
.md-rawblock-input.md-rawblock-control,
.md-htmlblock-panel.md-rawblock-control,
.md-math-container {
  border-radius: 0.5rem 0 0.5rem 0.5rem;
}

.md-rawblock-input {
  font-size: var(--code-blocks-font-size);
  padding: 0 1.3333333em;
}

.md-mathblock-panel .md-rawblock-input.md-rawblock-control {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-radius: 0;
}

.md-mathblock-panel .md-rawblock-before {
  padding-top: 1.1em;
  border-top-left-radius: 0.5rem;
}

.md-mathblock-panel .md-rawblock-after {
  padding-bottom: 1.1em;
  border-bottom-left-radius: 0.5rem;
  border-bottom-right-radius: 0.5rem;
}

.md-htmlblock-panel .md-rawblock-input {
  padding-top: 1.1111111em;
  padding-bottom: 1.1111111em;
}

.md-mathblock-panel .md-rawblock-before,
.md-mathblock-panel .md-rawblock-after {
  font-size: var(--code-blocks-font-size);
  padding-left: calc(4px + 1.3333333em);
  color: var(--code-bracket);
}

.md-rawblock-tooltip {
  color: var(--tw-prose-pre-code);
  border-radius: 0.5rem 0.5rem 0 0;
}

.md-rawblock-tooltip-name {
  opacity: 1;
}

.md-comment {
  font-size: var(--inline-code-font-size);
  color: var(--code-comment);
}

.md-raw-inline,
.md-tag,
[md-inline="linebreak"],
.md-image > .md-meta,
.md-inline-math.md-expand > .md-inline-math-container {
  font-size: var(--code-blocks-font-size);
}

/**
  * Code Fences
  * see http://support.typora.io/Code-Block-Styles
  */

.md-fences {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  font-weight: 400;
  font-size: var(--code-blocks-font-size);
  line-height: 1.7777778;
  margin-top: 2em;
  margin-bottom: 2em;
  border-radius: 0.5rem /* 8px */;
  padding: 1.1111111em 1.3333333em;
}

.md-fences.md-focus {
  border-bottom-right-radius: 0;
}

.md-fences > .code-tooltip {
  height: 1.8rem;
  bottom: -1.8rem;
  font-size: 0.9rem;
  border-radius: 0 0 0.5rem 0.5rem;
}

.code-tooltip .ty-input {
  min-width: 10rem;
}

pre code {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}

pre code::before {
  content: none;
}

pre code::after {
  content: none;
}

/* SYNTAX HIGHLIGHTING */

:root {
  --code-neutral: var(--theme-800);
  --code-cursor: var(--theme-900);
  --code-string: rgb(14, 165, 233); /* sky-500 */
  --code-number: rgb(245, 158, 11); /* amber-500 */
  --code-tag: rgb(236, 72, 153); /* pink-500 */
  --code-color: rgb(154, 154, 154);
  --code-color-bg: rgb(213, 213, 205);
  --code-variable: var(--theme-700);
  --code-operator: var(--theme-600);
  --code-comment: var(--theme-500);
  --code-bracket: var(--theme-500);
  --code-citation: var(--theme-500);

  --code-neutral-inverted: var(--theme-100);
  --code-cursor-inverted: var(--theme-50);
  --code-string-inverted: #7dd4fc; /* sky-300 */
  --code-number-inverted: #fde68a; /* amber-100 */
  --code-tag-inverted: #f472b5; /* pink-400 */
  --code-variable-inverted: var(--theme-200);
  --code-operator-inverted: var(--theme-400);
  --code-comment-inverted: var(--theme-400);
  --code-bracket-inverted: var(--theme-500);
  --code-citation-inverted: var(--theme-400);
}

#write .cm-s-inner {
  --code-neutral: var(--code-neutral-inverted);
  --code-cursor: var(--code-cursor-inverted);
  --code-string: var(--code-string-inverted);
  --code-number: var(--code-number-inverted);
  --code-tag: var(--code-tag-inverted);
  --code-variable: var(--code-variable-inverted);
  --code-operator: var(--code-operator-inverted);
  --code-comment: var(--code-comment-inverted);
  --code-bracket: var(--code-bracket-inverted);
  --code-citation: var(--code-citation-inverted);
}

.CodeMirror-selectedtext {
  background-color: transparent;
}
.CodeMirror-cursor {
  border-left: 1px solid var(--code-cursor) !important;
}
.CodeMirror-gutters {
  border-color: var(--code-comment);
}
.cm-s-inner span.cm-string {
  color: var(--code-string);
}

.cm-s-inner span.cm-number {
  color: var(--code-number);
}

.cm-s-inner span.cm-tag,
.cm-s-inner span.cm-keyword,
.cm-s-inner span.cm-qualifier {
  color: var(--code-tag);
}

.cm-s-inner .CodeMirror-guttermarker,
.cm-s-inner .CodeMirror-guttermarker-subtle,
.cm-s-inner span.cm-comment.cm-def,
.cm-s-inner span.cm-comment.cm-type,
.cm-s-inner span.cm-builtin,
.cm-s-inner span.cm-type,
.cm-s-inner span.cm-header,
.cm-s-inner span.cm-link,
.cm-s-inner span.cm-error {
  background: transparent;
  color: var(--code-neutral);
}

.cm-s-inner span.cm-attribute,
.cm-s-inner span.cm-property,
.cm-s-inner span.cm-variable,
.cm-s-inner span.cm-variable-2,
.cm-s-inner span.cm-variable-3,
.cm-s-inner span.cm-type,
.cm-s-inner span.cm-atom,
.cm-s-inner span.cm-def {
  color: var(--code-variable);
}
.cm-s-inner span.cm-comment,
.cm-s-inner .CodeMirror-linenumber {
  color: var(--code-comment);
}
.cm-s-inner span.cm-operator {
  color: var(--code-operator);
}
.cm-s-inner span.cm-bracket,
.cm-s-inner span.cm-tag.cm-bracket,
.cm-s-inner span.cm-meta {
  color: var(--code-bracket);
}

.cm-s-inner span.cm-link {
  text-decoration: underline;
}

/**
  * Inline Elements
  */

/* basic styles */

code {
  color: rgb(47, 206, 47);
  background-color: var(--code-color-bg);
  border-radius: 0.3rem;
  padding: 0.1rem 0.3rem;
  margin: 0.1rem 0.1rem;
}

code::before {
  content: none;
}

code::after {
  content: none;
}

[md-inline="code"].md-expand > code::before,
[md-inline="code"].md-expand > code::after {
  content: "";
}

a code {
  color: var(--tw-prose-links);
}

mark code {
  color: inherit;
}

strong {
  color: rgb(211, 211, 77);
  font-weight: 600;
}

a {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}

/* A block-level image should have a total top and bottom margin of 2em.
It is always wrapped in a paragraph with 1.2em vertical margin, hence we
add 0.8 here */
p > .md-image:only-child {
  margin-top: 0.8em !important;
  margin-bottom: 0.8em !important;
}

.md-image > .md-meta {
  color: var(--tw-prose-code);
}

/* extend styles */

mark {
  border-radius: 3px;
  padding: 0 2px;
  background-color: var(--tw-highlight-color);
}

/**
  * Source Code Mode
  * see http://support.typora.io/Code-Block-Styles
  */

.cm-s-typora-default .CodeMirror-activeline-background {
  background-color: var(--item-hover-bg-color);
}

#typora-source {
  font-family: var(--monospace);
  color: var(--typora-source-body);
}

#typora-source .cm-header {
  color: var(--code-tag);
}

#typora-source .cm-link {
  color: var(--code-string);
}

#typora-source .cm-string {
  color: var(--code-string);
}

#typora-source .cm-comment {
  color: var(--code-comment);
}

#typora-source .cm-atom {
  color: var(--code-citation);
}

#typora-source .cm-tag {
  color: var(--code-tag);
}

#typora-source .cm-attribute {
  color: var(--code-variable);
}

#typora-source .cm-bracket {
  color: var(--code-bracket);
}

.file-list-item-file-ext-part {
  opacity: 0.5;
}

#write div.md-toc-tooltip {
  background-color: var(--tw-prose-bg);
}

.md-toc {
  font-size: 0.8em;
}

.md-toc-h1 .md-toc-inner {
  margin-left: 0;
}

.md-toc-h2 .md-toc-inner {
  margin-left: 1em;
}

.md-toc-h3 .md-toc-inner {
  margin-left: 2em;
}

.md-toc-h4 .md-toc-inner {
  margin-left: 3em;
}

.md-toc-h5 .md-toc-inner {
  margin-left: 4em;
}

.md-toc-h6 .md-toc-inner {
  margin-left: 5em;
}

#typora-sidebar {
  border-right: var(--window-border);
}

.sidebar-tab {
  text-transform: none;
  font-weight: 700;
  font-size: 1.1em;
}

.md-search-hit {
  color: var(--search-hit-text-font-color);
  background-color: var(--search-hit-text-bg-color);
}

#md-searchpanel {
  box-shadow: none;
  filter: var(--tw-drop-shadow-md);
}

#md-searchpanel .btn:not(.close-btn):hover {
  box-shadow: none;
  -webkit-box-shadow: none;
  background-color: var(--tw-button-hover-bg);
}

#md-searchpanel input,
#md-searchpanel .btn,
#searchpanel-msg {
  border-radius: 5px;
}

#searchpanel-msg {
  color: var(--theme-500);
  border-color: var(--theme-300);
  background: var(--theme-100);
}

.form-control {
  border-color: var(--panel-border-color);
}

.btn-default {
  background-color: var(--button-bg);
}

/* you can override the default max-width size here or override each style by your custom css */

#write {
    font-size: 1.25rem;
    line-height: 1.625rem;
    max-width: 80rem;
}

p {
    line-height: 2rem;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875em;
}
@import "";
@import "";
@import "";

:root {
  --tw-prose-body: var(--tw-prose-invert-body);
  --tw-prose-headings: var(--tw-prose-invert-headings);
  --tw-prose-lead: var(--tw-prose-invert-lead);
  --tw-prose-links: var(--tw-prose-invert-links);
  --tw-prose-bold: var(--tw-prose-invert-bold);
  --tw-prose-counters: var(--tw-prose-invert-counters);
  --tw-prose-bullets: var(--tw-prose-invert-bullets);
  --tw-prose-hr: var(--tw-prose-invert-hr);
  --tw-prose-quotes: var(--tw-prose-invert-quotes);
  --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
  --tw-prose-code: var(--tw-prose-invert-code);
  --tw-prose-captions: var(--tw-prose-invert-captions);
  --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
  --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
  --tw-prose-td-borders: var(--tw-prose-invert-td-borders);
  --tw-prose-bg: var(--tw-prose-invert-bg);
  --tw-prose-meta: var(--tw-prose-invert-meta);
  --tw-prose-meta-bg: var(--tw-prose-invert-meta-bg); 
  --select-text-bg-color: rgb(35, 92, 197);

  --tw-button-hover-bg: var(--tw-button-hover-bg-inverted);

  --md-char-color: var(--md-char-color-inverted);
  --meta-content-color: var(--meta-content-color-inverted);
  --panel-border-color: var(--panel-border-color-inverted);
  --active-file-bg-color: var(--active-file-bg-color-inverted);
  --window-border: var(--window-border-inverted);
  --search-hit-text-bg-color: var(--search-hit-text-bg-color-inverted);
  --search-hit-text-font-color: var(--search-hit-text-font-color-inverted);
  --search-select-bg-color: var(--search-select-bg-color-inverted);
  --blur-text-color: var(--blur-text-color-inverted);
  --item-hover-bg-color: var(--item-hover-bg-color-inverted);
  --typora-source-body: var(--typora-source-body-inverted);
  --mermaid-theme: var(--mermaid-theme-inverted);
  --active-toggle-btn-color: var(--active-toggle-btn-color-inverted);

  --code-neutral: var(--code-neutral-inverted);
  --code-cursor: var(--code-cursor-inverted);
  --code-string: var(--code-string-inverted);
  --code-number: var(--code-number-inverted);
  --code-tag: var(--code-tag-inverted);
  --code-variable: var(--code-variable-inverted);
  --code-operator: var(--code-operator-inverted);
  --code-comment: var(--code-comment-inverted);
  --code-bracket: var(--code-bracket-inverted);
  --code-citation: var(--code-citation-inverted);
  --code-color: rgb(237, 71, 89);
  --code-color-bg: rgb(32, 41, 58);

  --button-bg: var(--button-bg-inverted);

  --md-grid-header: var(--md-grid-header-inverted);
  --md-grid-header-ext: var(--md-grid-header-ext-inverted);
  --md-grid-ext: var(--md-grid-ext-inverted);
  --md-grid-header-active: var(--md-grid-header-active-inverted);
  --md-grid-active: var(--md-grid-active-inverted);
  --md-grid-border-color: var(--md-grid-border-color-inverted);
}



mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG2"] path[data-c], mjx-container[jax="SVG2"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}
mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
							stroke-width: 0;
						}
</style><title>计算机组成原理</title>
</head>
<body class='typora-export os-windows typora-export-show-outline typora-export-collapse-outline'><div class='typora-export-content'>
<div class="typora-export-sidebar"><div class="outline-content"><li class="outline-item-wrapper outline-h1"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#计算机组成原理">计算机组成原理</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h2 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#常见问题">常见问题</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#概述">概述</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#五大部件">五大部件</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#计算机软件">计算机软件</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#层次结构">层次结构</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#工作原理">工作原理</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#性能指标">性能指标</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#数据的表示与运算">数据的表示与运算</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#数制与编码">数制与编码</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#定点数的表示">定点数的表示</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#定点数运算方法">定点数运算方法</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#浮点数">浮点数</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#存储系统">存储系统</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#存储器的分类">存储器的分类</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#性能指标-2">性能指标</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#多层次的存储系统">多层次的存储系统</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#主存">主存</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#外存">外存</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#cache">Cache</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#虚拟存储器">虚拟存储器</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#指令系统">指令系统</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#基本格式">基本格式</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#定长操作码">定长操作码</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#扩展操作码">扩展操作码</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#指令的操作类型">指令的操作类型</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#寻址方式">寻址方式</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#程序的机器级代码表示">程序的机器级代码表示</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#cisc和risc">CISC和RISC</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#中央处理器">中央处理器</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#基本功能">基本功能</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#基本结构">基本结构</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#指令的执行">指令的执行</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#数据通路">数据通路</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#控制器">控制器</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#异常和中断">异常和中断</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#指令流水线">指令流水线</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#多处理机">多处理机</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线">总线</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线的概念">总线的概念</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线分类">总线分类</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#系统总线的结构">系统总线的结构</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#常见的总线标准">常见的总线标准</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线的性能指标">总线的性能指标</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线事务">总线事务</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#总线定时">总线定时</a></div><ul class="outline-children"></ul></li></ul></li><li class="outline-item-wrapper outline-h2"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#输入输出系统">输入输出系统</a></div><ul class="outline-children"><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#io接口">I/O接口</a></div><ul class="outline-children"></ul></li><li class="outline-item-wrapper outline-h4 outline-item-single"><div class="outline-item"><span class="outline-expander"></span><a class="outline-label" href="#io方式">I/O方式</a></div><ul class="outline-children"></ul></li></ul></li></ul></li></div></div><div id='write'  class=' first-line-indent'><h1 id='计算机组成原理'><span>计算机组成原理</span></h1><p>&nbsp;</p><h2 id='常见问题'><span>常见问题</span></h2><ul><li><p><span>透明是指看不到，和黑箱类似</span></p><ul><li><p><em><span>IR、MAR、MDR</span></em><span> 对各类程序员都透明</span></p></li></ul></li><li><p><span>时序逻辑电路</span></p><ul><li><p><span>类似于 RNN，其任意时刻的输出信号不仅和当时的输入有关，也和电路原来的状态有关</span></p></li><li><p><span>必然包含存储记忆单元，存储元件如各种寄存器（PC、IR、GPRs）等均为状态元件（时序逻辑）</span></p></li></ul></li><li><p><span>组合逻辑电路</span></p><ul><li><p><span>具有</span><em><span>非记忆性，信号传输是单向的</span></em><span>，输入和输出之间无反馈通路</span></p></li><li><p><span>ALU、多路选择器都是操作元件（组合逻辑）</span></p></li></ul></li><li><p><span>表示频率时，单位一般是十进制，而表示数据时，k 通常是10进制，K 通常是二进制</span></p></li><li><p><span>一个</span><em><span>汉字占2B</span></em><span>，一个英文</span><em><span>字母占1B</span></em></p></li><li><p><span>地址码大小决定地址空间大小，注意地址从 0 开始，故最高地址为</span><span class='math-in-toc'>$2^n-1$</span></p></li><li><p><em><span>PC 取指之后就已经+1了，执行某指令时PC已经指向下一条指令</span></em><span>。</span><em><span>+1表示本指令的字长（几B）</span></em><span>，其长度若是 CISC则必须视本指令长度而定</span></p></li><li><p><span>若同时给出了机器级代码、汇编代码，注意比较代码之间的差异从而找出一些关键信息</span></p></li><li><p><em><span>IR 长度 = 指令字长，PC = MAR = 地址线位数，MDR = 数据线位数=存储字长，ALU = 机器字长</span></em><span>，机器字长和数据线位数不一定相等，存储字长为一次访存可取出的位数，与编址方式无关</span></p></li><li><p><em><span>PC最小位数是内存中指令的个数，若指令字长比编址单位大，则PC位数可以小于地址个数</span></em></p></li><li><p><span>”表项“仅仅是某一行，不是整张表</span></p></li><li><p><span>TLB 和虚拟地址相关，Cache 和物理地址相关，先查 TLB 和页表将其转化为物理地址，再拿着物理地址去查Cache或主存</span></p></li><li><p><em><span>页号、页偏移都是高位补零！！！必须将其化为二进制！！！</span></em></p></li><li><p><span>十六进制别忘了加 H，和内存有关的偏移量用十六进制更好（题目用的啥就用啥）</span></p></li><li><p><span>延迟写同样可用提升文件访问速度（减少IO），是将数据写入缓冲区，若又要访问则可直接从缓冲区读入，仅当缓冲区又要被分配时才写回</span></p></li><li><p><span>CPU 在读 IO 寄存器时，是无法进行 IO 写入的，因此每隔一个写满寄存器的时间，CPU查询一次就可以了</span></p></li><li><p><span>区分 Cache 总容量和 Cache 数据区容量</span></p></li><li><p><span>仔细看图，图中可能会展示有几个比较器、有几位组号、组号伸出了几个箭头，由此可得到映射方式、Cache有几组、每组有几行</span></p></li><li><p><span>有关流水线数据冒险的问题：抓住一个关键点，就是前一条指令总是快后一条指令一个小段；且五段流水线中只有1（IR）、5（写回寄存器）段和主存与寄存器有关（具体题目可能有差异）</span></p></li><li><p><span>有PC和补码表示的偏移量要计算地址时，地址为正、结果为正，可以直接用补码计算</span></p></li><li><p><span class='math-in-toc'>$\%$</span><span>和</span><span class='math-in-toc'>$/$</span><span>的应用，前者是</span><em><span>取模，实际上是取被除数低位的n个数字</span></em><span>；</span><em><span>除法是右移n位，丢弃掉低的n位</span></em><span>，n为除数长度。例如求中间的页表索引：</span><span class='math-in-toc'>$(LA/2^{12})\%2^{12}$</span><span>得到12位数字（11到23位）</span></p></li><li><p><span>仅当 Cache 缺失时 CPU 才需要访存，主存最低带宽和缺页率（访存频率）有关</span></p></li><li><p><span>中断处理为最底层，总是最后调用</span></p></li><li><p><span>补/unsigned的加减都可以用同一套电路实现，减法可以a+(-b)</span></p></li><li><p><em><span>目的操作数</span></em><span>所在位置为存放结果的位置，</span><em><span>intel格式第 1 个为目标</span></em></p></li><li><p><span>中断屏蔽字决定的是中断</span><em><span>处理</span></em><span>顺序</span></p></li><li><p><span>逻辑地址形成于链接（模块合并）</span></p></li><li><p><span>若先访问Cache后主存，可算 全命中时长+缺失时额外时长（主存传输到Cache）</span></p></li><li><p><span>如果题目给了PC的计算公式，要看清楚！若转移指令偏移量为8位补码，最低表示-128，但PC已+1，故最多往后跳转127条指令。转移指令地址=</span><span class='math-in-toc'>$(PC)+1+偏移量*指令长度$</span><span>​，不同题目转移指令地址不一定相同</span></p></li><li><p><span>存储器由数个NxM位DRAM芯片组成，则数据线就是M根，而地址线由N决定，且采用复用技术减少一半，</span><em><span>和芯片个数无关</span></em><span>。片选线和芯片组成的个数有关</span></p></li><li><p><span>CPU速度提高50%，和提高100%是不同的</span></p></li><li><p><span>指令流水线中，某条指令的某一段被阻塞，后续所有指令均阻塞，比如前一条的ID阻塞，则后一条的IF也被阻塞。流水线注意看题目的说明，可能与教材有区别</span></p></li><li><p><span>CPU时钟周期以</span><em><span>最长</span></em><span>时间部件+寄存器延时决定</span></p></li><li><p><span>short 类型是有符号的</span></p></li><li><p><span>机器指令+微指令，都能理解并直接执行，但微指令不算计算机语言</span></p></li><li><p><span>注意页的大小，1KB 和 4KB 经常看走眼</span></p></li><li><p><span>带宽永远是理想状态、一直传数据的极限传输率</span></p></li></ul><p>&nbsp;</p><h2 id='概述'><span>概述</span></h2><p><span>冯·诺依曼机基本思想：存储程序，即按地址访问并顺序执行指令</span></p><p><span>以前的计算机以CPU为核心，</span><em><span>现代计算机以存储器（内存）为中心</span></em><span>，使I/O操作尽可能绕过CPU</span></p><h4 id='五大部件'><span>五大部件</span></h4><ul><li><p><span>输入、输出</span></p></li><li><p><span>存储器</span></p><ul><li><p><span>存储体</span></p><ul><li><p><span>由许多存储单元构成</span></p></li></ul></li><li><p><span>MAR 地址寄存器</span></p><ul><li><p><span>用于寻址，其位数和存储单元个数有关，也</span><em><span>和 PC 长度相等</span></em></p></li></ul></li><li><p><span>MDR 数据寄存器</span></p><ul><li><p><span>用于暂存数据，</span><em><span>长度和存储字长相等</span></em></p></li></ul></li></ul></li><li><p><span>运算器</span></p><ul><li><p><span>ALU 算术逻辑单元</span></p></li><li><p><span>ACC 累加器、X 操作数寄存器、PSW 程序状态寄存器、IX 变址寄存器、BR 基址寄存器、MQ 乘商寄存器</span></p></li><li><p><span>用于算术运算和逻辑运算</span></p></li></ul></li><li><p><span>控制器</span></p><ul><li><p><span>PC 程序计数器</span></p><ul><li><p><span>自动+1，用于存放当前欲执行的指令地址</span></p></li><li><p><em><span>下一条指令总是由PC给出（包括转移指令）</span></em></p></li></ul></li><li><p><span>IR 指令寄存器</span></p><ul><li><p><span>其内容</span><em><span>来自主存的 MDR</span></em></p></li><li><p><em><span>OP(IR) 送至 CU，用于生成微操作命令，Ad(IR)送往MAR，用于取操作数</span></em></p></li><li><p><em><span>IR长度等于指令字长</span></em></p></li></ul></li><li><p><span>CU控制单元</span></p><ul><li><p><span>用于接受OP，生成微操作命令</span></p></li></ul></li></ul></li></ul><h4 id='计算机软件'><span>计算机软件</span></h4><ul><li><p><span>系统、应用软件，软硬件逻辑等价性</span></p><ul><li><p><span>数据库管理系统是系统应用，数据库系统是它的延伸，不是系统应用</span></p></li><li><p><span>编写操作系统、编译程序的是系统程序员</span></p></li></ul></li><li><p><span>三个级别的语言</span></p><ul><li><p><span>机器语言</span></p><ul><li><p><span>二进制，是计算机唯一可直接识别可执行的语言</span></p></li></ul></li><li><p><span>汇编语言</span></p><ul><li><p><span>用英文单词或缩写代替二进制的指令代码，注意它不是高级语言</span></p></li><li><p><span>使用汇编程序（汇编器）将汇编语言翻译成机器语言</span></p></li></ul></li><li><p><span>高级语言</span></p><ul><li><p><span>通常需要先编译成汇编语言再汇编成机器码</span></p></li><li><p><span>或直接解释为机器语言程序</span></p></li><li><p><span>解释不会生成文件</span></p></li></ul></li></ul></li></ul><h4 id='层次结构'><span>层次结构</span></h4><ul><li><p><span>高级语言层</span></p><ul><li><p><span>面向用户</span></p></li><li><p><span>在此之上还有应用程序层</span></p></li></ul></li><li><p><span>汇编语言层</span></p><ul><li><p><span>用汇编语言编程</span></p></li></ul></li><li><p><span>操作系统层</span></p><ul><li><p><span>位于软硬件交界处，机器语言解释操作系统</span></p></li><li><p><span>软硬件之间的借面就是指令集体系结构 ISA</span></p></li></ul></li><li><p><span>传统机器语言层</span></p><ul><li><p><span>微程序解释机器指令</span></p></li><li><p><span>这一级往下是硬件层</span></p></li></ul></li><li><p><span>微程序机器层</span></p><ul><li><p><span>机器硬件直接执行微指令</span></p></li></ul></li></ul><h4 id='工作原理'><span>工作原理</span></h4><ul><li><p><em><span>存储程序</span></em><span>工作原理</span></p><ul><li><p><span>程序执行前将程序的指令和数据送入主存</span></p></li><li><p><span>指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应该能区分它（</span><em><span>从指令执行的不同阶段区分</span></em><span>）</span></p></li><li><p><span>一旦程序开始执行，就无需干预</span></p></li></ul></li><li><p><span>源程序到可执行文件</span></p><ol start='' ><li><p><span>预处理阶段</span></p><ul><li><p><span>处理 </span><span>#</span><span> 开头的命令，生成 .i 为扩展名的文件</span></p></li></ul></li></ol><ol start='2' ><li><p><span>编译阶段</span></p><ul><li><p><span>编译器编译，生成汇编语言原程序 .s</span></p></li></ul></li></ol><ol start='3' ><li><p><span>汇编阶段</span></p><ul><li><p><span>汇编器将汇编语言翻译成机器语言，生成 .o 文件</span></p></li></ul></li></ol><ol start='4' ><li><p><span>链接阶段</span></p><ul><li><p><span>将多个 .o 文件和标准库函数进行链接生成可执行文件</span></p></li></ul></li></ol></li><li><p><span>程序执行过程的描述</span></p><ul><li><p><span>必须依靠操作系统的支持（内核）</span></p></li></ul></li><li><p><span>指令执行过程的描述</span></p><ol start='' ><li><p><span>取指令</span></p></li></ol><ul><li><p><em><span>PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</span></em></p></li><li><p><span>根据 PC 取指令到 IR</span></p></li></ul><ol start='2' ><li><p><span>分析指令</span></p></li></ol><ul><li><p><em><span>OP(IR)-&gt;CU</span></em></p></li><li><p><span>指令译码并送出控制信号</span></p></li></ul><ol start='3' ><li><p><span>执行指令</span></p></li></ol><ul><li><p><em><span>Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</span></em></p></li><li><p><span>取数送到ACC中，且PC+1</span></p></li></ul></li></ul><h4 id='性能指标'><span>性能指标</span></h4><ul><li><p><span>字长、主存容量、数据带宽、基准程序等</span></p></li><li><p><span>时钟周期以相邻状态单元之间的组合逻辑电路的最大延迟或指令流水线每个流水段的最大延迟确定</span></p></li><li><p><span>运算速度</span></p><ul><li><p><span>吞吐量：单位时间内能处理请求的数目，取决于信息能多快输入内存，因此主要取决于主存存取周期</span></p></li><li><p><span>主频：时钟周期的倒数</span></p></li><li><p><em><span>CPI：执行一条指令所需的时钟周期数</span></em></p></li><li><p><em><span>MIPS：每秒执行多少百万条指令</span></em></p></li><li><p><span>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOP，从10的6次方一直到10的21次方，每个隔了10的3次方。MFLOPS表示每秒多少百万次浮点运算（TPEZ）</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='数据的表示与运算'><span>数据的表示与运算</span></h2><h4 id='数制与编码'><span>数制与编码</span></h4><ul><li><p><span>二进制 0b、八进制 0c、</span><em><span>十六进制 0x</span></em><span>，这些符号是放在数前面的，若没有这些符号而在数的末尾有B、O、H，同样是表示这些进制</span></p></li><li><p><span>带符号数常以十六进制存储</span></p></li><li><p><span>一个进位数的大小就是</span><em><span>各位数码按权相加</span></em></p></li><li><p><span>任意一个二进制小数可以用十进制表示，但反过来不一定，如0.3</span></p></li><li><p><span>进制的转换</span></p><ul><li><p><span>二进制化8/16进制：</span><em><span>以3/4个数为一组，分别化为十进制，最后拼接起来</span></em></p></li><li><p><span>有小数和整数的，分别处理整数部分和小数部分</span></p></li><li><p><em><span>8/16进制化二进制：每个数化成3/4位二进制，最后拼接起来</span></em></p></li><li><p><em><span>任意进制化十进制：各位数码和权值相乘，小数则是负的权值</span></em></p></li><li><p><span>十进制化任意进制</span></p><ul><li><p><span>整数部分采用除基取余法</span></p><ul><li><p><span>最高位在最下面</span></p></li></ul></li><li><p><em><span>小数部分采用乘基取整法</span></em></p><ul><li><p><span>最高位在最上面，从上到下，乘积=1时停止</span></p></li></ul></li></ul></li></ul></li></ul><h4 id='定点数的表示'><span>定点数的表示</span></h4><ul><li><p><span>整数、小数表示</span></p><ul><li><p><span>无符号</span></p><ul><li><p><span>有符号数和无符号数同时参加运算，均视为无符号数</span></p></li></ul></li></ul></li><li><p><span>有符号</span></p></li><li><p><span>原码</span></p><ul><li><p><em><span>表示范围关于原点对称，有±0</span></em></p></li><li><p><span>正数原、反、补三码合一，负数反码为除符号位原码各位取反</span></p></li></ul></li><li><p><span>补码</span></p><ul><li><p><em><span>负数的补码为反码+1</span></em></p></li><li><p><span>由</span><span class='math-in-toc'>$[X]_补$</span><span>求</span><span class='math-in-toc'>$[-X]_补$</span><span>：</span><em><span>连同符号位取反再末尾+1（正负都是）</span></em></p></li><li><p><span>0 的表示唯一，负0变成了</span><span class='math-in-toc'>$-2^{n-1}$</span><span>，</span><em><span>补码全1表示-1</span></em></p></li><li><p><em><span>补码首位能直接运算</span></em><span>，不影响最后的结果</span></p></li><li><p><span>变形补码</span></p><ul><li><p><span>又称模4补码，和补码除了符号位外都一致</span></p></li><li><p><em><span>双符号位，但只存储1位</span></em></p></li><li><p><em><span>00表示正，11表示负，01和10表示溢出</span></em></p></li></ul></li><li><p><em><span>负数的补码，其数值部分越大，就越接近于0</span></em></p></li></ul></li><li><p><span>移码</span></p><ul><li><p><em><span>补码的符号位取反即得移码（正负数都是）</span></em></p></li><li><p><span>只能表示整数，0 的表示唯一</span></p></li><li><p><span>移码全0表示最小值</span><span class='math-in-toc'>$-2^{n-1}$</span></p></li></ul></li><li><p><em><span>原码反码表示的区间数轴对称，补码移码则不是</span></em></p></li><li><p><span>无符号整数（unsigned int）的表示</span></p><ul><li><p><span>没有符号位，因此表示范围更大</span></p></li><li><p><em><span>可用无符号整数进行地址运算，或用其表示指针</span></em></p></li></ul></li><li><p><span>带符号整数的表示</span></p><ul><li><p><span>将符号数字化，计算机中用补码来表示带符号数</span></p></li></ul></li><li><p><span>注意：若选择题要判断 x 的正负，不能忘记 0 这个特殊存在</span></p></li></ul><h4 id='定点数运算方法'><span>定点数运算方法</span></h4><ul><li><p><span>部件</span></p><ul><li><p><span>一位全加器</span></p><ul><li><p><span>有加数</span><span class='math-in-toc'>$A$</span><span>、加数</span><span class='math-in-toc'>$B$</span><span>及低位的进位</span><span class='math-in-toc'>$C_{i-1}$</span><span>共</span><em><span>三个输入</span></em></p></li><li><p><span>有本位和</span><span class='math-in-toc'>$S$</span><span>、向高位的进位</span><span class='math-in-toc'>$C_i$</span><span>共</span><em><span>两个输出</span></em></p></li><li><p><span>和表达式</span><span class='math-in-toc'>$S=A(XOR)B(XOR)C$</span></p><ul><li><p><span>这里 XOR 表示异或操作，用带圈的加号表示</span></p></li></ul></li><li><p><span>进位表达式</span><span class='math-in-toc'>$C_i=AB+(A(XOR)B)C_{i-1}$</span></p></li></ul></li><li><p><span>串行进位加法器</span></p><ul><li><p><span>n个全加器相连</span></p></li><li><p><span>每级进位直接依赖于前一级的进位，即进位信号是逐级形成的</span></p></li></ul></li><li><p><span>并行进位加法器</span></p><ul><li><p><span>在全加器的进位表达式中，</span><span class='math-in-toc'>$AB$</span><span> 称为进位产生函数，</span><span class='math-in-toc'>$A(XOR)B$</span><span> 称进位传递函数</span></p></li><li><p><span>是一种并行加法器</span></p></li></ul></li><li><p><span>带标志加法器</span></p><ul><li><p><span>溢出标志表达式</span><span class='math-in-toc'>$OF=C_n(XOR)C_{n-1}$</span><span>，即</span><em><span>最高位进位和次高位进位不同则溢出</span></em></p></li></ul></li><li><p><span>阵列乘法器等其它专用部件</span></p><ul><li><p><span>硬件实现的运算，</span><em><span>只需一个clock即可完成乘法运算，速度最快</span></em></p></li><li><p><span>编译器能将乘法运算转化为循环+加减法+移位，因此可用实现乘法运算（软件实现），但速度慢</span></p></li></ul></li><li><p><span>ALU 算术逻辑单元</span></p><ul><li><p><span>核心是带标志加法器</span></p></li><li><p><span>可执行算术、逻辑和移位运算</span></p></li><li><p><span>注意：当A-B时，由于等价于A+[-B]，故要让B的补码包括符号全部取反再+1，</span><em><span>实际上加法器的两个输出就是A和取反后的B，+1是作为低位进位的</span></em></p></li><li><p><span>ALUop 为控制信号，用于决定 ALU 功能，n位 ALUop 可有</span><span class='math-in-toc'>$2^n$</span><span>种操作（本质是输入到多路选择器MUX中，将结果视为不同的形式，如无符号或有符号等）</span></p></li><li><p><span>ALU生成标志位时只负责计算而不管是否有符号：</span><em><span>CF=1表示无符号数运算的溢出，OF=1表示有符号的溢出</span></em><span>，相当于</span><em><span>一次运算得到的结果可分别视为有/符号位数的结果</span></em></p><ul><li><p><span>补码（带符号数）是连着符号一起算，因此结果的</span><em><span>最高位就是符号标志SF</span></em></p></li><li><p><span>溢出判断：</span><em><span>加法中，仅同正、同负两种情况可能出现溢出</span></em><span>，OF逻辑表达式根据两个操作数、结果的最高位可得到</span></p></li><li><p><span>减法和加法类似，仅一正一负或一负一正才可能</span></p></li><li><p><em><span>带符号整数乘法，若 ALU 采用 64 位存储结果，则高 33 位若不完全相同（有0有 1）则表示溢出</span></em></p></li></ul></li></ul></li></ul></li><li><p><span>移位运算</span></p><ul><li><p><span>算术移位</span></p><ul><li><p><span>对象是</span><em><span>有符号数</span></em><span>，</span><em><span>符号跟着移动，但移位时符号必须保持不变</span></em></p></li><li><p><span>由于计算机都是补码表示数据，因此</span><em><span>左移补0，右移补符号位</span></em><span>（左零右符）</span></p></li><li><p><span>左移出的符号位不同于新符号位，则发生溢出，因此</span><em><span>补码左移的前提是最高位与符号位相同</span></em><span>；右移移出1则影响精度</span></p></li><li><p><em><span>变形补码只有低位符号参加移位</span></em><span>，高位符号是真实符号</span></p></li></ul></li><li><p><span>逻辑移位</span></p><ul><li><p><em><span>视为无符号数，均添0</span></em></p></li><li><p><span>高位左移出1，则溢出</span></p></li></ul></li><li><p><span>循环移位</span></p><ul><li><p><span>高位放到低位，低位放到高位</span></p></li><li><p><span>大循环：带进位标志位 CF 的循环移位</span></p></li><li><p><span>小循环：不带 CF 的循环移位</span></p></li><li><p><span>适合高低位数据的互换</span></p></li></ul></li></ul></li><li><p><span>加减运算</span></p><ul><li><p><span>补码加减法</span></p><ul><li><p><span>加法，则两数直接相加</span></p></li><li><p><em><span>减法，得到加数的负值的补码后再相加</span></em></p></li><li><p><span>无符号数加减法完全一致，其减法视为减去一个正数补码</span></p></li><li><p><span>加减运算电路</span></p><ul><li><p><span>第二个输入端 Y 加上n个反向器实现取反，再加上一个二路 MUX，用 sub 信号决定是输入 </span><span class='math-in-toc'>$Y$</span><span>还是</span><span class='math-in-toc'>$\overline{Y}$</span><span>​（同时sub作为低位输入到加法器）</span></p></li><li><p><span>ZF：均有意义</span></p></li><li><p><span>OF：有符号才有意义，结果等于符号位进位与最高数位进位的异或。因此某种意义上说，无符号不会发生溢出（实际上也会溢出）</span></p></li><li><p><span>SF：有符号才有意义</span></p></li><li><p><span>CF：无符号才有意义。减法时 CF=1 表示有借位0。加减法综合</span><span class='math-in-toc'>$CF=Sub⊕C_{out}$</span></p></li></ul></li></ul></li><li><p><span>原码加减法</span></p></li><li><p><span>溢出判别</span></p><ul><li><p><em><span>仅当两个符号相同的数相加或符号相异的数相减才可能产生溢出</span></em></p></li><li><p><span>无论是单符号位还是双符号位，</span><em><span>溢出判断必须有溢出判断电路</span></em><span>，用异或门实现</span></p></li><li><p><span>采用一位符号位</span></p><ul><li><p><span>若</span><em><span>参加运算的操作数符号相同，但结果符号不同，则表示溢出</span></em></p></li><li><p><span>溢出逻辑表达式</span><span class='math-in-toc'>$V=AB\overline{S}+\overline{AB}S$</span><span>，S为结果符号，A、B为操作数符号</span></p></li></ul></li><li><p><span>采用双符号位</span></p><ul><li><p><span>即模 4 补码，</span><em><span>01表示正溢出，10表示负溢出</span></em></p></li><li><p><span>双符号位只能便于检测加减运算中的问题，但不能避免溢出</span></p></li><li><p><em><span>仅在 ALU 中是双符号位，存储时仅是单符号位</span></em></p></li><li><p><span>溢出表达式</span><span class='math-in-toc'>$V=S_1⊕S_2$</span></p></li></ul></li><li><p><span>采用一位符号位，根据数据位的进位情况判断</span></p><ul><li><p><em><span>若符号位的进位与最高数位的进位相同则没有溢出</span></em><span>，否则溢出</span></p></li><li><p><span>逻辑表达式</span><span class='math-in-toc'>$V=C_{n-1}⊕C_n$</span></p></li><li><p><span>因为加减总化为加法，而此时两个符号相异是不会溢出的；若相同，则结果的符号位也必相同，不可能出现负+负结果为正吧？</span></p></li><li><p><span>若最高位进位了，符号位没进位，意味着必然是两个0+0的符号变成了1，故正溢出；若最高位没进位但符号位进位了，表示1+1变成了0，也是出错的</span></p></li></ul></li></ul></li></ul></li><li><p><span>乘除运算</span></p><ul><li><p><span>原码乘法（逻辑右移-累加）</span></p><ul><li><p><span>先</span><em><span>异或</span></em><span>算符号位</span></p></li><li><p><span>剩余部分视为无符号数，按二进制乘法计算结果</span></p></li><li><p><span>乘法电路</span></p><ul><li><p><span>控制逻辑 </span><span class='math-in-toc'>$C_n$</span><span> 控制右移计数，初始为32，每次右移-1</span></p></li><li><p><span>乘积寄存器 P 和乘积寄存器 Y 拼接成64位，被乘数放在Y中，P 初始全为0，ALU 控制 P 和乘数寄存器 X 做加法，并将结果送回 P，然后右移。Y 被移出的最低为被送到控制逻辑以决定被乘数是否加到 P 上面</span></p></li><li><p><span>因为加法可能产生进位，因此设置一个进位位 C 指向 P</span></p></li></ul></li><li><p><span>溢出判断</span></p><ul><li><p><span>两个 int 相乘，若高32位每一位都相同且等于32位的符号位，则不溢出，否则发生溢出</span></p></li><li><p><span>两个 unsigned，乘积高 32 全为0则不溢出，否则溢出</span></p></li></ul></li></ul></li><li><p><span>原码除法（逻辑左移-累加）</span></p><ul><li><p><span>先</span><em><span>异或</span></em><span>求商的符号，之后符号不参与运算，视为两个无符号数相除</span></p></li><li><p><span>除法统一为 2n 位被除数除以 n 位除数，得到一个 n 位的商。由于相除时为无符号数，故小数为低位添0，正整数为高位添0</span></p></li><li><p><span>手算二进制除法，本质上和十进制的基本一致</span></p></li><li><p><span>计算机内部的实现，需要加减，因此是以</span><em><span>补码</span></em><span>的形式实现的</span></p></li><li><p><span>除法运算电路</span></p><ul><li><p><span>余数寄存器 R 和 商寄存器 Q 拼接成64位，用于存放</span><em><span>被扩展的被除数</span></em><span>，控制逻辑计数器 </span><span class='math-in-toc'>$C_n$</span><span>​ 控制左移次数，初始为 32。每次 </span><em><span>Q 的最低位被上商</span></em></p></li><li><p><span>32 位 ALU 两个输入分别为 余数寄存器 R 的32位和 除数寄存器 Y，根据是否够减控制连接的开断</span></p></li></ul></li><li><p><span>两个32位 int 相除，只有</span><span class='math-in-toc'>$-2^{31}/-1$</span><span>（补码）这一种情况会发生溢出</span></p></li><li><p><span>注意，两个int相除，如果接收变量是int，那么结果就会把余数的小数截取掉</span></p></li></ul></li></ul></li><li><p><span>C语言整数类型及类型转换</span></p><ul><li><p><span>有、无符号整数</span></p><ul><li><p><em><span>char本质就是 8bit 的 unsigned int</span></em></p></li></ul></li><li><p><span>不同字长整数</span></p><ul><li><p><em><span>无符号用 0 扩展，有符号则用符号位扩展</span></em></p></li><li><p><em><span>纯小数，无论负数还是正数的补码都用 0 扩充（纯小数补码总是 0 补充）</span></em></p></li></ul></li></ul></li><li><p><span>数据的存储和排列</span></p><ul><li><p><span>大端、小端方式存储</span></p><ul><li><p><span>大端是最高有效字节放在前面顺序存储数据，而</span><em><span>小端是最低位在前面（单位字节）</span></em></p></li><li><p><span>小端存储顺序和原顺序相反</span></p></li></ul></li><li><p><span>边界对齐方式</span></p><ul><li><p><span>对齐是一种</span><em><span>空间换时间</span></em><span>的思想，能适应指令流水</span></p></li><li><p><span>按寻址方式和存储字长决定，若无说明默认存储字长为32位</span></p></li><li><p><span>一般一行就是一个存储字长，当本行数据占不满而下一个数据又太大时，填充后面的空间。如1个char和1个short，则一行为：char、填充、short</span></p></li></ul></li></ul></li></ul><h4 id='浮点数'><span>浮点数</span></h4><ul><li><p><span>表示</span></p><ul><li><p><span>表示格式</span></p><ul><li><p><span>数符（1位）：表示正负</span></p></li><li><p><span>阶码（7位）</span></p><ul><li><p><span>移码表示，即存储的是移码，</span><em><span>将其减去偏置才是真正的值</span></em></p></li><li><p><span>偏置是</span><span class='math-in-toc'>$2^{n-1}$</span><span>，这里偏置为 64。偏置约为阶码表示最大数的一半</span></p></li></ul></li><li><p><span>尾数（24位）</span></p><ul><li><p><em><span>原码</span></em><span>表示，因此现代计算机仍然要考虑原码加减运算</span></p></li><li><p><span>如果尾数用</span><em><span>补码</span></em><span>表示，则</span><em><span>符号位与最高位不同才是规格化数</span></em><span>（即负数最高位必须是0）</span></p></li></ul></li></ul></li><li><p><span>表示范围</span></p><ul><li><p><span>表示范围</span><em><span>关于原点对称</span></em></p></li><li><p><em><span>上溢会出错，下溢则当作机器0来处理</span></em></p></li></ul></li><li><p><span>规格化</span></p><ul><li><p><span>左规和右规</span></p><ul><li><p><span>均是</span><em><span>算术移位</span></em></p></li><li><p><em><span>右规时只需进行一次</span></em><span>，左规可能多次</span></p></li></ul></li><li><p><span>尾数决定了浮点数的精度，规格化使得尾数最高位是一个有效值，从而提升了精度</span></p></li><li><p><span>注意其规格化和 IEEE 标准的规格化是不同的，IEEE规格化最高有效位是个位，这个的最高有效位是第一个小数位</span></p></li><li><p><span>若浮点数</span><em><span>基数为 4</span></em><span>，则保证</span><em><span>小数点后两位不全为 0</span></em></p></li></ul></li><li><p><span>IEEE 754标准</span></p><ul><li><p><span>规格化数</span></p><ul><li><p><em><span>32位：1位符号位，8位阶码，23位尾数</span></em></p><ul><li><p><span>具有一位</span><em><span>隐藏位</span></em></p></li><li><p><span>注意这个隐藏位是直接移动到整数位的</span></p></li><li><p><span>阶码取值范围：1~254</span></p></li></ul></li><li><p><em><span>64位：1符号位，11位阶码，52位尾数</span></em></p></li><li><p><span>偏置值为127，即</span><span class='math-in-toc'>$2^{n-1}-1$</span></p></li><li><p><span>阶码取值范围为1~254，故最小规格化正数为</span><span class='math-in-toc'>$2^{-126}$</span></p></li><li><p><span>注意其规格化和一般浮点数的规格化不同，</span><em><span>最高一位移动到了小数点前，并隐藏起来</span></em></p></li><li><p><em><span>尾数用原码表示，阶码用移码表示</span></em></p></li></ul></li><li><p><span>非规格化数</span></p><ul><li><p><span>是</span><em><span>阶码全 0 但尾数不为 0 的数</span></em></p></li><li><p><span>偏置值固定为 126，且隐藏位为 0 而不是 1，其它方面和规格化数完全一致</span></p></li></ul></li><li><p><span>特殊数</span></p><ul><li><p><em><span>阶码全0且尾数全0：表示数值0</span></em></p><ul><li><p><span>仍然有正0和负0</span></p></li><li><p><span>规格数无法表示0和非常接近0的小数</span></p></li></ul></li><li><p><em><span>阶码全1且尾数全0：表示无限大</span></em></p><ul><li><p><span>符号位0和1分别表示正/负无穷</span></p></li></ul></li><li><p><em><span>非数NaN：阶码全1且尾数不为0</span></em></p></li></ul></li></ul></li><li><p><span>定点、浮点表示的差异</span></p><ul><li><p><span>范围、精度、运算、溢出</span></p></li></ul></li></ul></li><li><p><span>化为IEEE 754标准存储</span></p><ol start='' ><li><p><span>将数化为</span><code>1.xx * 2^k</code><span>的形式，</span><em><span>保证小数点前的第一位是 1</span></em><span>，k可正可负</span></p></li><li><p><em><span>127+k 就是阶数</span></em></p></li><li><p><em><span>再将 xx 化为二进制即是尾数</span></em><span>（小数点在尾数的第一位之前）</span></p></li></ol></li><li><p><span>加减运算</span></p><ol start='' ><li><p><span>对阶</span></p><ul><li><p><span>使两个数阶码相等</span></p></li><li><p><em><span>小阶向大阶看齐，因此不存在阶数减小的情况</span></em></p><ul><li><p><span>若大向小看齐，尾数左移最高有效位被移出会使结果出错</span></p></li></ul></li><li><p><em><span>对阶不会产生上下溢</span></em><span>（有运算时才可能发生）</span></p></li></ul></li></ol><ol start='2' ><li><p><span>尾数求和</span></p><ul><li><p><span>尾数相加减</span></p></li></ul></li></ol><ol start='3' ><li><p><span>规格化</span></p><ul><li><p><span>对于原码尾数，只需看整数位是否为1；补码尾数，符号位与整数位是否相反，相反则已规格化</span></p></li></ul></li><li><p><span>舍入</span></p><ul><li><p><em><span>对阶和右规都可能要舍入，舍入不一定产生误差</span></em></p></li><li><p><span>方法</span></p><ul><li><p><span>0舍1入法</span></p><ul><li><p><span>丢弃的最高位为1就在末尾+1</span></p></li><li><p><span>可能发生尾数溢出</span></p></li></ul></li><li><p><span>恒置1法：最后一位恒置1</span></p></li><li><p><span>截断法：直接截断，丢弃后面所有位</span></p></li></ul></li></ul></li></ol><ol start='5' ><li><p><span>溢出判断</span></p><ul><li><p><span>超过了阶码表示的范围</span></p></li><li><p><span>以</span><em><span>阶码是否发生了上溢</span></em><span>来判断</span></p></li><li><p><span>指数下溢，当作机器0来处理</span></p></li><li><p><span>有些题目指定尾数或阶码用补码表示，通常可采用双符号位，直到化成</span><code>00.1xxx</code><span>或</span><code>11.0xxx</code><span>，且阶码不需要减偏置</span></p></li></ul></li></ol></li><li><p><span>C语言中的浮点数类型</span></p><ul><li><p><span>int转换成float：有精度损失</span></p><ul><li><p><span>double转换成float：有精度损失且可能会溢出</span></p><ul><li><p><span>int或float转换成double：可以精确转换</span></p></li></ul></li><li><p><span>float或double转int：会舍入，且大数的转换可能会溢出</span></p></li><li><p><span>编码位数一定，浮点数和定点数表示的数据个数是一定的，</span><em><span>浮点数不比定点数多</span></em></p></li></ul></li></ul></li></ul><p>&nbsp;</p><h2 id='存储系统'><span>存储系统</span></h2><h4 id='存储器的分类'><span>存储器的分类</span></h4><ul><li><p><span>按层次</span></p><ul><li><p><span>主存、辅存、Cache</span></p></li></ul></li><li><p><span>按存取方式</span></p><ul><li><p><span>RAM、ROM、串行访问存储器（磁带、磁盘、光盘等）</span></p></li></ul></li><li><p><span>双端口存储器有两套独立的读/写接口，各自具有地址译码器，</span><em><span>可同时读</span></em><span>同一单元而不冲突</span></p></li></ul><h4 id='性能指标-2'><span>性能指标</span></h4><ul><li><p><span>存储容量</span></p><ul><li><p><span class='math-in-toc'>$存储字数 * 字长$</span></p></li></ul></li><li><p><span>存储速度</span></p><ul><li><p><span>存取时间：启动存储器到读出数据的时间</span></p></li><li><p><em><span>存取周期：两次存取之间的时间间隔</span></em><span>，</span><em><span>机器周期往往由存取周期决定</span></em></p></li><li><p><em><span>存取周期大于存取时间</span></em></p></li></ul></li></ul><h4 id='多层次的存储系统'><span>多层次的存储系统</span></h4><ul><li><p><span>为了</span><em><span>解决容量、速度、成本三者之间的矛盾</span></em></p></li><li><p><span>主存和 cache 之间的数据调动由硬件完成，对所有程序员都透明</span></p></li><li><p><span>主存和辅存之间的数据调动由硬件和OS共同完成，对应用程序员透明（缺页调页）</span></p></li></ul><h4 id='主存'><span>主存</span></h4><ul><li><p><span>主存主要由 DRAM 实现，也有 ROM；</span><em><span>SRAM常用于Cache</span></em></p></li><li><p><em><span>RAM 属于易失性存储器</span></em><span>，只要断电就没了</span></p></li><li><p><span>SRAM 工作原理</span></p><ul><li><p><span>非破坏性读出：信息被读出后</span><em><span>不需要再生</span></em></p></li></ul></li><li><p><span>DRAM 工作原理</span></p><ul><li><p><span>利用</span><em><span>栅极电容上的电荷</span></em><span>来存储信息</span></p></li><li><p><span>即使不读出、不断电，电荷也只能维持1-2ms，必须刷新才能保证信息不消失</span></p></li><li><p><span>三种刷新方式</span></p><ul><li><p><span>集中刷新</span></p><ul><li><p><span>在一个刷新周期内，用一段固定的时间（一般是一个存储周期），对存储器所有行进行再生，这段时间称为死时间或死区，不能访存</span></p></li></ul></li><li><p><span>分散刷新</span></p><ul><li><p><span>把每行的刷新分散到各个工作周期中</span></p></li><li><p><em><span>没有死区，但增加了系统的存取周期</span></em></p></li></ul></li><li><p><span>异步刷新</span></p><ul><li><p><span>前两种方法的结合，能减少死区时间而减少刷新次数，提高了效率</span></p></li></ul></li><li><p><em><span>DRAM一般按行刷新，故行少一点更好</span></em></p></li></ul></li><li><p><span>DRAM刷新只需要一个存储周期，刷新本质就是重新写入，刷新时内容并不会变化</span></p></li><li><p><span>注意：</span><em><span>DRAM默认采用地址复用技术，而SRAM不采用</span></em></p><ul><li><p><span>地址复用的本质是将地址线分别作为选择行和列的线，因此是</span><em><span>取行选择线和列选择线当中的最大值</span></em><span>，仅当两者相等时才有“地址线减少一半”</span></p></li></ul></li></ul></li><li><p><span>读写信号</span></p><ul><li><p><span>WE 读写信号，CS 片选信号，RAS 行选通信号，CAS 列选通信号</span></p></li><li><p><span>注意字母上面都有横线（应该是表示低电平有效？）</span></p></li></ul></li><li><p><span>存储器的内部结构</span></p><ul><li><p><span>存储体</span></p><ul><li><p><span>又称存储矩阵，由行选择线 X 和列选择线 Y 来选择访问单元，</span><em><span>存储体相同行或列上的位被同时读出或写入</span></em></p></li><li><p><span>行缓冲的大小和一行的比特数相等</span></p></li></ul></li></ul></li><li><p><span>地址译码器</span></p><ul><li><p><span>用来将地址转化为译码输出线上的高电平，驱动读写电路</span></p></li><li><p><span>I/O控制电路</span></p></li></ul></li><li><p><span>片选控制信号</span></p><ul><li><p><span>必须选中某个存储字所在的芯片而不选择其它芯片，是</span><em><span>地址线的高位</span></em><span>，数量根据片选方法而不同</span></p></li><li><p><em><span>若采用地址复用技术，则可不要片选线，加上行选通和列选通线，并将地址线减少</span></em></p></li><li><p><span>读写控制线</span></p></li><li><p><span>做题时默认读写共用一根线，若没有选项就认为读写各一根线</span></p></li><li><p><span>芯片的</span><em><span>引脚数就是线的根数</span></em></p></li></ul></li><li><p><span>ROM</span></p><ul><li><p><span>RAM和ROM</span><em><span>都是随机访问</span></em><span>的，因此随机访问不一定是RAM，也可能是ROM</span></p></li><li><p><span>具有非易失性，可靠性高，掉电也不丢失</span></p></li><li><p><span>种类：MROM、PROM、EPROM、FLASH、SSD</span></p></li><li><p><span>EPROM可以多次改写，但不能作为 RAM 使用</span></p></li></ul></li><li><p><span>主存的基本结构</span></p><ul><li><p><span>主存的读写</span></p></li><li><p><em><span>主存中含有 ROM</span></em></p></li></ul></li><li><p><span>多模块存储器</span></p><ul><li><p><span>是一种</span><em><span>空间并行</span></em><span>技术，利用多个结构相同的存储体并行工作来提高吞吐率</span></p></li><li><p><span>分类</span></p><ul><li><p><span>单体多字存储器</span></p><ul><li><p><span>存储器中只有一个存储体，</span><em><span>每个存储单元存储 m 个字</span></em><span>，总线宽度也为 m 个字。</span><em><span>一次并行读出 m 个字，但地址必须连续且位于同一存储单元</span></em></p></li><li><p><span>碰到转移指令就效果不明显</span></p></li></ul></li><li><p><span>多体并行存储器</span></p><ul><li><p><span>由多体模块组成，每个模块有相同的容量和速度。每个存储体每一行只存储一个存储字长</span></p></li><li><p><span>判断存取周期时，需根据主存地址判断该变量的</span><em><span>第一个字节</span></em><span>存储在几号存储体中，一般情况下，只有</span><em><span>位于不同存储体但是是同一行</span></em><span>的地址可以同时取出，若占了3行则需要至少三次启动</span></p></li><li><p><span>高位交叉编制（顺序方式）</span></p></li><li><p><img src="assets/v2-06a112a6559a8932a6f83ddcfe53376f_r.jpg" referrerpolicy="no-referrer"></p><ul><li><p><em><span>高位为体号，低位为体内地址</span></em></p></li><li><p><span>CPU总是顺序访问存储模块，</span><em><span>不能提高吞吐率</span></em></p></li><li><p><em><span>模块内地址是连续的，存取方式是串行存取，是顺序存储器，不满足局部性原理</span></em></p></li><li><p><span>高位交叉可以一次性读出彼此地址相隔多个存储体的字</span></p></li></ul></li><li><p><span>低位交叉编制（交叉方式）</span></p><ul><li><p><em><span>低位为体号，高位为体内地址</span></em></p></li><li><p><span>每个模块按</span><em><span>模 m 编址</span></em><span>，程序连续存放在相邻模块中，满足局部性原理，可采用流水线的方式并行处理</span></p></li><li><p><span>连续存取m个字的时间</span><span class='math-in-toc'>$t=T+(m-1)r$</span><span>，其中 T 为单个字的存取周期，r 为总线传送周期</span></p></li><li><p><span>此时速度瓶颈在 r，也就是</span><em><span>总线速度</span></em><span>上</span></p></li><li><p><span>注意画流水线图，每个流水的段数就是存储体的个数。连续读、重复 n 次的计算题尤其需要注意</span></p></li><li><p><span>同时启动方式：若所有模块并行读写的总位数等于数据线位数，则可以同时启动所有模块</span></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>主存与CPU的连接</span></p><ul><li><p><span>连接原理</span></p><ul><li><p><span>通过</span><em><span>数据、地址、控制总线</span></em><span>相连</span></p><ul><li><p><span>有</span><span class='math-in-toc'>$2^n$</span><span>次方个地址，就有 n 根地址线，再加上片选线。若采用了地址复用技术，则不要片选线且数量减半，最后+2</span></p></li><li><p><span>每个存储元有 m 位，就有 m 根数据线</span></p></li><li><p><span>控制总线（读写线）一般是一根，指出总线周期的类型和本次输入输出的完成时刻</span></p></li></ul></li></ul></li><li><p><span>容量的扩展</span></p><ul><li><p><span>位扩展法</span></p><ul><li><p><em><span>单独引出数据端</span></em><span>，</span><em><span>让 CS 和 WE 以及地址端都并联</span></em></p></li><li><p><em><span>单独引出就是变了的东西</span></em><span>，如这里的数据端（字长变了）和下面的片选线（芯片个数变了），没变的都并联</span></p></li><li><p><em><span>增加存储字长</span></em><span>，使得存储数据位数和 CPU 的数据线位数相等</span></p></li></ul></li></ul></li></ul></li><li><p><span>字扩展法</span></p><ul><li><p><span>单独引出片选线（CS），让 WE 和数据线以及部分地址线并联</span>
<span>	</span><span>- 芯片若采用字扩展，则必须采用多模块交叉编址的方式才能一次性输出扩展后的字，几体则和几个芯片组成一个字有关</span></p><ul><li><p><span>字位同时扩展法</span></p></li></ul></li><li><p><img src="assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbGtfamF2YQ==,size_16,color_FFFFFF,t_70#pic_center.png" referrerpolicy="no-referrer"></p><ul><li><p><span>片选线和数据线都单独引出</span></p></li></ul></li><li><p><span>位扩展类似于堆栈、字扩展类似于并排</span></p><ul><li><p><span>2-4译码器就是译码片选法，2是片选线个数（地址线高位）</span></p></li></ul></li><li><p><span>注意相比较于原始的方案，线的数量可能会改变，例如同样数量的芯片，位扩展后数据线位数增加，但芯片个数会减少即地址线数量减少（字选线数量不变，片选线减少）</span></p></li><li><p><span>地址分配和片选</span></p><ul><li><p><span>CPU访问，必须</span><em><span>先片选再字选</span></em></p></li><li><p><span>片内的字选通常是 n 条</span><em><span>低位地址线</span></em><span>完成的，</span><span class='math-in-toc'>$2^n$</span><span>就是</span><em><span>片内</span></em><span>的存储字数；片选则是高位地址线</span></p></li></ul></li><li><p><span>片选信号为低电平有效，即</span><em><span>1 无效而 0 有效</span></em></p><ul><li><p><span>片选信号的产生</span></p><ul><li><p><span>线选法</span></p></li><li><p><span>类似于</span><em><span>独热编码</span></em><span>，当高位地址线的</span><em><span>某一位为 0 时选中该芯片</span></em><span>（注意这里不是 1 有效）</span></p><ul><li><p><span>有几个芯片就有多少位</span></p></li></ul></li><li><p><em><span>不需要地址译码器</span></em><span>，线路简单，但不能充分利用存储器空间</span></p></li><li><p><span>译码片选法</span></p></li><li><p><em><span>二进制表示编号</span></em></p><ul><li><p><span>用高位地址线通过译码得到片选信号</span></p></li></ul></li><li><p><span>部分片选的译码</span></p></li><li><p><span>先根据片选电路写出信号的逻辑表达式（根据其串并联），然后</span><em><span>根据信号的低电平有效判断片选</span></em><span>。若</span><em><span>最终信号无效，表示不进行片选</span></em><span>，不进行片选的信号不属于该译码范围</span></p></li></ul></li></ul></li></ul></li><li><p><span>存储器与CPU的连接</span></p><ul><li><p><span>合理选择存储芯片</span></p><ul><li><p><span>通常 ROM 用于存放系统程序、标准子程序和各类常数</span></p></li><li><p><em><span>RAM 为用户编程而设置</span></em></p></li><li><p><span>考虑芯片数量时，尽量使连线简单和方便</span></p></li></ul></li><li><p><span>地址线的连接</span></p><ul><li><p><span>存储芯片的容量不同，其地址线的位数也不同</span></p></li><li><p><span>通常将</span><em><span>低位地址线用于字选，高位地址线用于片选</span></em></p></li></ul></li><li><p><span>数据线的连接</span></p><ul><li><p><span>CPU数据线数和存储芯片位数不等时，必须进行位扩展</span></p></li></ul></li><li><p><span>读写命令线的连接</span></p><ul><li><p><span>如果是</span><em><span>单根，就是高读低写</span></em></p></li><li><p><span>如果是读写线分开了，则均为</span><em><span>低电平有效</span></em></p></li></ul></li><li><p><span>片选线的连接</span></p><ul><li><p><span>若访存控制信号为低电平则片选</span></p></li></ul></li></ul></li></ul><h4 id='外存'><span>外存</span></h4><ul><li><p><span>磁盘存储器</span></p><ul><li><p><span>构成</span></p><ul><li><p><span>磁盘驱动器（就是磁盘）</span></p><ul><li><p><span>核心部件是磁头和盘片组件</span></p></li></ul></li><li><p><span>磁盘控制器</span></p><ul><li><p><span>硬盘和主机的接口</span></p></li><li><p><span>主流有 SATA、IDE 等</span></p></li></ul></li></ul></li><li><p><span>具体划分</span></p><ul><li><p><span>磁头、扇区、柱面、磁道等</span></p></li><li><p><em><span>磁道是一个圆环，扇区是该圆环的一部分</span></em></p></li></ul></li><li><p><span>磁盘性能指标</span></p><ul><li><p><span>记录密度</span></p><ul><li><p><span>每个扇区数据量相等，因此</span><em><span>内部的扇区记录密度更高</span></em></p></li></ul></li><li><p><span>磁盘的容量</span></p><ul><li><p><span>格式化后的磁盘容量更小</span></p></li></ul></li><li><p><span>平均存取时间</span></p><ul><li><p><span class='math-in-toc'>$=寻道时间+旋转延迟时间+传输时间$</span></p></li><li><p><span>磁盘读写都是</span><em><span>串行</span></em><span>的</span></p></li></ul></li><li><p><span>数据传输率</span></p><ul><li><p><span>单位时间传输的字节数</span></p></li><li><p><span>若磁盘转速为r，每条磁道容量为N字节，则</span><span class='math-in-toc'>$D_r=rN$</span><span>，注意单位</span></p></li></ul></li></ul></li><li><p><span>磁盘地址划分</span></p><ul><li><p><span>驱动器号（硬盘号）-磁道-盘面-扇区</span></p></li></ul></li><li><p><span>磁盘阵列RAID</span></p><ul><li><p><span>将多个独立的物理磁盘组成一个独立的逻辑盘，分割交叉存储，可并行、更安全可靠</span></p></li><li><p><span>海明码、奇偶校验等多种校验方式</span></p></li></ul></li></ul></li><li><p><span>固态硬盘</span></p><ul><li><p><span>基于闪存 Flash 技术，闪存翻译层充当了磁盘控制器</span></p></li><li><p><span>随机写很慢，因为要将这一块的内容</span><em><span>整体移动，再擦除，才能写</span></em></p></li><li><p><span>速度相比磁盘更快，并有很多优点</span></p></li><li><p><span>有读写寿命，但平均磨损逻辑控制得非常好</span></p></li></ul></li></ul><h4 id='cache'><span>Cache</span></h4><ul><li><p><span>局部性原理</span></p><ul><li><p><span>空间</span></p><ul><li><p><span>因为</span><em><span>指令通常是顺序存放、顺序存储</span></em><span>的，未来要用的信息很可能与现在使用的信息在存储空间上是临近的</span></p></li></ul></li><li><p><span>时间</span></p><ul><li><p><em><span>程序中存在循环</span></em><span>，所以未来要用的信息很可能是现在正在使用的信息，也就是多次访问同一信息</span></p></li></ul></li></ul></li><li><p><span>Cache工作原理</span></p><ul><li><p><em><span>Cache块（行）和主存块等长，是与主存交换数据的基本单位。而Cache与CPU交换与传送的单位都是字，Cache和主存传送数据也是以字为单位</span></em><span>（传送都是字为单位）</span></p></li><li><p><span>Cache 行长指这一行</span><em><span>能存放数据的长度</span></em></p></li><li><p><em><span>Cache 数据是主存中的副本，故存储器总容量中不该包含 Cache 的大小（主存不完全是外存的副本）</span></em></p></li><li><p><span>若Cache未命中且已满，则需要替换Cache的行（由</span><em><span>硬件实现</span></em><span>）</span></p></li><li><p><span>命中率、平均访存时间、性能提高及相关计算</span></p><ul><li><p><span>注意采用主存 Cache 同时访问和先访问 Cache 后访问主存的性能提高是不同的</span></p></li><li><p><code>A[k]=A[k]+32</code><span>，</span><em><span>需要两次访存</span></em><span>！故它和</span><code>A[k]=32</code><span>的命中率是不一样的</span></p></li></ul></li><li><p><span>注意</span><em><span>访问主存的次数就表示未命中</span></em><span>。Cache失效率也就是未命中率</span></p></li><li><p><span>Cache中某单元的地址：</span><em><span>块号+块内地址</span></em></p></li></ul></li><li><p><span>地址映射</span></p><ul><li><p><span>指</span><em><span>把主存空间地址映射到 Cache 地址空间，即用主存地址访问 Cache 行</span></em></p></li><li><p><span>注意地址的结构和 Cache 行的结构的区别，</span><em><span>主存地址结构为主存块号+块内地址</span></em></p></li><li><p><span>Cache 是以</span><em><span>物理地址</span></em><span>访问的，虚拟地址先查页表或TLB，再拿着物理地址来找Cache或主存，注意块与页进行区分</span></p></li><li><p><span>主存地址，本质上就是主存中第几个存储单元，如果是二进制表示则化为十进制即可，十进制直接可以计算</span></p></li><li><p><span>Cache 组号：如果已经有了</span><em><span>地址，把组号那一部分拿出来然后直接化为十进制就是组号</span></em><span>；若给出的是主存第几块，也就是十进制，则需化成二进制再算</span></p></li><li><p><span>直接映射</span></p><ul><li><p><em><span>地址结构=标记+Cache行号+块内地址</span></em><span>，其中标记+Cache行号就是主存块号</span></p></li><li><p><span>Cache 中需要增加标记（tag），用于指明这一块是主存的哪一块的副本。Cache 中每行也需要一个有效位</span></p></li><li><p><span>每个主存块只能装入 Cache 中唯一的位置</span></p></li><li><p><em><span>无需替换算法</span></em><span>，</span><span class='math-in-toc'>$Cache 行号=主存块号 \% Cache总行数$</span></p></li><li><p><span>实现简单，但不够灵活，</span><em><span>块冲突最高，空间利用率最低，命中率最低，判断所需时间最短，标记所占用的额外空间最少</span></em></p></li><li><p><em><span>访问 Cache 时先找到映射到的 Cache 行，再比较 tag 看是否一致，再看有效位为是否 1</span></em></p></li></ul></li><li><p><span>全相联映射</span></p><ul><li><p><em><span>标记+块内地址</span></em></p></li><li><p><span>主存块</span><em><span>可以装入 Cache 中的任何位置</span></em><span>，每行的标记用于指明主存的哪一块</span></p></li><li><p><span>速度较慢，成本高，常使用昂贵的相联存储器（按内容寻址）来实现。</span><em><span>命中率最高，判断所需时间最长，tag 所占额外空间最多</span></em></p></li></ul></li><li><p><span>组相联映射</span></p><ul><li><p><em><span>标记+Cache组号+块内地址</span></em></p></li><li><p><em><span>每个主存块可装入固定组的任意一行，即组间采用直接映射，组内采用全相联映射</span></em><span>。先按直接映射的方法找到组，再在组中一一比较标记，才能得到装入的Cache行号</span></p></li></ul></li><li><p><span>Cache块的结构：</span><em><span>标记+有效位+维护位（脏位）+替换控制位+数据</span></em><span>。有的时候需要根据题目灵活变通，但</span><em><span>标记和有效位是必须的</span></em></p></li><li><p><em><span>Cache 的比较器个数和主存能映射到多少行相等</span></em><span>，若是全相联则每行都有一个比较器（并行比较），若组相联则等于几路，若是直接映射则仅有一个比较器</span></p></li></ul></li><li><p><span>替换算法</span></p><ul><li><p><span>直接映射无需考虑替换算法</span></p></li><li><p><span>随机算法</span></p><ul><li><p><span>随机地替换Cache块，但未依据局部性原理</span></p></li></ul></li><li><p><span>先进先出算法</span></p><ul><li><p><span>选择最早进入的块进行调出，但未依据局部性原理，因为最早的块也可能是最常用的</span></p></li></ul></li><li><p><span>近期最少使用LRU</span></p><ul><li><p><span>是堆栈类算法，为</span><em><span>每行设置一个计数器</span></em><span>，计数值的位数和 Cache </span><em><span>组大小</span></em><span>有关，即</span><span class='math-in-toc'>$2^N=每组行数$</span><span>，N 为位数</span></p></li><li><p><em><span>命中时计数清零，未命中行的都+1</span></em><span>。这里的行指同一组内的（组相联）或全体行（全相联）。</span></p></li><li><p><em><span>替换掉计数最大的行</span></em></p></li></ul></li><li><p><span>最不经常使用算法</span></p><ul><li><p><span>每行设置一个计数器，每访问一次就+1，替换掉计数最小的行</span></p></li></ul></li><li><p><span>抖动</span></p><ul><li><p><span>当集中访问的存储区超过 Cache 组大小时，命中率可能变得很低</span></p></li></ul></li></ul></li><li><p><span>写策略</span></p><ul><li><p><span>写命中</span></p><ul><li><p><span>全写法（直通法）</span></p><ul><li><p><em><span>同时将数据写到 Cache 和主存</span></em></p></li><li><p><em><span>能保证主存数据的准确性，但增加了访存次数，在安全性要求高的时候可用</span></em></p></li><li><p><span>写缓冲：为减少全写法写入主存的时间消耗</span></p></li></ul></li><li><p><span>回写法</span></p><ul><li><p><em><span>仅写 Cache 不写回主存</span></em><span>，仅当该块</span><em><span>被替换时</span></em><span>写入主存</span></p></li><li><p><span>需设置</span><em><span>修改位（脏位）</span></em><span>。减少了访存次数但有数据不一致的隐患</span></p></li></ul></li></ul></li><li><p><span>写未命中（要修改的单元不在Cache中）</span></p><ul><li><p><span>写分配法</span></p><ul><li><p><em><span>加载块到 Cache，并更新这个块</span></em></p></li></ul></li><li><p><span>非写分配法</span></p><ul><li><p><span>只写入主存，不替换 Cache 块</span></p></li></ul></li></ul></li><li><p><span>常常用</span><em><span>写分配+回写法，全写法+非写分配法</span></em><span>组合</span></p></li><li><p><span>三级缓存、指令 Cache 和数据 Cache 在 L1 时分离等新技术</span></p></li></ul></li></ul><h4 id='虚拟存储器'><span>虚拟存储器</span></h4><ul><li><p><span>将主存和辅存的地址空间统一编址，虚拟存储器具有主存的速度和辅存的容量，它</span><em><span>对应用程序员透明</span></em></p></li><li><p><span>用户涉及到的只是逻辑地址（虚地址），需转化后得到物理地址</span></p></li><li><p><span>CPU使用虚地址时，由辅助硬件 MMU 进行转化，若需访问的内容在主存中，则变换后直接访问；若不在，则先调到主存再访问</span></p></li><li><p><span>由于</span><em><span>辅存过慢，缺页的代价很大，因此采用回写法+全相联映射（提升命中）</span></em></p></li><li><p><span>如果一个数据存在于多个字节中，若无其他说明（如支持突发传输），那么每个地址CPU都要发一遍，存储器每次都要准备。如果是</span><em><span>突发传输，则仅需传一次地址，一次准备数据即可传输完一组突发长度的数据</span></em></p></li><li><p><span>页式虚拟存储器</span></p><ul><li><p><span>页表</span></p><ul><li><p><span>以定长的页为基本单位，页表负责将虚拟地址转化到物理地址，位于内存中。页和物理页框大小相等</span></p></li><li><p><span>结构：</span><em><span>页号、有效位、脏位、引用位（长期未使用的页面将写回外存）、物理地址</span></em></p></li><li><p><em><span>虚拟地址的结构：页号+页内地址</span></em><span>，这里的页号是虚拟页号，可直接指示页表的第几个元素</span></p></li><li><p><span>页表基址寄存器存放页表的首地址，再根据页号找到某页的物理地址</span></p></li><li><p><span>页面长度固定，页表简单，但有</span><em><span>内部碎片</span></em><span>，且不适合保护与共享</span></p></li><li><p><span>页表中是含有页号这一项的，但页表是顺序存储的，由虚拟地址能直接指示页表的第几项，无需一一对比。但在 TLB 中由于仅是页表的部分项目，故必须采取一一对比的方法</span></p></li></ul></li><li><p><span>快表TLB</span></p><ul><li><p><span>利用局部性原理，把一些常访问的页所对应的页表项存放到Cache中</span></p></li><li><p><span>TLB一般采用</span><em><span>全相联方式</span></em><span>，此时</span><em><span>每一项都有一个比较器</span></em></p><ul><li><p><em><span>也有可能采用组相联，根据比较器个数可得到</span></em></p></li><li><p><span>也可能采用 LRU 替换等</span></p></li></ul></li><li><p><span>TLB 表项仍然由</span><em><span>页表表项</span></em><span>组成，TLB 中的标记 Tag，就是其中的虚页号，即需要让虚页号与 tag 比较</span></p></li></ul></li><li><p><span>具有 TLB 和 Cache 的多级存储结构</span></p><ul><li><p><em><span>Cache 缺失由硬件处理，缺页由软件处理，TLB可由硬件也可由软件处理</span></em></p></li><li><p><span>Cache 中存在比较器，用来比较 Tag 的，位数和 Tag 相同，个数和 Cache 组中的行数相同（几路组相连就是几个，全相联看成一组）</span></p></li><li><p><span>TLB 比页表快是由于本身的特性，即Cache</span></p></li><li><p><span>TLB、Page、Cache三种缺失的组合情况</span></p><ul><li><p><span>信息不在主存就一定不在 Cache</span></p></li><li><p><span>TLB 命中则 Page 一定命中（一定在内存中）</span></p></li></ul></li></ul></li></ul></li><li><p><span>段式虚拟存储器</span></p><ul><li><p><span>按程序的逻辑结构进行分段，</span><em><span>段长因程序而异</span></em></p></li><li><p><span>段表结构：段号+装入位+段起点+段长</span></p></li><li><p><span>有逻辑独立性，便于编译、保护、共享等，但会留下</span><em><span>外部碎片</span></em></p></li></ul></li><li><p><span>段页式虚拟存储器</span></p><ul><li><p><span>先按程序逻辑结构分段，再分页</span></p></li><li><p><span>虚地址分为：段号、段内页号、页内地址</span></p></li><li><p><span>兼顾页式和段式虚拟存储器的优点，可实现按段共享和保护</span></p></li><li><p><span>地址变换过程中需</span><em><span>两次查表</span></em><span>，开销较大</span></p></li></ul></li><li><p><span>虚拟存储器与Cache的比较</span></p><ul><li><p><span>相同</span></p><ul><li><p><span>都为了提高系统的性能，两者都有容量、速度、价格的梯度</span></p></li><li><p><span>都把数据划分为小信息块</span></p></li><li><p><span>都有地址的映射、替换算法、更新策略等</span></p></li><li><p><span>都将较为活跃的数据放在相对高速的部件中，基本原理都是局部性</span></p></li></ul></li><li><p><span>不同</span></p><ul><li><p><span>Cache主要解决速度，虚拟存储主要解决容量问题</span></p></li><li><p><span>Cache全由硬件实现，虚拟存储器由硬件和OS共同实现</span></p></li><li><p><span>虚拟存储器不命中的损失更大</span></p></li><li><p><span>CPU 和 Cache 和主存都建立了直接访问的通路，但辅存和 CPU 之间没有通路</span></p></li></ul></li></ul></li></ul><p>&nbsp;</p><h2 id='指令系统'><span>指令系统</span></h2><h4 id='基本格式'><span>基本格式</span></h4><ul><li><p><em><span>操作码+寻址特征+地址码</span></em></p></li><li><p><span>从 0 地址到多地址</span></p><ul><li><p><em><span>多地址指令，其地址码等长</span></em></p></li><li><p><span>零地址指令，例如关机、空操作。零地址的运算类指令只用于堆栈计算机中</span></p></li></ul></li><li><p><em><span>指令字长由op、ad位数、ad个数决定，和机器字长无关</span></em><span>。只是为了方便</span><em><span>一般两者是等长的</span></em></p><ul><li><p><span>CISC 指令长度不同，取出时间亦有差异</span></p></li><li><p><span>按字节编址，则指令字长、存储字长必须是8的整数倍</span></p></li><li><p><span>指令执行的访存次数也和寻址方式、指令类型有关，取指令、取操作数、存结果都要访存。一地址直接寻址需要三次访存</span></p></li></ul></li></ul><h4 id='定长操作码'><span>定长操作码</span></h4><ul><li><p><span>最高位部分分配若干定长位来表示操作码</span></p></li></ul><h4 id='扩展操作码'><span>扩展操作码</span></h4><ul><li><p><em><span>字长一定，动态调整地址码和操作码的长度</span></em></p><ul><li><p><em><span>不允许短码是长码的前缀</span></em></p></li><li><p><em><span>各指令的操作码不能重复</span></em></p></li></ul></li><li><p><span>分析指令的寻址单元数，以及最大的指令条数</span></p><ul><li><p><span>短操作码不能是长操作码的前缀，即短op会占用长op的条数，短op占用的那几位，长op不能使用</span></p></li><li><p><span>指令的个数由op的个数决定</span></p></li></ul></li></ul><h4 id='指令的操作类型'><span>指令的操作类型</span></h4><ul><li><p><span>数据传送</span></p><ul><li><p><span>MOV </span><em><span>寄存器之间的传送</span></em></p></li><li><p><span>LOAD 从内存读取到CPU寄存器</span></p></li><li><p><span>STORE 从</span><em><span>CPU寄存器写入内存</span></em></p></li></ul></li><li><p><span>算术和逻辑运算</span></p><ul><li><p><span>ADD加、SUB减、MUL乘、DIV除、CMP比较</span></p></li><li><p><span>INC加一、DEC减一、AND与、OR或、NOT取反、XOR异或</span></p></li></ul></li><li><p><span>移位操作</span></p><ul><li><p><span>算术移位、逻辑移位、循环移位</span></p></li><li><p><em><span>移位指令中，操作数1代表移一位即乘2，2代表移两位即乘4</span></em></p></li></ul></li><li><p><span>转移操作</span></p><ul><li><p><em><span>JMP无条件转移</span></em><span>、BRANCH条件转移、CALL调用、RET返回、TRAP陷阱</span></p></li><li><p><span>循环语句是由转移语句实现的，同样是程序控制指令</span></p></li></ul></li></ul><h4 id='寻址方式'><span>寻址方式</span></h4><ul><li><p><span>指令中地址码不是真实地址，被称为形式地址</span></p></li><li><p><span>指令寻址</span></p><ul><li><p><span>顺序寻址</span></p><ul><li><p><span>PC自动+1得到</span></p></li></ul></li><li><p><span>跳跃寻址</span></p><ul><li><p><span>通过转移类指令实现</span></p></li><li><p><em><span>下条指令的地址的计算方法由本条指令给出</span></em></p></li><li><p><em><span>跳跃寻址的结果是修改PC值</span></em><span>，所以下一条指令仍由PC给出</span></p></li><li><p><span>像 jmp、jgp 等都是有数据的，因为要给出下一条指令的地址</span></p></li><li><p><span>分为绝对地址和相对地址</span></p><ul><li><p><em><span>绝对地址由标记符直接得到</span></em></p><ul><li><p><em><span>必定非负</span></em></p></li></ul></li><li><p><span>相对地址是</span><em><span>相对于当前PC的偏移量</span></em></p><ul><li><p><span class='math-in-toc'>$下条指令的地址=本条指令地址+1+相对偏移量$</span></p></li><li><p><em><span>+1为本条指令的长度</span></em></p></li></ul></li></ul></li></ul></li></ul></li><li><p><span>数据寻址</span></p><ul><li><p><span>表示如何在指令中表示一个操作数的地址</span></p></li><li><p><span>由于寻址方式较多，通常在操作码和地址码之间设置一个字段，用来指明寻址方式</span></p></li><li><p><span>多种寻址方式目的是</span><em><span>扩大寻址范围</span></em><span>，但</span><em><span>增大了译码难度</span></em></p></li><li><p><span>隐含寻址</span></p><ul><li><p><span>不明显给出操作数的地址，在指令中隐含操作数的地址，如</span><em><span>单地址指令规定 ACC 就是第二个数</span></em></p></li><li><p><span>有利于缩短指令字长，但需增加隐含地址的硬件</span></p></li><li><p><span>是</span><em><span>最简化</span></em><span>的地址结构</span></p></li></ul></li><li><p><span>立即（数）寻址</span></p><ul><li><p><em><span>地址字段就是操作数，补码表示</span></em><span>，又称立即数</span></p></li><li><p><em><span>不访问主存</span></em><span>，执行时间短，但地址码的位数限制了立即数的范围</span></p></li></ul></li><li><p><span>直接寻址</span></p><ul><li><p><em><span>地址码即操作数的真实地址</span></em></p></li><li><p><span>直接寻址给出的操作数是地址，因此</span><em><span>是unsigned int</span></em></p></li><li><p><span>简单，</span><em><span>取操作数仅访问一次主存</span></em><span>，但地址码的位数限制了寻址范围</span></p></li></ul></li><li><p><span>间接寻址</span></p><ul><li><p><span>地址码给出的是地址是存放操作数地址的地址</span></p></li><li><p><span>可以一次间接寻址或多次间址</span></p></li><li><p><span>可扩大寻址范围，但要多次访问</span></p></li></ul></li><li><p><span>寄存器寻址</span></p><ul><li><p><em><span>地址码指出寄存器编号，操作数在寄存器里</span></em></p></li><li><p><em><span>不用访存</span></em><span>，速度快，地址码长度小，但寄存器有限</span></p></li></ul></li><li><p><span>寄存器间接寻址</span></p><ul><li><p><em><span>地址码指示寄存器编号，寄存器里放操作数的地址码</span></em></p></li></ul></li><li><p><span>相对寻址</span></p><ul><li><p><span>真实地址为</span><em><span>(PC)+1+形式地址</span></em></p></li><li><p><span>形式地址也可称为偏移量，</span><em><span>补码表示</span></em><span>，可正可负</span></p></li><li><p><span>操作数的地址不固定，随 PC 的值而变化，便于</span><em><span>程序浮动</span></em><span>，广泛用在转移指令中</span></p></li></ul></li><li><p><span>基址寻址</span></p><ul><li><p><em><span>基址寻址器 BR+形式地址</span></em></p></li><li><p><em><span>面向操作系统，程序执行时 BR 的内容不变，而形式地址变化</span></em></p></li><li><p><span>可扩大寻址范围，有利于多道程序设计和</span><em><span>浮动程序</span></em><span>，但形式地址的位数较短</span></p></li></ul></li><li><p><span>变址寻址</span></p><ul><li><p><em><span>变址寻址器 IX + 形式地址</span></em></p></li><li><p><em><span>面向用户，程序执行时 IX 可变而形式地址不变</span></em></p></li><li><p><span>适合编制</span><em><span>循环</span></em><span>程序，也适用于处理数组</span></p></li></ul></li><li><p><span>堆栈寻址</span></p><ul><li><p><span>硬堆栈：寄存器堆栈</span></p></li><li><p><span>软堆栈：从主存中划出一段区域来做堆栈</span></p></li><li><p><em><span>堆栈结构中，操作数隐含在堆栈里，不需要地址</span></em></p></li></ul></li></ul></li></ul><h4 id='程序的机器级代码表示'><span>程序的机器级代码表示</span></h4><ul><li><p><span>相关寄存器</span></p><ul><li><p><span>x86中，有 8 个 32 位的通用寄存器，除两个堆栈寄存器外，其余的使用比较随意</span></p><ul><li><p><span>EAX-EDX，ESI、EDI</span></p></li><li><p><span>EBP、ESP</span></p></li></ul></li></ul></li><li><p><span>汇编格式的比较（408统考一般是 Intel 格式）</span></p><ul><li><p><span>AT&amp;T 只能用小写字母，Intel 不敏感</span></p></li><li><p><span>AT&amp;T 第一个为源操作数，第二个为目的操作数，方向从左到右；</span><em><span>Intel则是第一个为目的操作数</span></em><span>。</span><em><span>寄存器目标为目的操作数</span></em></p><pre class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" spellcheck="false" lang="assembly"><div class="CodeMirror cm-s-inner cm-s-null-scroll" lang="assembly"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 12px; left: 32px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; min-width: 483.24px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>8</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">mov</span> $100, %<span class="cm-variable-2">eax</span><span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment"># AT&amp;T格式，100-&gt;R[eax]</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">mov</span> <span class="cm-variable-2">eax</span>, 100<span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># Intel格式</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">movl</span> %<span class="cm-variable-2">eax</span>, %<span class="cm-variable-2">ebx</span><span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-comment"># 长度为四字节（双字）的 R[eax]-&gt;R[ebx]</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">mov</span> <span class="cm-keyword">dword</span> <span class="cm-keyword">ptr</span> <span class="cm-variable-2">ebx</span>, <span class="cm-variable-2">eax</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">lea</span> <span class="cm-keyword">8</span>(%<span class="cm-variable-2">edx</span>,%<span class="cm-variable-2">eax</span>,2), %<span class="cm-variable-2">eax</span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># R[edx]+R[eax]*2+8-&gt;R[eax]</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">lea</span> <span class="cm-variable-2">eax</span>, [<span class="cm-variable-2">edx</span>+<span class="cm-variable-2">eax</span>*2+8]<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment"># lea 指令在地址需要复杂计算时使用，和mov类似</span></span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 224px;"></div><div class="CodeMirror-gutters" style="height: 224px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li><li><p><span>AT&amp;T寄存器需加前缀</span><code>%</code><span>，立即数加</span><code>$</code><span>，Intel都不加</span></p></li><li><p><span>AT&amp;T使用</span><code>()</code><span>进行内存寻址，Intel使用</span><code>[]</code></p></li><li><p><span>AT&amp;T复杂寻址格式</span><code>disp(base,index,scale)</code><span>，Intel 的就是表达式</span></p></li><li><p><span>AT&amp;T在操作码后面跟一个字符代表操作数大小，b代表字节，w代表字，l 表示双字，1 word=16 bit；Intel格式中，在操作码后面显式地注明 </span><code>数据类型 ptr</code><span> </span></p></li></ul></li><li><p><span>常用指令</span></p><ul><li><p><span>数据传送指令</span></p><ul><li><p><code>mov</code><span>指令</span></p></li><li><p><code>push</code><span>指令：入栈，</span><em><span>先 ESP-4 再入栈</span></em><span>（指针直接指向栈的最后一个元素）</span></p></li><li><p><code>pop</code><span>指令：出栈，</span><em><span>先出栈再把 ESP+4</span></em></p></li></ul></li><li><p><span>算术和逻辑运算指令</span></p><ul><li><p><code>add/sub</code><span>：两操作数相加减，</span><em><span>结果覆盖掉原目的操作数</span></em></p></li><li><p><code>inc/dec</code><span>：自加或自减</span></p></li><li><p><code>imul</code><span>：带符号整数乘法</span></p></li><li><p><code>idiv</code><span>：带符号整数除法</span></p><ul><li><p><em><span>只有一个操作数，即除数</span></em><span>，被除数由</span><code>edx:eax</code><span>拼接而成</span></p></li><li><p><span>结果分为商和余数，</span><em><span>商送到eax，余数送到edx</span></em></p></li></ul></li><li><p><code>and/or/xor</code></p></li><li><p><code>not</code><span>：每一位都翻转</span></p></li><li><p><code>neg</code><span>：取负指令</span></p></li><li><p><code>shl和shr</code>
<span>	</span><span>- </span><em><span>算术</span></em><span>左移和右移，</span><em><span>第一个数为被操作数，第二个为移位的位数</span></em></p></li></ul></li><li><p><span>控制流指令</span></p><ul><li><p><code>jmp &lt;label&gt;</code></p><ul><li><p><span>无条件跳转到 label 所指示的地址</span></p></li></ul></li><li><p><code>jcondition</code><span>条件转移指令</span></p><ul><li><p><span>依据 CPU 状态字中的一系列条件状态转移</span></p></li><li><p><span>例如 jle 就是小于等于时跳转，</span><em><span>jne 就是不等于时跳转</span></em></p></li></ul></li><li><p><code>cmp/test</code><span>指令</span></p><ul><li><p><span>cmp 用于比较两个操作数的值，实现方式是两数相减；test 是两个数逐位与运算</span></p></li><li><p><em><span>两者都只改变状态字，如溢出of、零标志zf等，不保存结果</span></em></p></li><li><p><span>常与条件转移指令搭配使用</span></p></li></ul></li><li><p><code>call/ret</code><span>指令</span></p><ul><li><p><span>是</span><em><span>函数调用</span></em><span>中最关键的两条指令，都是</span><em><span>无条件转移指令</span></em></p></li><li><p><span>call 执行</span><em><span>当前指令地址的入栈和跳转</span></em><span>，ret 则相反</span></p></li></ul></li></ul></li></ul></li><li><p><span>过程调用的机器级表示</span></p><ul><li><p><span>在内存中划出一个</span><em><span>栈区</span></em><span>来实现调用，</span><em><span>地址从高位向低位增长</span></em></p></li><li><p><em><span>调用子进程只需要保存 PC，不需要保存 PSW，但中断必须保存 PC 和 PSW</span></em></p></li></ul></li><li><p><span>选择语句的机器级表示</span></p><ul><li><p><em><span>CF 进位/借位标志、ZF零标志、SF符号标志、OF溢出标志</span></em></p></li><li><p><em><span>OF、SF 对无符号数没有意义</span></em><span>（</span><em><span>无符号数不存在溢出</span></em><span>，尽管装不下了但根据CF=1可以确定结果是多少，用最高位CF=1表示超过最大值），</span><em><span>CF 对带符号数没有意义</span></em><span>（符号位不是进位而是溢出）</span></p></li><li><p><span>编译器通过条件码（标志位）设置指令和各类转移指令来实现跳转</span></p></li></ul></li><li><p><span>循环语句的机器级表示</span></p><ul><li><p><span>while、do-while 和 for 都可翻译成 do-while，而又进一步翻译成 goto 语句</span></p></li></ul></li></ul><h4 id='cisc和risc'><span>CISC和RISC</span></h4><ul><li><p><span>RISC 指令长度固定，只有load、store指令访存，</span><em><span>寄存器非常多</span></em><span>，</span><em><span>一定采用</span></em><span>流水线技术，不用或少用微程序控制</span></p></li><li><p><span>CISC 也可能采用流水线技术</span></p></li><li><p><span>RISC 有利于编译优化，更能提高运算速度，能缩小芯片面积，便于设计降低成本</span></p></li></ul><p>&nbsp;</p><h2 id='中央处理器'><span>中央处理器</span></h2><h4 id='基本功能'><span>基本功能</span></h4><ul><li><p><span>指令控制：完成取指令、分析指令和执行指令的操作</span></p></li><li><p><span>操作控制、时间控制</span></p></li><li><p><span>数据加工、中断处理</span></p></li></ul><h4 id='基本结构'><span>基本结构</span></h4><ul><li><p><span>运算器：ALU、ACC、PSW（程序状态字寄存器）、通用寄存器组等</span></p><ul><li><p><span>PSW 包含 ZF、OF、CF 等各种状态</span></p></li></ul></li><li><p><span>控制器：PC、IR、MAR、MDR、ID（指令译码器）等</span></p></li></ul><h4 id='指令的执行'><span>指令的执行</span></h4><ul><li><p><span>指令周期</span></p><ul><li><p><span>CPU 执行一条指令的时长称为指令周期，也称工作周期，一个工作周期包含多个机器周期</span></p></li></ul></li><li><p><span>机器周期一般由存取周期决定，常包含多个时钟周期，一般指令周期每个阶段执行时长都是一个机器周期</span></p><ol start='' ><li><p><span>取指周期</span></p></li></ol><ul><li><p><em><span>根据 PC 取出指令放到 IR</span></em></p></li><li><p><em><span>访存目的是取指令</span></em></p></li><li><p><span>取指操作是</span><em><span>自动进行</span></em><span>的，控制器不需要得到相应的指令</span></p><ul><li><p><span>不同长度的指令，取指操作可能不同，如单字、双字指令取指就不同</span></p></li><li><p><span>数据流</span></p><ul><li><p><span>PC &gt; MAR &gt; 地址总线 &gt; 主存</span></p></li><li><p><span>CU 发出读命令 &gt; 控制总线 &gt; 主存</span></p></li><li><p><span>主存 &gt; 数据总线 &gt; MDR &gt; IR（存放指令）</span></p></li><li><p><span>CU 发出控制信号 &gt; PC+1</span></p></li></ul></li></ul></li></ul><ol start='2' ><li><p><span>间址周期（间接寻址）</span></p></li></ol><ul><li><p><em><span>访存，取操作数有效地址</span></em></p></li><li><p><em><span>JMP 无条件转移指令，没有间址周期</span></em></p></li><li><p><span>数据流</span></p><ul><li><p><span>Ad(IR) (或MDR) &gt; MAR &gt; 地址总线 &gt; 主存</span></p></li><li><p><span>CU 发出读命令 &gt; 控制总线 &gt; 主存</span></p></li><li><p><span>主存 &gt; 数据总线 &gt; MDR</span></p></li></ul></li></ul><ol start='3' ><li><p><span>执行周期</span></p></li></ol><ul><li><p><em><span>取操作数，并根据 IR 的 op 通过 ALU 产生结果</span></em></p></li><li><p><em><span>访存是为了取操作数</span></em></p></li><li><p><span>数据流：没有统一的数据流向</span></p></li></ul><ol start='4' ><li><p><span>中断周期</span></p></li></ol><ul><li><p><span>处理中断请求</span></p></li><li><p><em><span>检测到有中断请求时才有这一周期</span></em><span>，且只有这一周期才能响应</span><em><span>非紧急</span></em><span>的中断</span></p></li><li><p><span>访存是为了</span><em><span>保存程序断点</span></em><span>。也就是说</span><em><span>四个周期都有CPU访存操作</span></em></p></li><li><p><span>数据流</span></p><ul><li><p><span>CU 控制 SP-1，SP &gt; MAR &gt; 地址总线 &gt; 主存</span></p><ul><li><p><span>SP是栈顶地址，</span><em><span>先改地址再存数据</span></em></p></li><li><p><span>-1 是因为地址从高到低增长，是把栈顶的地址送到主存，以便访问主存中的栈顶并存入数据</span></p></li></ul></li><li><p><span>CU 发出写命令 &gt; 控制总线 &gt; 主存</span></p></li><li><p><span>PC &gt; MDR &gt; 数据总线 &gt; 主存（程序断点存入主存）</span></p></li><li><p><span>CU(中断程序入口地址) &gt; PC</span></p></li></ul></li></ul></li><li><p><span>指令周期中，每一个操作就是一个机器周期，而</span><em><span>每个机器周期又由若干时钟周期组成</span></em></p></li><li><p><em><span>机器周期通常由存取周期决定</span></em></p></li><li><p><span>指令执行方案</span></p><ul><li><p><span>单指令周期</span></p><ul><li><p><em><span>所有指令都选用相同的时间来完成</span></em></p></li><li><p><span>以最长执行时间为时间基准，</span><em><span>串行</span></em><span>执行，</span><em><span>CPI=1</span></em><span>，一条指令用一个时钟周期，但主频非常低</span></p></li></ul></li><li><p><span>多指令周期</span></p><ul><li><p><em><span>串行</span></em><span>执行，</span><em><span>某指令需要几个周期就分配几个周期</span></em><span>，CPI&gt;1</span></p></li></ul></li><li><p><span>流水线方案</span></p><ul><li><p><span>指令之间</span><em><span>并行</span></em><span>执行，但在不同的执行步骤当中</span></p></li></ul></li></ul></li></ul><h4 id='数据通路'><span>数据通路</span></h4><ul><li><p><em><span>数据在各部件之间传送的逻辑路径，包括数据通路上流经的部件</span></em><span>，描述了信息从什么地方开始，经过了哪些地方最后到了什么地方</span></p></li><li><p><span>功能：实现 </span><em><span>CPU 内部</span></em><span>的运算器和寄存器与寄存器之间的</span><em><span>数据交换</span></em></p></li><li><p><span>结构</span></p><ul><li><p><span>CPU 内部单总线方式</span></p><ul><li><p><span>将</span><em><span>所有寄存器的输入端和输出端都连接到一条公共通路上</span></em></p></li><li><p><em><span>1 个 clock 只能完成一个动作</span></em><span>，而不能完成一条指令</span></p></li><li><p><em><span>每个时刻总线上只有一个数据有效，故ALU需要一个输入暂存器</span></em><span>；若ALU不设置输出暂存器，其输出到总线后会反馈到输入端从而影响结果</span></p></li><li><p><span>结构简单，但冲突较多，性能较低</span></p></li></ul></li><li><p><span>CPU 内部多总线方式</span></p><ul><li><p><span>所有寄存器的输入端、输出端都连接到</span><em><span>多条公共通路</span></em><span>上，提高了效率</span></p></li></ul></li><li><p><span>专用数据通路方式</span></p><ul><li><p><span>根据数据和地址的流动安排专门的线路，避免使用共享总线，性能较高但硬件复杂</span></p></li></ul></li></ul></li><li><p><span>规定</span><em><span>各部件使用大写字母表示</span></em><span>，</span><em><span>in 和 out 控制信号的输入和输出</span></em><span>，如ACCin、Zout等</span></p></li><li><p><span>寄存器之间的数据流向</span></p><ul><li><p><span>以 PC 寄存器为例：</span><code>(PC)&gt;MAR</code><span>，PCout 和 MARin 有效，PC内容 &gt; MAR</span></p></li></ul></li><li><p><span>通用寄存器</span></p><ul><li><p><span>是 CPU 内的一组寄存器，既可读又可写</span></p></li><li><p><span>需要连接地址译码器进行</span><em><span>译码</span></em></p></li></ul></li><li><p><span>MUX</span></p><ul><li><p><span>多路选择器，选择多个输入中的一个有效，是</span><em><span>多输入单输出的组合逻辑电路</span></em></p></li><li><p><span>PC+1 也是需要经过 ALU 的，故 MUX 可以将一个输入固定为一条指令的长度，方便在指令顺序执行时快速+1</span></p></li></ul></li><li><p><span>主存和 CPU 之间的数据传送</span></p><ul><li><p><code>(PC)&gt;MAR</code></p><ul><li><p><span>PCout 和 MARin 有效，现行指令地址&gt;MAR</span></p></li><li><p><span>为什么是现行指令而不是下一条指令到 IR？因为一条指令的周期是从取址开始的，即从取这条指令的第一步开始，就是这条指令的周期，这条指令就是现行指令</span></p></li></ul></li><li><p><code>1&gt;R</code></p><ul><li><p><span>CU 发出读命令，1是数字，R 代表读控制线（对应的还有 W 写控制线）</span></p></li></ul></li><li><p><code>MEM(MAR)&gt;MDR</code></p><ul><li><p><span>MDRin 有效</span></p></li></ul></li><li><p><code>(MDR)&gt;IR</code></p><ul><li><p><span>MDRout 和 IRin 有效，现行指令&gt;IR</span></p></li></ul></li></ul></li><li><p><span>执行算术或逻辑运算</span></p><ul><li><p><code>(R1)&gt;Y</code></p><ul><li><p><span>R1out 和 Yin 有效，操作数&gt;Y</span></p></li></ul></li><li><p><code>(ACC)+(Y)&gt;Z</code><span>（微操作）</span></p><ul><li><p><span>控制信号：ACCout 和 ALUin 有效，CU 向 ALU 发出加命令，结果&gt;Z</span></p></li><li><p><span>简化为：ACCout，ALUin，“+”</span></p></li></ul></li><li><p><code>(Z)&gt;ACC</code></p><ul><li><p><span>Zout 和 ACCin 有效，结果&gt;ACC</span></p></li></ul></li><li><p><span>以上三步不能同时执行，否则会引起总线冲突，因此该操作需要 3 个 Clock</span></p></li></ul></li><li><p><span>数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同指令执行过程的微操作序列也不同，关系着微操作信号形成部件</span></p></li><li><p><span>注意分析操作序列的 clock 消耗，传送以及能同时进行的，都只要一个clock</span></p></li><li><p><span>控制信号：当执行部件不需要执行时，信号为0，否则为具体操作，如 ALUop=sub、MEMop=read 等</span></p></li></ul><h4 id='控制器'><span>控制器</span></h4><ul><li><p><span>硬布线控制器</span></p><ul><li><p><span>由复杂的组合逻辑电路和触发器组成，其时序系统比微程序设计更</span><em><span>复杂</span></em></p></li><li><p><span>CU 的输入信号</span></p><ol start='' ><li><p><span>操作码译码后产生的</span><em><span>指令信息</span></em></p></li></ol><ul><li><p><span>来源硬件：译码电路 ID</span></p></li></ul><ol start='2' ><li><p><span>时序系统产生的</span><em><span>机器周期信号和节拍信号</span></em></p></li></ol><ul><li><p><span>来源硬件：节拍发生器</span></p></li></ul><ol start='3' ><li><p><span>来自执行单元的反馈，即</span><em><span>标志</span></em></p></li></ol><ul><li><p><span>来源硬件：状态标志</span></p></li></ul><ol start='4' ><li><p><span>另外，还接收来自控制总线的</span><em><span>控制信号</span></em><span>，如DMA请求、中断请求等</span></p></li></ol></li><li><p><span>时序系统及微操作</span></p><ul><li><p><span>一个节拍对应一个时钟周期</span></p></li><li><p><span>机器周期可视为所有指令执行的一个基准时间，可完成若干微操作，常以存取周期为基准。</span><em><span>存取字长等于机器字长时，取址周期等于机器周期，一个机器周期可完成若干微操作</span></em></p></li><li><p><span>目标是一个时钟周期完成一条指令</span></p></li><li><p><span>微操作命令：与指令相关，且必须按次序发出</span></p></li><li><p><span>指令的三个周期：取指、间址、执行</span></p></li></ul></li><li><p><span>CPU的控制方式</span></p><ul><li><p><span>同步</span></p><ul><li><p><span>系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟，节拍时间通常以最繁琐的微操作为标准</span></p></li><li><p><span>控制电路简单，但速度较慢</span></p></li></ul></li><li><p><span>异步</span></p><ul><li><p><span>不存在基准时间，每个部件按自己的速度运行，通过</span><em><span>应答</span></em><span>的方式联络</span></p></li><li><p><em><span>速度快</span></em><span>，但电路复杂</span></p></li></ul></li><li><p><span>联合控制</span></p><ul><li><p><span>大部分同步控制，小部分异步控制</span></p></li></ul></li></ul></li></ul></li><li><p><span>微程序控制器</span></p><ul><li><p><span>采用</span><em><span>存储逻辑</span></em><span>实现，解释机器指令的微程序</span></p></li><li><p><em><span>每条机器指令编写成一个微程序</span></em><span>，</span><em><span>每个微程序包含若干条微指令</span></em><span>，</span><em><span>每条微指令对应多个微操作命令即微命令</span></em></p></li><li><p><code>微操作=微命令-&gt;微指令（有地址）-&gt;微程序</code></p></li><li><p><span>微命令是控制部件向执行部件发出的各种控制命令，是构成控制序列的</span><em><span>最小单位</span></em></p></li><li><p><span>微命令是执行过程就是微操作，它们是对应的，一个节拍可执行一个微操作，即微操作是最基本的不可分割的操作。这里的微操作，就是</span><code>(PC)-&gt;MAR</code><span>、</span><code>Ad(CMDR)-&gt;CMAR</code><span>这种</span></p></li><li><p><em><span>微指令的构成：操作控制字段+顺序控制字段</span></em><span>，</span><em><span>前者类似操作码，后者提供下一条微指令的位置</span></em></p></li><li><p><span>通常</span><em><span>一个微程序周期对应一个指令周期</span></em></p></li><li><p><span>组成</span></p><ul><li><p><span>控制存储器 CM</span></p><ul><li><p><span>相当于主存，用于存放微程序，用 ROM 实现</span></p></li><li><p><span>CM 中微程序的个数，等于</span><em><span>机器指令数+取址、间指、中断等公共微程序数</span></em></p></li></ul></li><li><p><span>微指令寄存器 CMDR</span></p><ul><li><p><span>又称 μIR，类似于 IR，用于存放微指令，位数和指令字长相等</span></p></li><li><p><span>注意CMDR和MDR不同！！！而是</span><em><span>类似于 IR</span></em></p></li></ul></li><li><p><span>微指令计数器</span></p><ul><li><p><span>决定</span><em><span>微指令</span></em><span>（而不是指令）的顺序，类似于</span><em><span>PC</span></em></p></li></ul></li><li><p><span>微地址寄存器 CMAR</span></p><ul><li><p><span>类似于 MAR 的功能</span></p></li></ul></li></ul></li><li><p><span>微指令的编码</span></p><ul><li><p><span>直接编码</span></p><ul><li><p><em><span>无需译码</span></em><span>，</span><em><span>命令字段每个位都代表一个微命令</span></em><span>，选用设置为1，不用就是0</span></p><ul><li><p><span>直观速度快，但 n 个命令就要 n 位操作字长</span></p></li></ul></li></ul></li><li><p><span>字段直接编码</span></p><ul><li><p><span>将微命令的命令字段分成若干小段，</span><em><span>互斥性微命令组合在同一字段内</span></em><span>，每个小段独立编码（多个小段表示的操作可并行），每种编码代表一个微命令</span></p><ul><li><p><span>n 位某小段可表示 </span><span class='math-in-toc'>$2^n$</span><span> 条命令</span></p></li><li><p><span>每个小段都要</span><em><span>留出一个状态</span></em><span>，通常是全 0，表示本小段不发出任何微命令</span></p></li></ul></li><li><p><em><span>需要译码</span></em><span>，因此比直接编码慢</span></p><ul><li><p><span>可以缩短指令字长</span></p></li></ul></li></ul></li><li><p><span>字段间接编码</span></p><ul><li><p><span>一个字段的某些微命令需要由另一个字段的某些微命令来解释</span></p><ul><li><p><span>可进一步缩短指令字长，但会削弱微指令的并行能力</span></p></li></ul></li></ul></li></ul></li><li><p><span>微指令地址的形成方式</span></p><ul><li><p><span>由微指令的</span><em><span>下地址字段</span></em><span>指出</span></p></li><li><p><span>根据机器指令的操作码形成</span></p><ul><li><p><span>跟 PC 一样，CMAR+1</span></p></li><li><p><span>根据标志决定分支转移地址</span></p></li></ul></li></ul></li><li><p><span>微指令的格式</span></p><ul><li><p><span>水平型微指令</span></p><ul><li><p><span>上面三种微指令的编码方式，都属于水平型微指令</span></p><ul><li><p><span>一条水平型微指令对应</span><em><span>几个并行</span></em><span>的操作</span></p></li></ul></li><li><p><em><span>微程序短，执行速度快，但指令字较长</span></em></p><ul><li><p><span>注意区分微程序的长度和指令的长度，这里是单条微指令长，但由于能表示多个操作，所以微程序短</span></p></li></ul></li></ul></li><li><p><span>垂直型微指令</span></p><ul><li><p><span>采用微操作译码法，和机器指令的操作码类似</span></p><ul><li><p><em><span>一条只能定义并执行一种基本操作</span></em></p></li></ul></li><li><p><span>微指令短，工整，但速度慢，且微程序长</span></p></li><li><p><span>微指令格式：</span><span class='math-in-toc'>$\mu OP$</span><span>+目的地址+源地址</span></p></li></ul></li></ul></li><li><p><span>动态微程序设计</span></p><ul><li><p><span>能根据用户的要求改变微程序</span></p></li><li><p><span>必须有可写控制寄存器的支持，如EPROM</span></p></li></ul></li></ul></li></ul><h4 id='异常和中断'><span>异常和中断</span></h4><ul><li><p><span>异常的概念</span></p><ul><li><p><span>异常是 </span><em><span>CPU 内部</span></em><span>产生的意外事件，如</span><em><span>除数为0、溢出、程序断点</span></em><span>等</span></p><ul><li><p><span>这里的内部产生是指由于 CPU 执行了这条指令产生了问题</span></p></li></ul></li><li><p><span>异常也被视为中断（内中断）</span></p></li><li><p><em><span>Cache 缺失是硬件故障</span></em><span>，不需要异常处理软件来处理</span></p></li><li><p><span>数据下溢将视作机器 0，不会产生异常</span></p></li><li><p><em><span>异常并不总是返回本条指令执行</span></em></p></li></ul></li><li><p><span>异常的分类</span></p><ul><li><p><span>故障Fault：指令引起故障</span></p><ul><li><p><span>存储保护错：例如地址越界，缺页</span></p></li><li><p><span>处理之后返回</span><em><span>本条</span></em><span>指令执行</span></p></li></ul></li><li><p><span>自陷Trap：预先安排的异常事件</span></p><ul><li><p><span>自陷处理后，返回陷阱指令的</span><em><span>下一条</span></em><span>去执行</span></p></li></ul></li><li><p><span>终止Abort：出现无法继续执行问题</span></p><ul><li><p><span>例如除数为0</span></p></li><li><p><em><span>中断处理完成后，无法返回本条指令继续执行，而是直接终止执行</span></em></p></li></ul></li></ul></li><li><p><span>中断的分类</span></p><ul><li><p><span>可屏蔽中断</span></p><ul><li><p><span>通过 INTR 中断请求线发送</span></p></li></ul></li><li><p><span>不可屏蔽中断</span></p><ul><li><p><span>通过 NMI 线发送</span></p></li></ul></li></ul></li><li><p><span>异常和中断的区别</span></p><ul><li><p><span>异常的检测由 CPU 自己完成，而中断必须通过中断请求线才直到哪个设备发生了何种中断</span></p></li><li><p><span>中断不和任何指令相关联</span></p></li></ul></li><li><p><span>异常和中断的响应</span></p><ol start='' ><li><p><span>关中断、保存断点和程序状态（PC和PSW）</span></p></li><li><p><span>识别并转移到相关处理程序</span></p><ul><li><p><span>相关程序在内核中执行</span></p></li><li><p><span>中断由软硬件共同实现</span></p></li><li><p><span>软件识别方式：CPU设置一个异常状态寄存器，记录异常原因，OS使用统一的中断查询程序，按优先级查询异常状态寄存器，一个个处理</span></p></li><li><p><span>异常和中断响应非常类似，这也是为什么有时将两者统称中断</span></p></li></ul></li><li><p><span>中断服务处理</span></p><ul><li><p><span>保护现场、开中断、中断处理、关中断、恢复现场、开中断、中断返回</span></p></li><li><p><span>中断处理时是开中断的</span></p></li></ul></li></ol></li></ul><h4 id='指令流水线'><span>指令流水线</span></h4><ul><li><p><span>处理机并行性的提升</span></p><ul><li><p><span>时间并行</span></p><ul><li><p><span>将任务分解，每个子任务在不同功能部件中执行，代表即流水线技术</span></p></li><li><p><span>只有</span><em><span>任务密集型</span></em><span>的应用才适合流水线技术，</span><em><span>流水线技术对单个运算无法提升性能</span></em></p></li></ul></li><li><p><span>空间并行</span></p><ul><li><p><span>设置多个功能相同的部件，同时执行任务，代表即多核CPU</span></p></li></ul></li></ul></li><li><p><span>实现</span></p><ul><li><p><span>数据通路与控制信号</span></p><ul><li><p><span>每个流水段后面都要加流水寄存器，以让本段的执行结果让下一流水段也能使用</span></p></li></ul></li><li><p><span>执行过程（</span><em><span>取译执访写</span></em><span>）</span></p><ol start='' ><li><p><span>取指（IF）</span></p></li></ol><ul><li><p><span>从指令寄存器或 Cache 中取指令</span></p></li></ul><ol start='2' ><li><p><span>译码/读寄存器（ID）</span></p></li></ol><ul><li><p><span>操作控制器对指令译码，同时从寄存器堆中取操作数</span></p></li><li><p><span>指令译码器 ID 仅在本过程中使用，取指和执行都不需要ID的参与</span></p></li></ul><ol start='3' ><li><p><span>执行/计算地址（EX）</span></p></li></ol><ul><li><p><span>执行运算或计算地址</span></p></li></ul><ol start='4' ><li><p><span>访存（MEM）</span></p></li></ol><ul><li><p><span>对存储器进行读写操作</span></p></li></ul><ol start='5' ><li><p><span>写回（WB）</span></p></li></ol><ul><li><p><span>将指令执行结果写回寄存器</span></p></li></ul></li><li><p><span>理想情况下，CPI等于1，即每个时钟周期都有一条指令完成</span></p></li></ul></li><li><p><span>流水线冒险</span></p><ul><li><p><span>结构冒险</span></p><ul><li><p><span>即</span><em><span>资源冲突</span></em><span>，指令访存阶段时，同时访问同一存储器</span></p></li><li><p><span>解决</span></p><ul><li><p><em><span>前一指令访存时，使后一个指令暂停一个时钟周期</span></em></p></li><li><p><span>单独设置数据存储器和指令寄存器，例如指令和数据分离的Cache</span></p></li></ul></li></ul></li><li><p><span>数据冒险</span></p><ul><li><p><span>即数据依赖问题，</span><em><span>下一条指令会用到当前指令的计算结果</span></em></p></li><li><p><span>是对流水线影响</span><em><span>最为严重</span></em><span>的冒险</span></p></li><li><p><span>分类</span></p><ul><li><p><span>（没有）写后（才）读</span></p><ul><li><p><em><span>RAW，读到的就是旧数据</span></em></p></li><li><p><em><span>按序流动的流水线仅会出现 RAW 而不会有其它数据冒险</span></em></p></li></ul></li><li><p><span>读后写</span></p><ul><li><p><span>WAR，没有先读后写，读到的就是错误的新数据</span></p></li></ul></li><li><p><span>写后写</span></p><ul><li><p><span>WAW，写的顺序出了问题，使数据出问题</span></p></li></ul></li></ul></li><li><p><span>解决</span></p><ul><li><p><span>遇到的</span><em><span>数据相关的指令暂停几个时钟周期</span></em><span>，直到数据问题消失。可分为硬件阻塞和软件插入方法</span></p></li><li><p><span>设置相关的专用通路（数据旁路技术），不等前一条指令把计算结果写回寄存器，下一条指令也不读寄存器，而是直接从 ALU 中的计算结果作为自己的输入从而开始计算</span></p></li><li><p><span>编译优化，调整指令顺序</span></p></li></ul></li></ul></li><li><p><span>控制冒险</span></p><ul><li><p><span>顺序问题，例如调用、转移指令，让 PC 断流</span></p></li><li><p><span>解决</span></p><ul><li><p><span>分支预测，尽早生成转移目标地址</span></p><ul><li><p><span>静态预测：预测条件不满足就继续执行后续指令</span></p></li><li><p><span>动态预测：根据程序执行的历史情况，动态地进行预测，准确率较高</span></p></li></ul></li><li><p><span>加快形成条件码</span></p></li><li><p><span>预取转移成功和不成功两个方向上的目标指令</span></p></li><li><p><span>在分支指令中加入若干空操作</span></p></li></ul></li></ul></li></ul></li><li><p><span>性能指标</span></p><ul><li><p><span class='math-in-toc'>$吞吐率TP=任务数/总时长$</span></p><ul><li><p><span>当任务数 n 趋近无限大时，最大吞吐率为时钟周期的倒数</span></p></li></ul></li><li><p><span class='math-in-toc'>$加速比S=不使用与使用流水线的时间比$</span></p><ul><li><p><span>n 趋近无限大时，</span><em><span>最大加速比为流水线段数 k</span></em></p></li></ul></li></ul></li><li><p><span>高级流水线</span></p><ul><li><p><span>超标量流水线</span></p><ul><li><p><span>用</span><em><span>度</span></em><span>来表示层数</span></p></li><li><p><span>也称动态多发射技术，可乱序执行</span></p></li><li><p><em><span>设置多个相同的部件</span></em><span>，实现指令并行+流水线</span></p></li></ul></li><li><p><span>超长指令字</span></p><ul><li><p><span>也称静态多发射技术</span></p></li><li><p><span>将</span><em><span>能并行</span></em><span>的指令组合成超长指令字</span></p></li></ul></li><li><p><span>超流水线</span></p><ul><li><p><span>尽量将流水段级数划分得更多</span></p></li></ul></li></ul></li></ul><h4 id='多处理机'><span>多处理机</span></h4><ul><li><p><span>SISD、SIMD、MIMD的概念</span></p><ul><li><p><span>SIMD 单指令多数据，也称数据级并行技术，即一条指令处理多个数据</span></p></li><li><p><span>SIMD 在处理 for 循环最有效，在条件分支如 switch 语句时效率最低</span></p></li><li><p><span>向量处理器是 SIMD 的变体，在数值模拟等领域中性能较高</span></p></li></ul></li><li><p><span>硬件多线程</span></p><ul><li><p><span>细粒度多线程</span></p><ul><li><p><em><span>交叉执行</span></em><span>，可乱序执行，每个clock都可切换线程</span></p></li></ul></li><li><p><span>粗粒度多线程</span></p><ul><li><p><span>交叉执行，但仅出现了阻塞才切换线程</span></p></li></ul></li><li><p><span>同时多线程 SMT</span></p><ul><li><p><span>指令级并行+线程级并行</span></p></li><li><p><span>可以</span><em><span>并行</span></em><span>执行，本质上是</span><em><span>复制了必要的线程资源</span></em><span>让两个线程同时运行，可能会出现抢资源的情况</span></p></li><li><p><span>Intel 的超线程技术就是此类</span></p></li></ul></li></ul></li><li><p><span>多核处理器</span></p><ul><li><p><span>真正意义上的并行</span></p></li><li><p><span>必须采用</span><em><span>多线程</span></em><span>技术才能发挥作用</span></p></li></ul></li><li><p><span>共享内存多处理器 SMP</span></p><ul><li><p><span>共享的单一物理地址空间的多处理器</span></p></li><li><p><span>分为：统一存储访问和非统一存储访问</span></p></li></ul></li></ul><p>&nbsp;</p><h2 id='总线'><span>总线</span></h2><h4 id='总线的概念'><span>总线的概念</span></h4><ul><li><p><span>作用</span></p><ul><li><p><span>为了</span><em><span>减少线的条数</span></em></p></li><li><p><span>总线</span><em><span>不能提高速度和并行能力</span></em><span>，专线才可以</span></p></li></ul></li><li><p><span>特点</span></p><ul><li><p><span>分时：同一时刻只有一个部件可发送信息</span></p></li><li><p><span>共享：总线的每个部位可同时接受相同信息</span></p></li></ul></li></ul><h4 id='总线分类'><span>总线分类</span></h4><ul><li><p><span>片内总线</span></p><ul><li><p><span>芯片内部的总线，连接寄存器之间、运算器之间</span></p></li></ul></li><li><p><span>系统总线</span></p><ul><li><p><span>数据总线</span></p><ul><li><p><em><span>双向</span></em><span>传输总线，位数与机器字长有关</span></p></li><li><p><em><span>每一位都有一根数据线</span></em><span>，即32位就有32根数据线</span></p></li></ul></li><li><p><span>地址总线</span></p><ul><li><p><em><span>单向</span></em><span>传输总线，位数与主存地址空间大小有关</span></p></li><li><p><span>不仅可以选择主存地址，还有 IO 接口</span></p></li></ul></li><li><p><span>控制总线</span></p><ul><li><p><span>传输读或写信号，</span><em><span>瞬时单向，总体上可视为双向</span></em></p></li></ul></li></ul></li><li><p><span>局部总线</span></p><ul><li><p><span>能节省系统总带宽，主要针对高速设备</span></p></li></ul></li><li><p><span>IO总线</span></p><ul><li><p><span>用于连接中低速的 IO 设备，将低速与高速设备分离，提升性能</span></p></li></ul></li><li><p><span>通信总线</span></p><ul><li><p><span>也称外部总线，在计算机之间传输信息</span></p></li></ul></li></ul><h4 id='系统总线的结构'><span>系统总线的结构</span></h4><ul><li><p><span>单总线</span></p><ul><li><p><span>不是只有一根线，而是所有设备都挂在一组总线上，</span><em><span>允许任何设备之间直接交换信息</span></em></p></li><li><p><span>结构简单成本低</span></p></li></ul></li><li><p><span>双总线</span></p><ul><li><p><em><span>主存总线</span></em><span>：CPU、主存和通道之间传输信息</span></p></li><li><p><span>IO 总线：外部设备和通道之间传输信息</span></p></li></ul></li><li><p><span>三总线</span></p><ul><li><p><span>主存总线、IO 总线、DMA 总线</span></p></li><li><p><span>提升了 IO 设备的性能，但系统工作效率低</span></p></li></ul></li></ul><h4 id='常见的总线标准'><span>常见的总线标准</span></h4><ul><li><p><span>SATA、PCI、USB等</span></p></li><li><p><span>PCI总线是系统总线，USB是设备总线，用于连接IO设备</span></p></li><li><p><span>总线一般都是</span><em><span>串行传输</span></em><span>的，串行总线就是一次传输有个数据</span></p></li></ul><h4 id='总线的性能指标'><span>总线的性能指标</span></h4><ul><li><p><span class='math-in-toc'>$总线带宽=总线频率 * 总线宽度(数据位数)$</span></p></li></ul><h4 id='总线事务'><span>总线事务</span></h4><ul><li><p><span>从</span><em><span>请求总线到完成总线</span></em><span>的一个操作序列，其时间称为总线周期</span></p></li><li><p><em><span>请求、仲裁、寻址、传输、释放</span></em><span>五个阶段</span></p><ul><li><p><span>传输阶段一般只能传输</span><em><span>一个字长</span></em><span>的数据</span></p></li></ul></li><li><p><span>突发传送方式可以成组地传输数据，</span><em><span>每个时钟周期都可传输一个字长的信息，一组传输完成后再释放总线</span></em><span>，也能提升总线传输速率</span></p></li></ul><h4 id='总线定时'><span>总线定时</span></h4><ul><li><p><span>同步定时方式</span></p><ul><li><p><span>采用统一的时钟来协调传输双方的关系</span></p></li><li><p><em><span>速度快</span></em><span>，逻辑简单，但可靠性较差。适用于</span><em><span>总线长度较短和部件之间存取时间比较接近</span></em><span>的系统</span></p></li></ul></li><li><p><span>异步定时方式</span></p><ul><li><p><span>没有统一时钟，双方采用</span><em><span>握手和挥手</span></em><span>方式，传输时间按需分配</span></p></li><li><p><span>总线周期长度可变，能保证速度差距很大的设备传输信息。但比同步控制方式复杂，且</span><em><span>速度更慢</span></em></p></li><li><p><span>每次握手传输</span><em><span>一次</span></em><span>数据</span></p></li><li><p><span>不互锁</span></p><ul><li><p><span>主设备发出请求信号后，</span><em><span>不必等到回复</span></em><span>，而是过一段时间就可撤销请求，从设备同理</span></p></li></ul></li><li><p><span>半互锁</span></p><ul><li><p><em><span>主设备必须等</span></em><span>到从设备的回复后才可撤销请求，但</span><em><span>从设备不必等</span></em><span>到主设备的请求撤销，就可撤销回答信号</span></p></li></ul></li><li><p><span>全互锁</span></p><ul><li><p><span>都需要等到对方的回复后才可撤销</span></p></li></ul></li></ul></li><li><p><span>高速和低速设备之间可同步也可异步，只是</span><em><span>同步会限制高速设备的发挥</span></em></p></li><li><p><em><span>半同步总线</span></em><span>可使用同步或异步定时方式，例如 PCI</span></p></li></ul><p>&nbsp;</p><h2 id='输入输出系统'><span>输入输出系统</span></h2><h4 id='io接口'><span>I/O接口</span></h4><ul><li><p><span>功能</span></p><ul><li><p><span>IO 接口又称设备控制器，用于地址译码和设备选择、数据缓冲、信号格式的转换、通信控制</span></p></li><li><p><em><span>IO 设备不可能和总线直接相连</span></em><span>，必须通过IO接口</span></p></li></ul></li><li><p><span>基本结构</span></p><ul><li><p><span>IO总线：</span><em><span>数据线、地址线、控制线</span></em><span>等</span></p></li><li><p><span>控制线仅发送</span><em><span>读/写</span></em><span>信号，地址线仅单向传输</span><em><span>地址</span></em><span>，其它均由数据线传输</span></p></li></ul></li><li><p><span>接口和端口的区别</span></p><ul><li><p><span>端口指接口电路中可读写的</span><em><span>寄存器</span></em><span>，若干端口加上控制逻辑才成为接口</span></p></li></ul></li><li><p><span>I/O 端口及编址</span></p><ul><li><p><em><span>CPU能对数据端口读写，对状态端口只能读，对控制端口只能写</span></em></p></li><li><p><span>编址方式</span></p><ul><li><p><span>统一编址</span></p><ul><li><p><span>当作存储器单元，不需要专门的 IO 指令，但会占用内存地址，且速度较慢</span></p></li><li><p><span>靠不同的</span><em><span>地址码</span></em><span>区分主存和外设</span></p></li></ul></li><li><p><span>独立编址</span></p><ul><li><p><span>又称 IO 映射方式，设置专门的 IO 指令来访问 IO 端口，编制清晰便于理解，但增加了控制的复杂性</span></p></li><li><p><span>IO 指令是机器指令的一种，其格式和通用指令格式有所不同</span></p></li><li><p><span>靠不同的</span><em><span>指令</span></em><span>区分主存和外设</span></p></li></ul></li><li><p><span>无论主存还是外设，程序员都使用</span><em><span>逻辑地址</span></em><span>进行访问</span></p></li></ul></li></ul></li></ul><h4 id='io方式'><span>I/O方式</span></h4><ul><li><p><span>程序查询方式</span></p><ul><li><p><span>完全由 CPU 执行程序来实现</span></p></li><li><p><span>独占查询</span></p><ul><li><p><span>CPU启动 IO 后，就必须停止程序的运行，并开始询问IO状态，直到外设准备就绪</span></p></li><li><p><span>CPU和IO</span><em><span>串行</span></em><span>工作，CPU存在踏步现象，花费了大量时间来查询，效率非常低</span></p></li><li><p><span>四种 IO 方式中，只有</span><em><span>程序查询方式（独占）是 CPU 和 IO 串行的</span></em><span>，其它三者都是CPU和IO并行执行</span></p></li><li><p><span>若无特殊说明，默认程序查询方式为独占查询</span></p></li></ul></li><li><p><span>定时查询</span></p><ul><li><p><span>周期性查询接口状态，其时间间隔和数据传输速率有关</span></p></li><li><p><span>必须在外设传输完端口大小的数据时访问端口，否则数据可能丢失</span></p></li></ul></li></ul></li><li><p><span>程序中断方式</span></p><ul><li><p><span>程序中断的概念</span></p><ul><li><p><span>中断是指再出现紧急情况或特殊请求时，暂停执行现程序，转而去处理特殊情况，然后返回断点处继续执行原程序</span></p></li><li><p><span>利用程序中断实现IO：CPU在程序中安排好在某个时间启动外设，随后继续执行程序，直到外设准备好并发出中断请求，则以中断的方式处理 IO</span></p></li><li><p><em><span>外设准备数据时间应当大于中断处理时间</span></em><span>，因为若太快，计算机可能来不及取走缓冲的数据就又被写入了</span></p></li><li><p><span>中断情况下，</span><em><span>外设的数据都要经过CPU</span></em><span>，不和主存</span><em><span>直接</span></em><span>打交道</span></p></li></ul></li><li><p><span>中断的工作流程</span></p><ul><li><p><span>中断请求</span></p><ul><li><p><span>INTR 可屏蔽中断线，NMI 不可屏蔽中断线</span></p></li><li><p><em><span>允许多个中断源</span></em></p></li></ul></li><li><p><span>中断响应判优</span></p><ul><li><p><span>通过硬件排队器实现</span></p></li><li><p><em><span>DMA请求 &gt; NMI &gt;内部异常&gt; INTR</span></em></p></li><li><p><span>硬件故障 &gt; 访管指令 &gt; 程序性</span><em><span>异常</span></em><span> &gt; 外部中断 &gt; IO 中断 &gt; 重新启动</span></p></li><li><p><span>输入设备高于输出设备，高速设备先于低速设备</span></p></li></ul></li><li><p><span>CPU响应中断的条件</span></p><ul><li><p><span>中断源有中断请求</span></p></li><li><p><span>CPU 允许中断及开中断（</span><em><span>异常和不可屏蔽中断不受此限制</span></em><span>）</span></p></li><li><p><span>一条指令执行完毕（异常不受此限制）</span></p></li></ul></li><li><p><span>中断</span><em><span>响应过程</span></em></p><ul><li><p><em><span>响应中断并转而执行中断服务程序</span></em><span>，这些操作</span><em><span>由硬件直接实现</span></em><span>，称为</span><em><span>中断隐指令</span></em></p></li><li><p><span>注意区分中断响应周期（机器周期的一个）和中断响应过程</span></p></li><li><p><span>执行过程</span></p><ol start='' ><li><p><span>关中断</span></p></li></ol><ul><li><p><span>将中断触发器置 0</span></p></li></ul><ol start='2' ><li><p><span>保存断点和状态到栈或特定寄存器中：PC、PSW</span></p></li><li><p><span>引出中断服务程序</span></p></li></ol><ul><li><p><span>识别中断源，并将对应的中断服务程序送入 PC</span></p></li><li><p><span>识别中断源分为</span><em><span>硬件向量法</span></em><span>和</span><em><span>软件查询法</span></em></p></li></ul></li></ul></li><li><p><span>中断向量</span></p><ul><li><p><em><span>中断向量即特定中断程序入口地址</span></em><span>，而中断向量的地址则是地址的地址</span></p></li><li><p><span>CPU 响应中断后，计算出中断向量的地址，然后在</span><em><span>中断向量表</span></em><span>中取出中断向量，并送入PC</span></p></li><li><p><span>操作系统初始化时需要创建中断向量表</span></p></li></ul></li><li><p><span>中断</span><em><span>处理过程</span></em></p><ol start='' ><li><p><span>关中断、保存断点、引出中断服务</span></p></li></ol><ul><li><p><span>这些是硬件实现的中断隐指令，也就是响应中断</span></p></li></ul><ol start='2' ><li><p><span>保存现场和屏蔽字、开中断、执行中断服务、关中断、恢复现场和屏蔽字、开中断、中断返回</span></p></li></ol><ul><li><p><span>由中断服务程序完成</span></p></li><li><p><span>执行中断服务程序时是开中断，允许更高级的中断发生</span></p></li></ul></li></ul></li><li><p><span>多重中断和中断屏蔽技术</span></p><ul><li><p><span>优先级高的（严格高于）中断有权中断优先级低的中断</span></p></li><li><p><span>中断屏蔽技术</span></p><ul><li><p><span>每个中断源都有一个屏蔽触发器，</span><em><span>1 表示屏蔽该中断，0 表示可以被该中断插入</span></em><span>（1屏蔽）</span></p></li><li><p><span>比如有ABCD四个中断，若 A 的优先级最高，则 A 的屏蔽字为 1111，即没有可中断A的中断，A 处理时能屏蔽所有中断</span></p></li><li><p><span>中断屏蔽标志</span><em><span>仅改变中断的处理顺序</span></em><span>而不是优先级</span></p></li></ul></li></ul></li></ul></li><li><p><span>DMA方式</span></p><ul><li><p><span>特点</span></p><ul><li><p><span>完全由</span><em><span>硬件</span></em><span>进行成组信息的传输，IO和主机</span><em><span>并行</span></em><span>工作，程序和传送并行工作</span></p></li><li><p><em><span>主存和 DMA 接口</span></em><span>之间有一条直接的逻辑数据通路，降低了CPU负担，</span><em><span>数据传送不经过CPU</span></em></p></li><li><p><em><span>仅在开始和结束时 CPU 要介入，仅在传送结束时产生中断</span></em></p></li><li><p><span>DMA 传送时</span><em><span>接管 CPU 的系统总线</span></em><span>：数据、控制、地址总线，即DMA控制器必须有控制总线的能力</span></p></li><li><p><span>多路 DMA 也可以用于多个慢速设备，即 </span><em><span>DMA 不一定是快速设备</span></em></p></li><li><p><em><span>传输一个字占一个存取周期，也就是一个机器周期</span></em></p></li><li><p><span>DMA 不会破坏 PC 和寄存器的内容，故</span><em><span>不需要保护现场</span></em></p></li><li><p><em><span>DMA 请求是由外设发出的</span></em><span>，而 </span><em><span>DMA 控制器发送总线上的请求</span></em></p></li><li><p><span>DMA 及其它方式均由</span><em><span>驱动程序</span></em><span>（直接和硬件打交道）设置传送参数</span></p></li></ul></li><li><p><span>DMA控制器（DMA接口）的组成</span></p><ul><li><p><span>主存地址计数器（存放主存地址）、传送长度计数器、数据缓冲计数器（DMAC）、DMA请求触发器、控制/状态逻辑、中断机构</span></p></li></ul></li><li><p><span>DMA的传送方式</span></p><ul><li><p><span>停止 CPU 访存</span></p><ul><li><p><span>直到数据传输完毕时才回复 CPU 的控制权</span></p></li></ul></li><li><p><span>周期挪用</span></p><ul><li><p><span>当有 DMA 请求，且 CPU 想访存时，IO 设备挪用几个存取周期，传送完一个数据后立刻释放总线</span></p></li></ul></li><li><p><span>DMA 和 CPU 交替访存</span></p><ul><li><p><span>把 CPU  工作周期（执行一条指令的时长）分为两部分，分别供DMA和CPU使用</span></p></li><li><p><span>适用于 CPU 工作周期比主存存取周期</span><em><span>长</span></em><span>的情况</span></p></li></ul></li></ul></li><li><p><span>DMA的传输过程</span></p><ul><li><p><span>预处理、传输、后处理</span></p></li><li><p><em><span>数据传输阶段完全由硬件控制，后处理中包含中断</span></em></p></li></ul></li><li><p><span>DMA方式和中断方式的区别</span></p><ul><li><p><span>DMA 请求优先级高于中断</span></p></li><li><p><span>中断方式需要保护和恢复现场，但 DMA 不需要</span></p></li><li><p><span>对中断的响应只能在指令执行完毕的中断查询周期中</span></p></li><li><p><span>中断传输需要 CPU 干预，而 </span><em><span>DMA 方式不需要</span></em></p></li><li><p><span>DMA 仅进行数据的传输，</span><em><span>中断有处理异常的能力</span></em></p></li><li><p><em><span>中断方式靠程序传送，而DMA方式靠硬件</span></em></p></li></ul></li></ul></li><li><p><span>通道控制方式</span></p><ul><li><p><span>是 DMA 方式的发展，但却是一种</span><em><span>程序控制</span></em><span>方式</span></p></li><li><p><span>IO 通道也能执行指令（专门的指令）</span></p></li><li><p><span>通道程序存放在主存中，由通道从主存中取出并执行，且只能在具有通道的 IO 系统中使用</span></p></li></ul></li></ul><p>&nbsp;</p></div></div>

<script>(function(){function e(e,n,i){document.addEventListener(e,function(e){if(!e.defaultPrevented)for(var t=e.target;t&&t!=this;t=t.parentNode)if(t.matches(n)){!1===i.call(t,e)&&(e.preventDefault(),e.stopPropagation());break}},!1)}var t=document.body.parentElement,i=[],r=null,o=document.body.classList.contains("typora-export-collapse-outline");function a(){return t.scrollTop}e("click",".outline-expander",function(e){var t=this.closest(".outline-item-wrapper").classList;return t.contains("outline-item-open")?t.remove("outline-item-open"):t.add("outline-item-open"),u(),!1}),e("click",".outline-item",function(e){var t=this.querySelector(".outline-label");location.hash="#"+t.getAttribute("href"),o&&((t=this.closest(".outline-item-wrapper").classList).contains("outline-item-open")||t.add("outline-item-open"),d(),t.add("outline-item-active"))});function s(){var e=a();r=null;for(var t=0;t<i.length&&i[t][1]-e<60;t++)r=i[t]}function n(){c=setTimeout(function(){var n;i=[],n=a(),document.querySelector("#write").querySelectorAll("h1, h2, h3, h4, h5, h6").forEach(e=>{var t=e.getAttribute("id");i.push([t,n+e.getBoundingClientRect().y])}),s(),u()},300)}var l,c,d=function(){document.querySelectorAll(".outline-item-active").forEach(e=>e.classList.remove("outline-item-active")),document.querySelectorAll(".outline-item-single.outline-item-open").forEach(e=>e.classList.remove("outline-item-open"))},u=function(){if(r&&(d(),t=document.querySelector('.outline-label[href="#'+(CSS.escape?CSS.escape(r[0]):r[0])+'"]')))if(o){var e=t.closest(".outline-item-open>ul>.outline-item-wrapper");if(e)e.classList.add("outline-item-active");else{for(var t,n=(t=t.closest(".outline-item-wrapper")).parentElement.closest(".outline-item-wrapper");n;)n=(t=n).parentElement.closest(".outline-item-wrapper");t.classList.add("outline-item-active")}}else t.closest(".outline-item-wrapper").classList.add("outline-item-active")};window.addEventListener("scroll",function(e){l&&clearTimeout(l),l=setTimeout(function(){s(),u()},300)});window.addEventListener("resize",function(e){c&&clearTimeout(c),n()}),n()})();</script></body>
</html>